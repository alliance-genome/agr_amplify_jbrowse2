{"version":3,"sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"names":["CramSlightlyLazyFeature","record","store","_store","this","readName","alignmentStart","lengthOnRef","readFeatures","mappingQuality","flags","isReverseComplemented","rg","samHeader","readGroups","readGroupId","undefined","qualityScores","join","refIdToName","sequenceId","_get_seq_id","mate","isPaired","getPairOrientation","templateLength","templateSize","RG","_read_group_id","tags","getReadBases","seq","cigar","op","oplen","ref","_refRegion","refStart","start","last_pos","sublen","forEach","code","refPos","sub","data","substring","ret","split","added","String","fromCharCode","length","readLength","Object","getOwnPropertyNames","prototype","filter","prop","startsWith","map","methodName","replace","id","uniqueId","field","mismatches","get","type","cliplen","t","val","name","qual","qualRaw","args","pos","push","base","altbase","len","_get_mismatches","CramAdapter","setupP","seqIdToRefName","seqIdToOriginalRefName","cramLocation","readConfObject","config","craiLocation","Error","cram","IndexedCramFile","cramFilehandle","openLocation","pluginManager","index","CraiIndex","filehandle","seqFetch","bind","checkSequenceMD5","fetchSizeLimit","sequenceAdapterType","getSubAdapter","seqConf","sequenceAdapter","dataAdapter","BaseFeatureDataAdapter","opts","a","configure","getHeaderText","seqId","end","refName","refIdToOriginalName","getFeatures","assemblyName","pipe","toArray","toPromise","seqChunks","sequence","sort","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","substr","toLocaleString","statusCallback","configured","getSamHeader","signal","idToName","nameToId","l","tag","sqLine","refId","item","value","rgLine","find","setupPre","catch","e","setup","indexOf","region","originalRefName","ObservableCreate","observer","getRefNames","refNameToId","getRecordsForRange","records","checkAbortSignal","next","cramRecordToFeature","console","warn","complete","regions","bytesForRegions","bytes","_opts","Promise","all","chrId","getEntriesForRange","blockResults","flat","reduce","sliceBytes"],"mappings":"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","file":"static/js/37.01b468ed.chunk.js","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\n\nimport CramAdapter from './CramAdapter'\n\nexport interface Mismatch {\n  qual?: number\n  start: number\n  length: number\n  type: string\n  base: string\n  altbase?: string\n  seq?: string\n  cliplen?: number\n}\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  private _store: CramAdapter\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(private record: any, store: CramAdapter) {\n    this._store = store\n  }\n\n  _get_name() {\n    return this.record.readName\n  }\n\n  _get_start() {\n    return this.record.alignmentStart - 1\n  }\n\n  _get_end() {\n    return this.record.alignmentStart + this.record.lengthOnRef - 1\n  }\n\n  _get_cram_read_features() {\n    return this.record.readFeatures\n  }\n\n  _get_type() {\n    return 'match'\n  }\n\n  _get_score() {\n    return this.record.mappingQuality\n  }\n\n  _get_flags() {\n    return this.record.flags\n  }\n\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _read_group_id() {\n    const rg = this._store.samHeader.readGroups\n    return rg ? rg[this.record.readGroupId] : undefined\n  }\n\n  _get_qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  qualRaw() {\n    return this.record.qualityScores\n  }\n\n  _get_seq_id() {\n    return this._store.refIdToName(this.record.sequenceId)\n  }\n\n  _get_refName() {\n    return this._get_seq_id()\n  }\n\n  _get_is_paired() {\n    return !!this.record.mate\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  _get_next_seq_id() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.mate ? this.record.mate.alignmentStart : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  _get_tags() {\n    const RG = this._read_group_id()\n    const { tags } = this.record\n    // avoids a tag copy if no RG, but just copy if there is one\n    return RG !== undefined ? { ...tags, RG } : tags\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  _get_CIGAR() {\n    let seq = ''\n    let cigar = ''\n    let op = 'M'\n    let oplen = 0\n\n    // not sure I should access these, but...\n    const ref = this.record._refRegion.seq\n    const refStart = this.record._refRegion.start\n    let last_pos = this.record.alignmentStart\n    let sublen = 0\n    if (typeof this.record.readFeatures !== 'undefined') {\n      // @ts-ignore\n      this.record.readFeatures.forEach(({ code, refPos, sub, data }) => {\n        sublen = refPos - last_pos\n        seq += ref.substring(last_pos - refStart, refPos - refStart)\n        last_pos = refPos\n\n        if (oplen && op !== 'M') {\n          cigar += oplen + op\n          oplen = 0\n        }\n        if (sublen) {\n          op = 'M'\n          oplen += sublen\n        }\n\n        if (code === 'b') {\n          // An array of bases stored verbatim\n          const ret = data.split(',')\n          const added = String.fromCharCode(...ret)\n          seq += added\n          last_pos += added.length\n          oplen += added.length\n        } else if (code === 'B') {\n          // Single base (+ qual score)\n          seq += sub\n          last_pos++\n          oplen++\n        } else if (code === 'X') {\n          // Substitution\n          seq += sub\n          last_pos++\n          oplen++\n        } else if (code === 'D' || code === 'N') {\n          // Deletion or Ref Skip\n          last_pos += data\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += data + code\n          oplen = 0\n        } else if (code === 'I' || code === 'S') {\n          // Insertion or soft-clip\n          seq += data\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += data.length + code\n          oplen = 0\n        } else if (code === 'i') {\n          // Single base insertion\n          seq += data\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += `${1}I`\n          oplen = 0\n        } else if (code === 'P') {\n          // Padding\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += `${data}P`\n        } else if (code === 'H') {\n          // Hard clip\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += `${data}H`\n          oplen = 0\n        } // else q or Q\n      })\n    } else {\n      sublen = this.record.readLength - seq.length\n    }\n    if (seq.length !== this.record.readLength) {\n      sublen = this.record.readLength - seq.length\n      seq += ref.substring(last_pos - refStart, last_pos - refStart + sublen)\n\n      if (oplen && op !== 'M') {\n        cigar += oplen + op\n        oplen = 0\n      }\n      op = 'M'\n      oplen += sublen\n    }\n    if (oplen) {\n      cigar += oplen + op\n    }\n    return cigar\n  }\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      CramSlightlyLazyFeature.prototype,\n    )\n    return properties\n      .filter(\n        prop =>\n          prop.startsWith('_get_') &&\n          prop !== '_get_mismatches' &&\n          prop !== '_get_skips_and_dels' &&\n          prop !== '_get_cram_read_features',\n      )\n      .map(methodName => methodName.replace('_get_', ''))\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string) {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) {\n      // @ts-ignore\n      return this[methodName]()\n    }\n    return undefined\n  }\n\n  parent(): undefined | Feature {\n    return undefined\n  }\n\n  children(): undefined | Feature[] {\n    return undefined\n  }\n\n  set(): void {}\n\n  pairedFeature() {\n    return false\n  }\n\n  _get_clipPos() {\n    const mismatches = this.get('mismatches')\n    if (mismatches.length) {\n      const record =\n        this.get('strand') === -1\n          ? mismatches[mismatches.length - 1]\n          : mismatches[0]\n      const { type, cliplen } = record\n      if (type === 'softclip' || type === 'hardclip') {\n        return cliplen\n      }\n    }\n    return 0\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const tags: Record<string, any> = {}\n    this.tags().forEach((t: string) => {\n      const val = this.get(t)\n      if (val !== undefined) {\n        tags[t] = val\n      }\n    })\n\n    return {\n      ...tags,\n      name: this.get('name'),\n      type: this.get('type'),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches(): Mismatch[] {\n    const readFeatures = this.get('cram_read_features')\n    const qual = this.qualRaw()\n    if (!readFeatures) {\n      return []\n    }\n    const start = this.get('start')\n    const mismatches: Mismatch[] = []\n    readFeatures.forEach(\n      (args: {\n        code: string\n        refPos: number\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        data: any\n        pos: number\n        sub: string\n        ref: string\n      }) => {\n        const { code, pos, data, sub, ref } = args\n        const refPos = args.refPos - 1 - start\n        if (code === 'X') {\n          // substitution\n          mismatches.push({\n            start: refPos,\n            length: 1,\n            base: sub,\n            qual: qual?.[pos],\n            altbase: ref,\n            type: 'mismatch',\n          })\n        } else if (code === 'I') {\n          // insertion\n          mismatches.push({\n            start: refPos,\n            type: 'insertion',\n            base: `${data.length}`,\n            length: 0,\n          })\n        } else if (code === 'N') {\n          // reference skip\n          mismatches.push({\n            type: 'skip',\n            length: data,\n            start: refPos,\n            base: 'N',\n          })\n        } else if (code === 'S') {\n          // soft clip\n          const len = data.length\n          mismatches.push({\n            start: refPos,\n            type: 'softclip',\n            base: `S${len}`,\n            cliplen: len,\n            length: 1,\n          })\n        } else if (code === 'P') {\n          // padding\n        } else if (code === 'H') {\n          // hard clip\n          const len = data\n          mismatches.push({\n            start: refPos,\n            type: 'hardclip',\n            base: `H${len}`,\n            cliplen: len,\n            length: 1,\n          })\n        } else if (code === 'D') {\n          // deletion\n          mismatches.push({\n            type: 'deletion',\n            length: data,\n            start: refPos,\n            base: '*',\n          })\n        } else if (code === 'b') {\n          // stretch of bases\n        } else if (code === 'q') {\n          // stretch of qual scores\n        } else if (code === 'B') {\n          // a pair of [base, qual]\n        } else if (code === 'i') {\n          // single-base insertion\n          // insertion\n          mismatches.push({\n            start: refPos,\n            type: 'insertion',\n            base: data,\n            length: 1,\n          })\n        } else if (code === 'Q') {\n          // single quality value\n        }\n      },\n    )\n    return mismatches\n  }\n\n  _get_skips_and_dels(): Mismatch[] {\n    return this._get_mismatches()\n  }\n}\n","import { CraiIndex, IndexedCramFile } from '@gmod/cram'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { checkAbortSignal } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { toArray } from 'rxjs/operators'\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\n\ninterface HeaderLine {\n  tag: string\n  value: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  data: HeaderLine[]\n}\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: number[]\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  samHeader: Header = {}\n\n  private setupP?: Promise<{\n    samHeader: Header\n    cram: any // eslint-disable-line @typescript-eslint/no-explicit-any\n    sequenceAdapter: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  }>\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configure() {\n    const cramLocation = readConfObject(this.config, 'cramLocation')\n    const craiLocation = readConfObject(this.config, 'craiLocation')\n    if (!cramLocation) {\n      throw new Error('missing cramLocation argument')\n    }\n    if (!craiLocation) {\n      throw new Error('missing craiLocation argument')\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const cram: any = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation, this.pluginManager),\n      index: new CraiIndex({\n        filehandle: openLocation(craiLocation, this.pluginManager),\n      }),\n      seqFetch: this.seqFetch.bind(this),\n      checkSequenceMD5: false,\n      fetchSizeLimit: 200_000_000, // just make this a large size to avoid hitting it\n    })\n    // instantiate the sequence adapter\n    const sequenceAdapterType = readConfObject(this.config, [\n      'sequenceAdapter',\n      'type',\n    ])\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const seqConf = readConfObject(this.config, 'sequenceAdapter')\n    const { dataAdapter: sequenceAdapter } = await this.getSubAdapter(seqConf)\n\n    if (!(sequenceAdapter instanceof BaseFeatureDataAdapter)) {\n      throw new Error(\n        `CRAM feature adapters cannot use sequence adapters of type '${sequenceAdapterType}'`,\n      )\n    }\n\n    return { cram, sequenceAdapter }\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    return cram.cram.getHeaderText(opts)\n  }\n\n  private async seqFetch(seqId: number, start: number, end: number) {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const { sequenceAdapter } = await this.configure()\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) {\n      return undefined\n    }\n\n    const seqChunks = await sequenceAdapter\n      .getFeatures({\n        refName,\n        start,\n        end,\n        assemblyName: '',\n      })\n      .pipe(toArray())\n      .toPromise()\n\n    const sequence = seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .map(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        return chunkSeq.substr(trimStart, trimLength)\n      })\n      .join('')\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const configured = await this.configure()\n    statusCallback('Downloading index')\n    const { cram } = configured\n    const samHeader: HeaderLine[] = await cram.cram.getSamHeader(opts?.signal)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    samHeader\n      .filter(l => l.tag === 'SQ')\n      .forEach((sqLine, refId) => {\n        sqLine.data.forEach(item => {\n          if (item.tag === 'SN') {\n            // this is the ref name\n            const refName = item.value\n            nameToId[refName] = refId\n            idToName[refId] = refName\n          }\n        })\n      })\n\n    const readGroups = samHeader\n      .filter(l => l.tag === 'RG')\n      .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n    const data = { idToName, nameToId, readGroups }\n    statusCallback('')\n    this.samHeader = data\n    return { samHeader: data, ...configured }\n  }\n\n  private async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    if (!samHeader.idToName) {\n      throw new Error('CRAM file has no header lines')\n    }\n    return samHeader.idToName\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    if (this.samHeader.idToName) {\n      return this.samHeader.idToName[refId]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName[refId]\n    }\n    return undefined\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions,\n  ) {\n    const { signal, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram, sequenceAdapter } = await this.setup(opts)\n      statusCallback('Downloading alignments')\n      if (!this.seqIdToRefName) {\n        this.seqIdToRefName = await sequenceAdapter.getRefNames(opts)\n      }\n      const refId = this.refNameToId(refName)\n      if (refId !== undefined) {\n        if (originalRefName) {\n          this.seqIdToOriginalRefName[refId] = originalRefName\n        }\n        const records = await cram.getRecordsForRange(refId, start, end, opts)\n        checkAbortSignal(signal)\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        records.forEach((record: any) => {\n          observer.next(this.cramRecordToFeature(record))\n        })\n      } else {\n        console.warn('Unknown refName', refName)\n      }\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  cramRecordToFeature(record: unknown) {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n\n  // we return the configured fetchSizeLimit, and the bytes for the region\n  async estimateRegionsStats(regions: Region[], opts?: BaseOptions) {\n    const bytes = await this.bytesForRegions(regions, opts)\n    const fetchSizeLimit = readConfObject(this.config, 'fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[], _opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return cram.index.getEntriesForRange(chrId, start, end)\n      }),\n    )\n\n    return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0)\n  }\n}\n"],"sourceRoot":""}