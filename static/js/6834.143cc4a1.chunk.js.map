{"version":3,"file":"static/js/6834.143cc4a1.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BigBedAdapter/BigBedAdapter.ts","../../../plugins/bed/src/util.ts"],"sourcesContent":["import { BigBed, Header } from '@gmod/bbi'\nimport BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { map, mergeAll } from 'rxjs/operators'\n\n// locals\nimport { isUCSC, makeBlocks, ucscProcessedTranscript } from '../util'\n\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n  private cached?: Promise<{ bigbed: BigBed; header: Header; parser: BED }>\n\n  public async configurePre(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bigbed = new BigBed({\n      filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n    })\n    const header = await bigbed.getHeader(opts)\n    const parser = new BED({ autoSql: header.autoSql })\n    return { bigbed, header, parser }\n  }\n\n  public async configure(opts?: BaseOptions) {\n    if (!this.cached) {\n      this.cached = this.configurePre(opts).catch(e => {\n        this.cached = undefined\n        throw e\n      })\n    }\n    return this.cached\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { parser, header } = await this.configure(opts)\n    // @ts-expect-error\n    const { version, fileType } = header\n    const { fields, ...rest } = parser.autoSql\n    return {\n      version,\n      fileType,\n      autoSql: { ...rest },\n      fields: Object.fromEntries(\n        fields.map(({ name, comment }) => [name, comment]),\n      ),\n    }\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    const { signal } = opts\n    const scoreColumn = this.getConf('scoreColumn')\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { parser, bigbed } = await this.configure(opts)\n        const ob = await bigbed.getFeatureStream(\n          region.refName,\n          region.start,\n          region.end,\n          {\n            signal,\n            basesPerSpan: region.end - region.start,\n          },\n        )\n        ob.pipe(\n          mergeAll(),\n          map(feat => {\n            const data = parser.parseLine(\n              `${region.refName}\\t${feat.start}\\t${feat.end}\\t${feat.rest}`,\n              {\n                uniqueId: feat.uniqueId!,\n              },\n            )\n\n            if (feat.uniqueId === undefined) {\n              throw new Error('invalid bbi feature')\n            }\n            const {\n              uniqueId,\n              type,\n              chromStart,\n              chromStarts,\n              blockStarts,\n              blockCount,\n              blockSizes,\n              chromEnd,\n              thickStart,\n              thickEnd,\n              chrom,\n              score,\n              ...rest\n            } = data\n\n            const subfeatures = blockCount\n              ? makeBlocks({\n                  chromStarts,\n                  blockStarts,\n                  blockCount,\n                  blockSizes,\n                  uniqueId,\n                  refName: region.refName,\n                  start: feat.start,\n                })\n              : []\n\n            // collection of heuristics for suggesting that this feature should\n            // be converted to a gene, CNV bigbed has many gene like features\n            // including thickStart and blockCount but no strand\n            return new SimpleFeature({\n              id: `${this.id}-${uniqueId}`,\n              data: isUCSC(data)\n                ? ucscProcessedTranscript({\n                    ...rest,\n                    uniqueId,\n                    type,\n                    start: feat.start,\n                    end: feat.end,\n                    refName: region.refName,\n                    score: scoreColumn ? +data[scoreColumn] : score,\n                    chromStarts,\n                    blockCount,\n                    blockSizes,\n                    thickStart,\n                    thickEnd,\n                    subfeatures,\n                  })\n                : {\n                    ...rest,\n                    uniqueId,\n                    type,\n                    start: feat.start,\n                    score: scoreColumn ? +data[scoreColumn] : score,\n                    end: feat.end,\n                    refName: region.refName,\n                    subfeatures,\n                  },\n            })\n          }),\n        ).subscribe(observer)\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeature } from '@jbrowse/core/util'\n\ninterface MinimalFeature {\n  type: string\n  start: number\n  end: number\n  refName: string\n}\ninterface TranscriptFeat {\n  thickStart: number\n  thickEnd: number\n  blockCount: number\n  blockSizes: number[]\n  chromStarts: number[]\n  refName: string\n  strand?: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function ucscProcessedTranscript(feature: TranscriptFeat) {\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    blockSizes,\n    chromStarts,\n    refName,\n    strand = 0,\n    ...rest\n  } = feature\n\n  if (!thickStart || !thickEnd || !strand) {\n    return feature\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n    ?.forEach(block => {\n      const start = block.start\n      const end = block.end\n      if (thickStart >= end) {\n        // left-side UTR\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n        // UTR | CDS\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push(\n          {\n            type: `${prime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd >= end) {\n        // CDS\n        subfeatures.push({\n          type: 'CDS',\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd < end) {\n        // UTR | CDS | UTR\n        const leftPrime = strand > 0 ? 'five' : 'three'\n        const rightPrime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `${leftPrime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: `CDS`,\n            start: thickStart,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${rightPrime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n        // CDS | UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `CDS`,\n            start,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${prime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickEnd <= start) {\n        // right-side UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      }\n    })\n\n  return { ...rest, strand, type: 'mRNA', refName, subfeatures }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = Object.fromEntries(line.split('\\t').map((f, i) => [fields[i], f]))\n\n  return {\n    ...rest,\n    blockStarts: blockStarts?.split(',').map(r => +r),\n    chromStarts: chromStarts?.split(',').map(r => +r),\n    blockSizes: blockSizes?.split(',').map(r => +r),\n    thickStart: +thickStart,\n    thickEnd: +thickEnd,\n    blockCount: +blockCount,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts: number[]\n  blockSizes: number[]\n  blockStarts: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bmax = bmin + (blockSizes?.[b] || 0)\n    subfeatures.push({\n      uniqueId: `${uniqueId}-${b}`,\n      start: bmin,\n      end: bmax,\n      refName,\n      type: 'block',\n    })\n  }\n  return subfeatures\n}\nexport function featureData(\n  line: string,\n  colRef: number,\n  colStart: number,\n  colEnd: number,\n  scoreColumn: string,\n  parser: BED,\n  uniqueId: string,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const refName = l[colRef]\n  const start = +l[colStart]\n  const colSame = colStart === colEnd ? 1 : 0\n  const end = +l[colEnd] + colSame\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n\n  const {\n    blockCount,\n    blockSizes,\n    blockStarts,\n    chromStarts,\n    thickStart,\n    thickEnd,\n    type,\n    score,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n  const subfeatures = blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts,\n        blockCount,\n        blockSizes,\n        blockStarts,\n      })\n    : []\n  const f = {\n    ...rest,\n    type,\n    score: scoreColumn ? +data[scoreColumn] : score,\n    start,\n    end,\n    refName,\n    uniqueId,\n    subfeatures,\n  }\n  return new SimpleFeature({\n    id: uniqueId,\n    data: isUCSC(data)\n      ? ucscProcessedTranscript({\n          thickStart,\n          thickEnd,\n          blockCount,\n          blockSizes,\n          chromStarts,\n          ...f,\n        })\n      : f,\n  })\n}\n\nexport function isUCSC(f: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return f.thickStart && f.blockCount && f.strand !== 0\n}\n"],"names":["BigBedAdapter","BaseFeatureDataAdapter","configurePre","opts","pm","this","pluginManager","bigbed","BigBed","filehandle","openLocation","getConf","header","getHeader","parser","BED","autoSql","configure","cached","catch","e","undefined","getRefNames","Object","keys","refsByName","version","fileType","fields","rest","fromEntries","map","name","comment","getFeatures","region","signal","scoreColumn","ObservableCreate","async","getFeatureStream","refName","start","end","basesPerSpan","pipe","mergeAll","feat","data","parseLine","uniqueId","Error","type","chromStart","chromStarts","blockStarts","blockCount","blockSizes","chromEnd","thickStart","thickEnd","chrom","score","subfeatures","makeBlocks","SimpleFeature","id","isUCSC","ucscProcessedTranscript","subscribe","observer","error","freeResources","feature","oldSubfeatures","strand","filter","child","sort","a","b","forEach","block","prime","push","leftPrime","rightPrime","starts","bmin","bmax","featureData","line","colRef","colStart","colEnd","names","l","split","colSame","f","i","r","defaultParser","_1","_2","_3"],"sourceRoot":""}