{"version":3,"file":"static/js/477.dc6b1fd6.chunk.js","mappings":"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","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"sourcesContent":["import { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf-8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc && parsedLoc.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (options.hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (options.hasColumnNameLine && options.columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(\n      options.columnNameLineNumber - 1,\n      1,\n    )\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(\n      rowSet,\n      columnNumber,\n      options.isValidRefName,\n    )\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      rowSet.rows.forEach(row => {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, options.isValidRefName)\n      })\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!options.hasColumnNameLine,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"names":["bufferToString","buffer","TextDecoder","fatal","decode","parseWith","_x","_parseWith","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","csv","_args","wrap","_context","prev","next","length","undefined","then","module","default","sent","abrupt","_objectSpread","noheader","output","fromString","stop","dataToSpreadsheetSnapshot","rows","hasColumnNameLine","columnNameLineNumber","isValidRefName","maxCols","rowSet","isLoaded","map","row","rowNumber","id","String","cells","text","columnNumber","columnNames","_rowSet$rows$splice","splice","colNamesRow","_slicedToArray","forEach","cell","columns","columnDisplayOrder","_loop","push","guessedType","parsedLoc","parseLocString","error","refName","start","test","guessColumnType","extendedData","name","dataType","type","hasColumnNames","assemblyName","selectedAssemblyName","parseCsvBuffer","_x2","_parseCsvBuffer","_callee2","_args2","_context2","parseTsvBuffer","_x3","_parseTsvBuffer","_callee3","_args3","_context3","delimiter"],"sourceRoot":""}