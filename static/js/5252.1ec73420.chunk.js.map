{"version":3,"file":"static/js/5252.1ec73420.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/binary-parser/dist/binary_parser.js","../../../node_modules/@gmod/binary-parser/dist/context.js"],"sourcesContent":["\"use strict\";function _typeof(obj) {if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} //= =======================================================================================\n// Globals\n//= =======================================================================================\nvar _require = require(\"buffer\"),Buffer = _require.Buffer;\n\nvar Context = require(\"./context\").Context;\nvar Long = require(\"long\");\n\nif (typeof window !== \"undefined\") window.Buffer = Buffer;\nif (typeof self !== \"undefined\") self.Buffer = Buffer; // this is for webworker, and also is not an elseif to avoid window polyfills in webworker\n\n// https://github.com/ionic-team/rollup-plugin-node-polyfills/blob/9b5fe1a9cafffd4871e6d65613ed224f807ea251/polyfills/vm.js#L129-L132\nfunction runInThisContext(code) {\n  // eslint-disable-next-line no-new-func\n  var fn = new Function(\"code\", \"return eval(code);\");\n  // eslint-disable-next-line no-undef\n  return fn.call(globalThis, code);\n}\n\nvar PRIMITIVE_TYPES = {\n  UInt8: 1,\n  UInt16LE: 2,\n  UInt16BE: 2,\n  UInt32LE: 4,\n  UInt32BE: 4,\n  Int8: 1,\n  Int16LE: 2,\n  Int16BE: 2,\n  Int32LE: 4,\n  Int32BE: 4,\n  FloatLE: 4,\n  FloatBE: 4,\n  DoubleLE: 8,\n  DoubleBE: 8,\n  UInt64: 8,\n  Int64: 8 };\n\n\nvar SPECIAL_TYPES = {\n  String: null,\n  Buffer: null,\n  Array: null,\n  Skip: null,\n  Choice: null,\n  Nest: null,\n  Bit: null,\n  Itf8: null,\n  Ltf8: null };\n\n\nvar aliasRegistry = {};\nvar FUNCTION_PREFIX = \"___parser_\";\n\nvar BIT_RANGE = [];\n(function () {\n  var i;\n  for (i = 1; i <= 32; i++) {\n    BIT_RANGE.push(i);\n  }\n})();\n\n// Converts Parser's method names to internal type names\nvar NAME_MAP = {};\nObject.keys(PRIMITIVE_TYPES).\nconcat(Object.keys(SPECIAL_TYPES)).\nforEach(function (type) {\n  NAME_MAP[type.toLowerCase()] = type;\n});\n\n//= =======================================================================================\n// class Parser\n//= =======================================================================================\n\n//----------------------------------------------------------------------------------------\n// constructor\n//----------------------------------------------------------------------------------------\n\nvar Parser = function Parser() {\n  this.varName = \"\";\n  this.type = \"\";\n  this.options = {};\n  this.next = null;\n  this.head = null;\n  this.compiled = null;\n  this.endian = \"le\";\n  this.constructorFn = null;\n  this.alias = null;\n};\n\n//----------------------------------------------------------------------------------------\n// public methods\n//----------------------------------------------------------------------------------------\n\nParser.start = function () {\n  return new Parser();\n};\n\nObject.keys(PRIMITIVE_TYPES).forEach(function (type) {\n  Parser.prototype[type.toLowerCase()] = function (varName, options) {\n    return this.setNextParser(type.toLowerCase(), varName, options);\n  };\n\n  var typeWithoutEndian = type.replace(/BE|LE/, \"\").toLowerCase();\n  if (!(typeWithoutEndian in Parser.prototype)) {\n    Parser.prototype[typeWithoutEndian] = function (varName, options) {\n      return this[typeWithoutEndian + this.endian](varName, options);\n    };\n  }\n});\n\nBIT_RANGE.forEach(function (i) {\n  Parser.prototype[\"bit\".concat(i.toString())] = function (varName, options) {\n    if (!options) {\n      options = {};\n    }\n    options.length = i;\n    return this.setNextParser(\"bit\", varName, options);\n  };\n});\n\nParser.prototype.namely = function (alias) {\n  aliasRegistry[alias] = this;\n  this.alias = alias;\n  return this;\n};\n\nParser.prototype.skip = function (length, options) {\n  if (options && options.assert) {\n    throw new Error(\"assert option on skip is not allowed.\");\n  }\n\n  return this.setNextParser(\"skip\", \"\", { length: length });\n};\n\nParser.prototype.string = function (varName, options) {\n  if (!options.zeroTerminated && !options.length && !options.greedy) {\n    throw new Error(\n    \"Neither length, zeroTerminated, nor greedy is defined for string.\");\n\n  }\n  if ((options.zeroTerminated || options.length) && options.greedy) {\n    throw new Error(\n    \"greedy is mutually exclusive with length and zeroTerminated for string.\");\n\n  }\n  if (options.stripNull && !(options.length || options.greedy)) {\n    throw new Error(\n    \"Length or greedy must be defined if stripNull is defined.\");\n\n  }\n  options.encoding = options.encoding || \"utf8\";\n\n  return this.setNextParser(\"string\", varName, options);\n};\n\nParser.prototype.buffer = function (varName, options) {\n  if (!options.length && !options.readUntil) {\n    throw new Error(\"Length nor readUntil is defined in buffer parser\");\n  }\n\n  return this.setNextParser(\"buffer\", varName, options);\n};\n\nParser.prototype.array = function (varName, options) {\n  if (!options.readUntil && !options.length && !options.lengthInBytes) {\n    throw new Error(\"Length option of array is not defined.\");\n  }\n  if (!options.type) {\n    throw new Error(\"Type option of array is not defined.\");\n  }\n  if (\n  typeof options.type === \"string\" &&\n  !aliasRegistry[options.type] &&\n  Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.type]) < 0)\n  {\n    throw new Error(\"Specified primitive type \\\"\".concat(\n    options.type, \"\\\" is not supported.\"));\n\n  }\n\n  return this.setNextParser(\"array\", varName, options);\n};\n\nParser.prototype.choice = function (varName, options) {\n  if (arguments.length === 1 && _typeof(varName) === \"object\") {\n    options = varName;\n    varName = null;\n  }\n\n  if (!options.tag) {\n    throw new Error(\"Tag option of array is not defined.\");\n  }\n  if (!options.choices) {\n    throw new Error(\"Choices option of array is not defined.\");\n  }\n\n  Object.keys(options.choices).forEach(function (key) {\n    // if (isNaN(parseInt(key, 10))) {\n    //   throw new Error(\"Key of choices must be a number.\");\n    // }\n    if (!options.choices[key]) {\n      throw new Error(\"Choice Case \".concat(key, \" of \").concat(varName, \" is not valid.\"));\n    }\n\n    if (\n    typeof options.choices[key] === \"string\" &&\n    !aliasRegistry[options.choices[key]] &&\n    Object.keys(PRIMITIVE_TYPES).indexOf(NAME_MAP[options.choices[key]]) < 0)\n    {\n      throw new Error(\"Specified primitive type \\\"\".concat(\n      options.choices[key], \"\\\" is not supported.\"));\n\n    }\n  }, this);\n\n  return this.setNextParser(\"choice\", varName, options);\n};\n\nParser.prototype.nest = function (varName, options) {\n  if (arguments.length === 1 && _typeof(varName) === \"object\") {\n    options = varName;\n    varName = null;\n  }\n\n  if (!options.type) {\n    throw new Error(\"Type option of nest is not defined.\");\n  }\n  if (!(options.type instanceof Parser) && !aliasRegistry[options.type]) {\n    throw new Error(\"Type option of nest must be a Parser object.\");\n  }\n  if (!(options.type instanceof Parser) && !varName) {\n    throw new Error(\n    \"options.type must be a object if variable name is omitted.\");\n\n  }\n\n  return this.setNextParser(\"nest\", varName, options);\n};\n\nParser.prototype.endianess = function (endianess) {\n  switch (endianess.toLowerCase()) {\n    case \"little\":\n      this.endian = \"le\";\n      break;\n    case \"big\":\n      this.endian = \"be\";\n      break;\n    default:\n      throw new Error(\"Invalid endianess: \".concat(endianess));}\n\n\n  return this;\n};\n\nParser.prototype.create = function (constructorFn) {\n  if (!(constructorFn instanceof Function)) {\n    throw new Error(\"Constructor must be a Function object.\");\n  }\n\n  this.constructorFn = constructorFn;\n\n  return this;\n};\n\nParser.prototype.getCode = function () {\n  var ctx = new Context();\n\n  ctx.pushCode(\"if (!Buffer.isBuffer(buffer)) {\");\n  ctx.generateError('\"argument buffer is not a Buffer object\"');\n  ctx.pushCode(\"}\");\n\n  if (!this.alias) {\n    this.addRawCode(ctx);\n  } else {\n    this.addAliasedCode(ctx);\n  }\n\n  if (this.alias) {\n    ctx.pushCode(\"return {0}(0)\", FUNCTION_PREFIX + this.alias);\n  } else {\n    ctx.pushCode(\"return { offset: offset, result: vars };\");\n  }\n\n  return ctx.code;\n};\n\nParser.prototype.addRawCode = function (ctx) {\n  ctx.pushCode(\"var offset = 0;\");\n\n  if (this.constructorFn) {\n    ctx.pushCode(\"var vars = new constructorFn();\");\n  } else {\n    ctx.pushCode(\"var vars = {};\");\n  }\n\n  this.generate(ctx);\n\n  this.resolveReferences(ctx);\n\n  ctx.pushCode(\"return { offset: offset, result: vars };\");\n};\n\nParser.prototype.addAliasedCode = function (ctx) {\n  ctx.pushCode(\"function {0}(offset) {\", FUNCTION_PREFIX + this.alias);\n\n  if (this.constructorFn) {\n    ctx.pushCode(\"var vars = new constructorFn();\");\n  } else {\n    ctx.pushCode(\"var vars = {};\");\n  }\n\n  this.generate(ctx);\n\n  ctx.markResolved(this.alias);\n  this.resolveReferences(ctx);\n\n  ctx.pushCode(\"return { offset: offset, result: vars };\");\n  ctx.pushCode(\"}\");\n\n  return ctx;\n};\n\nParser.prototype.resolveReferences = function (ctx) {\n  var references = ctx.getUnresolvedReferences();\n  ctx.markRequested(references);\n  references.forEach(function (alias) {\n    var parser = aliasRegistry[alias];\n    parser.addAliasedCode(ctx);\n  });\n};\n\nParser.prototype.compile = function () {\n  var src = \"(function(buffer, constructorFn, Long) { \".concat(this.getCode(), \" })\");\n  this.compiled = runInThisContext(src);\n};\n\nParser.prototype.sizeOf = function () {\n  var size = NaN;\n\n  if (Object.keys(PRIMITIVE_TYPES).indexOf(this.type) >= 0) {\n    size = PRIMITIVE_TYPES[this.type];\n\n    // if this is a fixed length string\n  } else if (\n  this.type === \"String\" &&\n  typeof this.options.length === \"number\")\n  {\n    size = this.options.length;\n\n    // if this is a fixed length buffer\n  } else if (\n  this.type === \"Buffer\" &&\n  typeof this.options.length === \"number\")\n  {\n    size = this.options.length;\n\n    // if this is a fixed length array\n  } else if (this.type === \"Array\" && typeof this.options.length === \"number\") {\n    var elementSize = NaN;\n    if (typeof this.options.type === \"string\") {\n      elementSize = PRIMITIVE_TYPES[NAME_MAP[this.options.type]];\n    } else if (this.options.type instanceof Parser) {\n      elementSize = this.options.type.sizeOf();\n    }\n    size = this.options.length * elementSize;\n\n    // if this a skip\n  } else if (this.type === \"Skip\") {\n    size = this.options.length;\n\n    // if this is a nested parser\n  } else if (this.type === \"Nest\") {\n    size = this.options.type.sizeOf();\n  } else if (!this.type) {\n    size = 0;\n  }\n\n  if (this.next) {\n    size += this.next.sizeOf();\n  }\n\n  return size;\n};\n\n// Follow the parser chain till the root and start parsing from there\nParser.prototype.parse = function (buffer) {\n  if (!this.compiled) {\n    this.compile();\n  }\n\n  return this.compiled(buffer, this.constructorFn, Long);\n};\n\n//----------------------------------------------------------------------------------------\n// private methods\n//----------------------------------------------------------------------------------------\n\nParser.prototype.setNextParser = function (type, varName, options) {\n  var parser = new Parser();\n\n  parser.type = NAME_MAP[type];\n  parser.varName = varName;\n  parser.options = options || parser.options;\n  parser.endian = this.endian;\n\n  if (this.head) {\n    this.head.next = parser;\n  } else {\n    this.next = parser;\n  }\n  this.head = parser;\n\n  return this;\n};\n\n// Call code generator for this parser\nParser.prototype.generate = function (ctx) {\n  if (this.type) {\n    this[\"generate\".concat(this.type)](ctx);\n    this.generateAssert(ctx);\n  }\n\n  var varName = ctx.generateVariable(this.varName);\n  if (this.options.formatter) {\n    this.generateFormatter(ctx, varName, this.options.formatter);\n  }\n\n  return this.generateNext(ctx);\n};\n\nParser.prototype.generateAssert = function (ctx) {\n  if (!this.options.assert) {\n    return;\n  }\n\n  var varName = ctx.generateVariable(this.varName);\n\n  switch (_typeof(this.options.assert)) {\n    case \"function\":\n      ctx.pushCode(\n      \"if (!({0}).call(vars, {1})) {\",\n      this.options.assert,\n      varName);\n\n      break;\n    case \"number\":\n      ctx.pushCode(\"if ({0} !== {1}) {\", this.options.assert, varName);\n      break;\n    case \"string\":\n      ctx.pushCode('if (\"{0}\" !== {1}) {', this.options.assert, varName);\n      break;\n    default:\n      throw new Error(\n      \"Assert option supports only strings, numbers and assert functions.\");}\n\n\n  ctx.generateError('\"Assert error: {0} is \" + {0}', varName);\n  ctx.pushCode(\"}\");\n};\n\n// Recursively call code generators and append results\nParser.prototype.generateNext = function (ctx) {\n  if (this.next) {\n    ctx = this.next.generate(ctx);\n  }\n\n  return ctx;\n};\n\nObject.keys(PRIMITIVE_TYPES).forEach(function (type) {\n  Parser.prototype[\"generate\".concat(type)] = function (ctx) {\n    if (type === \"UInt64\") {\n      ctx.pushCode(\n      \"{0} = Long.fromBytes(buffer.slice(offset,offset+8), true, this.endian === 'le').toNumber();\",\n      ctx.generateVariable(this.varName),\n      type);\n\n    } else if (type === \"Int64\") {\n      ctx.pushCode(\n      \"{0} = Long.fromBytes(buffer.slice(offset,offset+8), false, this.endian === 'le').toNumber();\",\n      ctx.generateVariable(this.varName),\n      type);\n\n    } else {\n      ctx.pushCode(\n      \"{0} = buffer.read{1}(offset);\",\n      ctx.generateVariable(this.varName),\n      type);\n\n    }\n    ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[type]);\n  };\n});\n\nParser.prototype.generateBit = function (ctx) {\n  // TODO find better method to handle nested bit fields\n  var parser = JSON.parse(JSON.stringify(this));\n  parser.varName = ctx.generateVariable(parser.varName);\n  ctx.bitFields.push(parser);\n\n  if (\n  !this.next ||\n  this.next && [\"Bit\", \"Nest\"].indexOf(this.next.type) < 0)\n  {\n    var sum = 0;\n    ctx.bitFields.forEach(function (p) {\n      sum += p.options.length;\n    });\n\n    var val = ctx.generateTmpVariable();\n\n    if (sum <= 8) {\n      ctx.pushCode(\"var {0} = buffer.readUInt8(offset);\", val);\n      sum = 8;\n    } else if (sum <= 16) {\n      ctx.pushCode(\"var {0} = buffer.readUInt16BE(offset);\", val);\n      sum = 16;\n    } else if (sum <= 24) {\n      var val1 = ctx.generateTmpVariable();\n      var val2 = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = buffer.readUInt16BE(offset);\", val1);\n      ctx.pushCode(\"var {0} = buffer.readUInt8(offset + 2);\", val2);\n      ctx.pushCode(\"var {2} = ({0} << 8) | {1};\", val1, val2, val);\n      sum = 24;\n    } else if (sum <= 32) {\n      ctx.pushCode(\"var {0} = buffer.readUInt32BE(offset);\", val);\n      sum = 32;\n    } else {\n      throw new Error(\n      \"Currently, bit field sequence longer than 4-bytes is not supported.\");\n\n    }\n    ctx.pushCode(\"offset += {0};\", sum / 8);\n\n    var bitOffset = 0;\n    var isBigEndian = this.endian === \"be\";\n    ctx.bitFields.forEach(function (p) {\n      ctx.pushCode(\n      \"{0} = {1} >> {2} & {3};\",\n      p.varName,\n      val,\n      isBigEndian ? sum - bitOffset - p.options.length : bitOffset,\n      (1 << p.options.length) - 1);\n\n      bitOffset += p.options.length;\n    });\n\n    ctx.bitFields = [];\n  }\n};\n\nParser.prototype.generateSkip = function (ctx) {\n  var length = ctx.generateOption(this.options.length);\n  ctx.pushCode(\"offset += {0};\", length);\n};\n\nParser.prototype.generateString = function (ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var start = ctx.generateTmpVariable();\n\n  if (this.options.length && this.options.zeroTerminated) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\n    \"while(buffer.readUInt8(offset++) !== 0 && offset - {0}  < {1});\",\n    start,\n    this.options.length);\n\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', {2}, offset - {2} < {3} ? offset - 1 : offset);\",\n    name,\n    this.options.encoding,\n    start,\n    this.options.length);\n\n  } else if (this.options.length) {\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', offset, offset + {2});\",\n    name,\n    this.options.encoding,\n    ctx.generateOption(this.options.length));\n\n    ctx.pushCode(\"offset += {0};\", ctx.generateOption(this.options.length));\n  } else if (this.options.zeroTerminated) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\"while(buffer.readUInt8(offset++) !== 0);\");\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', {2}, offset - 1);\",\n    name,\n    this.options.encoding,\n    start);\n\n  } else if (this.options.greedy) {\n    ctx.pushCode(\"var {0} = offset;\", start);\n    ctx.pushCode(\"while(buffer.length > offset++);\");\n    ctx.pushCode(\n    \"{0} = buffer.toString('{1}', {2}, offset);\",\n    name,\n    this.options.encoding,\n    start);\n\n  }\n  if (this.options.stripNull) {\n    ctx.pushCode(\"{0} = {0}.replace(/\\\\x00+$/g, '')\", name);\n  }\n};\n\nParser.prototype.generateBuffer = function (ctx) {\n  if (this.options.readUntil === \"eof\") {\n    ctx.pushCode(\n    \"{0} = buffer.slice(offset);\",\n    ctx.generateVariable(this.varName));\n\n  } else {\n    ctx.pushCode(\n    \"{0} = buffer.slice(offset, offset + {1});\",\n    ctx.generateVariable(this.varName),\n    ctx.generateOption(this.options.length));\n\n    ctx.pushCode(\"offset += {0};\", ctx.generateOption(this.options.length));\n  }\n\n  if (this.options.clone) {\n    ctx.pushCode(\"{0} = Buffer.from({0});\", ctx.generateVariable(this.varName));\n  }\n};\n\nParser.prototype.generateArray = function (ctx) {\n  var length = ctx.generateOption(this.options.length);\n  var lengthInBytes = ctx.generateOption(this.options.lengthInBytes);\n  var type = this.options.type;\n  var counter = ctx.generateTmpVariable();\n  var lhs = ctx.generateVariable(this.varName);\n  var item = ctx.generateTmpVariable();\n  var key = this.options.key;\n  var isHash = typeof key === \"string\";\n\n  if (isHash) {\n    ctx.pushCode(\"{0} = {};\", lhs);\n  } else {\n    ctx.pushCode(\"{0} = [];\", lhs);\n  }\n  if (typeof this.options.readUntil === \"function\") {\n    ctx.pushCode(\"do {\");\n  } else if (this.options.readUntil === \"eof\") {\n    ctx.pushCode(\"for (var {0} = 0; offset < buffer.length; {0}++) {\", counter);\n  } else if (lengthInBytes !== undefined) {\n    ctx.pushCode(\n    \"for (var {0} = offset; offset - {0} < {1}; ) {\",\n    counter,\n    lengthInBytes);\n\n  } else {\n    ctx.pushCode(\"for (var {0} = 0; {0} < {1}; {0}++) {\", counter, length);\n  }\n\n  if (typeof type === \"string\") {\n    if (!aliasRegistry[type]) {\n      ctx.pushCode(\"var {0} = buffer.read{1}(offset);\", item, NAME_MAP[type]);\n      ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[NAME_MAP[type]]);\n    } else {\n      var tempVar = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = {1}(offset);\", tempVar, FUNCTION_PREFIX + type);\n      ctx.pushCode(\"var {0} = {1}.result; offset = {1}.offset;\", item, tempVar);\n      if (type !== this.alias) ctx.addReference(type);\n    }\n  } else if (type instanceof Parser) {\n    ctx.pushCode(\"var {0} = {};\", item);\n\n    ctx.pushScope(item);\n    type.generate(ctx);\n    ctx.popScope();\n  }\n\n  if (isHash) {\n    ctx.pushCode(\"{0}[{2}.{1}] = {2};\", lhs, key, item);\n  } else {\n    ctx.pushCode(\"{0}.push({1});\", lhs, item);\n  }\n\n  ctx.pushCode(\"}\");\n\n  if (typeof this.options.readUntil === \"function\") {\n    ctx.pushCode(\n    \" while (!({0}).call(this, {1}, buffer.slice(offset)));\",\n    this.options.readUntil,\n    item);\n\n  }\n};\n\nParser.prototype.generateChoiceCase = function (ctx, varName, type) {\n  if (typeof type === \"string\") {\n    if (!aliasRegistry[type]) {\n      ctx.pushCode(\n      \"{0} = buffer.read{1}(offset);\",\n      ctx.generateVariable(this.varName),\n      NAME_MAP[type]);\n\n      ctx.pushCode(\"offset += {0};\", PRIMITIVE_TYPES[NAME_MAP[type]]);\n    } else {\n      var tempVar = ctx.generateTmpVariable();\n      ctx.pushCode(\"var {0} = {1}(offset);\", tempVar, FUNCTION_PREFIX + type);\n      ctx.pushCode(\n      \"{0} = {1}.result; offset = {1}.offset;\",\n      ctx.generateVariable(this.varName),\n      tempVar);\n\n      if (type !== this.alias) ctx.addReference(type);\n    }\n  } else if (type instanceof Parser) {\n    ctx.pushPath(varName);\n    type.generate(ctx);\n    ctx.popPath(varName);\n  }\n};\n\nParser.prototype.generateChoice = function (ctx) {\n  var tag = ctx.generateOption(this.options.tag);\n  if (this.varName) {\n    ctx.pushCode(\"{0} = {};\", ctx.generateVariable(this.varName));\n  }\n  ctx.pushCode(\"switch({0}) {\", tag);\n  Object.keys(this.options.choices).forEach(function (t) {\n    var type = this.options.choices[t];\n    if (Number.isNaN(parseInt(t, 10))) {\n      ctx.pushCode(\"case '{0}':\", t);\n    } else {\n      ctx.pushCode(\"case {0}:\", t);\n    }\n    this.generateChoiceCase(ctx, this.varName, type);\n    ctx.pushCode(\"break;\");\n  }, this);\n  ctx.pushCode(\"default:\");\n  if (this.options.defaultChoice) {\n    this.generateChoiceCase(ctx, this.varName, this.options.defaultChoice);\n  } else {\n    ctx.generateError('\"Met undefined tag value \" + {0} + \" at choice\"', tag);\n  }\n  ctx.pushCode(\"}\");\n};\n\nParser.prototype.generateNest = function (ctx) {\n  var nestVar = ctx.generateVariable(this.varName);\n\n  if (this.options.type instanceof Parser) {\n    if (this.varName) {\n      ctx.pushCode(\"{0} = {};\", nestVar);\n    }\n    ctx.pushPath(this.varName);\n    this.options.type.generate(ctx);\n    ctx.popPath(this.varName);\n  } else if (aliasRegistry[this.options.type]) {\n    var tempVar = ctx.generateTmpVariable();\n    ctx.pushCode(\n    \"var {0} = {1}(offset);\",\n    tempVar,\n    FUNCTION_PREFIX + this.options.type);\n\n    ctx.pushCode(\"{0} = {1}.result; offset = {1}.offset;\", nestVar, tempVar);\n    if (this.options.type !== this.alias) ctx.addReference(this.options.type);\n  }\n};\n\nParser.prototype.generateFormatter = function (ctx, varName, formatter) {\n  if (typeof formatter === \"function\") {\n    ctx.pushCode(\"{0} = ({1}).call(this, {0});\", varName, formatter);\n  }\n};\n\nParser.prototype.isInteger = function () {\n  return !!this.type.match(/U?Int[8|16|32][BE|LE]?|Bit\\d+/);\n};\n\n// /////////////////// CRAM-specific types //////////////////////////\n//\nParser.prototype.itf8 = function (varName, options) {\n  return this.setNextParser(\"itf8\", varName, options);\n};\nParser.prototype.itf8 = function (varName, options) {\n  return this.setNextParser(\"itf8\", varName, options);\n};\n\nParser.prototype.generateItf8 = function (ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var countFlags = ctx.generateTmpVariable();\n  ctx.pushCode(\"\\n    var \".concat(\n  countFlags, \" = buffer[offset];\\n    if (\").concat(\n  countFlags, \" < 0x80) {\\n      \").concat(\n  name, \" = \").concat(countFlags, \";\\n      offset += 1;\\n    } else if (\").concat(\n\n  countFlags, \" < 0xc0) {\\n      \").concat(\n  name, \" = ((\").concat(countFlags, \"<<8) | buffer[offset+1]) & 0x3fff;\\n      offset += 2;\\n    } else if (\").concat(\n\n  countFlags, \" < 0xe0) {\\n      \").concat(\n  name, \" = ((\").concat(countFlags, \"<<16) | (buffer[offset+1]<< 8) |  buffer[offset+2]) & 0x1fffff;\\n      offset += 3;\\n    } else if (\").concat(\n\n  countFlags, \" < 0xf0) {\\n      \").concat(\n  name, \" = ((\").concat(countFlags, \"<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\\n      offset += 4\\n    } else {\\n      \").concat(\n\n\n  name, \" = ((\").concat(countFlags, \" & 0x0f)<<28) | (buffer[offset+1]<<20) | (buffer[offset+2]<<12) | (buffer[offset+3]<<4) | (buffer[offset+4] & 0x0f);\\n      // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);\\n      // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\\n      offset += 5\\n    }\\n  \"));\n\n\n\n\n\n};\n\nParser.prototype.ltf8 = function (varName, options) {\n  return this.setNextParser(\"ltf8\", varName, options);\n};\n\nParser.prototype.generateLtf8 = function (ctx) {\n  var name = ctx.generateVariable(this.varName);\n  var countFlags = ctx.generateTmpVariable();\n  ctx.pushCode(\"\\n  var \".concat(\n  countFlags, \" = buffer[offset];\\n  if (\").concat(\n  countFlags, \" < 0x80) {\\n    \").concat(\n  name, \" = \").concat(countFlags, \";\\n    offset += 1;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xc0) {\\n    \").concat(\n  name, \" = ((buffer[offset]<<8) | buffer[offset+1]) & 0x3fff;\\n    offset += 2;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xe0) {\\n    \").concat(\n  name, \" = ((buffer[offset]<<16) | (buffer[offset+1]<<8) | buffer[offset+2]) & 0x1fffff;\\n    \").concat(\n  name, \" = (((\").concat(countFlags, \" & 63) << 16) | buffer.readUInt16LE(offset + 1));\\n    offset += 3;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xf0) {\\n    \").concat(\n  name, \" = ((buffer[offset]<<24) | (buffer[offset+1]<<16) | (buffer[offset+2]<<8) | buffer[offset+3]) & 0x0fffffff;\\n    offset += 4;\\n  } else if (\").concat(\n\n  countFlags, \" < 0xf8) {\\n    \").concat(\n  name, \" = (((buffer[offset] & 15) * Math.pow(2,32))) +\\n      (buffer[offset+1]<<24) | (buffer[offset+2]<<16 | buffer[offset+3]<<8 | buffer[offset+4])\\n    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\\n    offset += 5;\\n  } else if (\").concat(\n\n\n\n  countFlags, \" < 0xfc) {\\n    \").concat(\n  name, \" = ((((buffer[offset] & 7) << 8) | buffer[offset+1] )) * Math.pow(2,32) +\\n      (buffer[offset+2]<<24) | (buffer[offset+3]<<16 | buffer[offset+4]<<8 | buffer[offset+5])\\n    offset += 6;\\n  } else if (\").concat(\n\n\n  countFlags, \" < 0xfe) {\\n    \").concat(\n  name, \" = ((((buffer[offset] & 3) << 16) | buffer[offset+1]<<8 | buffer[offset+2])) * Math.pow(2,32) +\\n      (buffer[offset+3]<<24) | (buffer[offset+4]<<16 | buffer[offset+5]<<8 | buffer[offset+6])\\n    offset += 7;\\n  } else if (\").concat(\n\n\n  countFlags, \" < 0xff) {\\n    \").concat(\n  name, \" = Long.fromBytesBE(buffer.slice(offset+1,offset+8));\\n    if (\").concat(\n  name, \".greaterThan(Number.MAX_SAFE_INTEGER) || \").concat(name, \".lessThan(Number.MIN_SAFE_INTEGER))\\n      throw new Error('integer overflow')\\n    \").concat(\n\n  name, \" = \").concat(name, \".toNumber()\\n    offset += 8;\\n  } else {\\n    \").concat(\n\n\n  name, \" = Long.fromBytesBE(buffer.slice(offset+1,offset+9));\\n    if (\").concat(\n  name, \".greaterThan(Number.MAX_SAFE_INTEGER) || \").concat(name, \".lessThan(Number.MIN_SAFE_INTEGER))\\n      throw new Error('integer overflow')\\n    \").concat(\n\n  name, \" = \").concat(name, \".toNumber()\\n    offset += 9;\\n  }\\n  \"));\n\n\n\n};\n\n//= =======================================================================================\n// Exports\n//= =======================================================================================\n\nexports.Parser = Parser;","\"use strict\";function _typeof(obj) {if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {_typeof = function _typeof(obj) {return typeof obj;};} else {_typeof = function _typeof(obj) {return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;};}return _typeof(obj);} //= =======================================================================================\n// class Context\n//= =======================================================================================\n\n//----------------------------------------------------------------------------------------\n// constructor\n//----------------------------------------------------------------------------------------\n\nvar Context = function Context() {\n  this.code = \"\";\n  this.scopes = [[\"vars\"]];\n  this.isAsync = false;\n  this.bitFields = [];\n  this.tmpVariableCount = 0;\n  this.references = {};\n};\n\n//----------------------------------------------------------------------------------------\n// public methods\n//----------------------------------------------------------------------------------------\n\nContext.prototype.generateVariable = function (name) {\n  var arr = [];\n\n  Array.prototype.push.apply(arr, this.scopes[this.scopes.length - 1]);\n\n  // $parent. prefixes allow sub-parsers to access values of their parent parsers\n  while (/^\\$parent\\./.test(name)) {\n    arr.pop();\n    name = name.replace(/^\\$parent\\./, \"\");\n  }\n\n  if (name) {\n    arr.push(name);\n  }\n\n  return arr.join(\".\");\n};\n\nContext.prototype.generateOption = function (val) {\n  switch (_typeof(val)) {\n    case \"number\":\n      return val.toString();\n    case \"string\":\n      return this.generateVariable(val);\n    case \"function\":\n      return \"(\".concat(val, \").call(\").concat(this.generateVariable(), \", vars)\");\n    default:\n      return undefined;}\n\n};\n\nContext.prototype.generateError = function () {\n  var args = Array.prototype.slice.call(arguments);\n  var err = Context.interpolate.apply(this, args);\n\n  if (this.isAsync) {\n    this.pushCode(\"return process.nextTick(function() { callback(new Error(\".concat(\n    err, \"), vars); });\"));\n\n  } else {\n    this.pushCode(\"throw new Error(\".concat(err, \");\"));\n  }\n};\n\nContext.prototype.generateTmpVariable = function () {\n  return \"$tmp\".concat(this.tmpVariableCount++);\n};\n\nContext.prototype.pushCode = function () {\n  var args = Array.prototype.slice.call(arguments);\n\n  this.code += \"\".concat(Context.interpolate.apply(this, args), \"\\n\");\n};\n\nContext.prototype.pushPath = function (name) {\n  if (name) {\n    this.scopes[this.scopes.length - 1].push(name);\n  }\n};\n\nContext.prototype.popPath = function (name) {\n  if (name) {\n    this.scopes[this.scopes.length - 1].pop();\n  }\n};\n\nContext.prototype.pushScope = function (name) {\n  this.scopes.push([name]);\n};\n\nContext.prototype.popScope = function () {\n  this.scopes.pop();\n};\n\nContext.prototype.addReference = function (alias) {\n  if (this.references[alias]) return;\n  this.references[alias] = { resolved: false, requested: false };\n};\n\nContext.prototype.markResolved = function (alias) {\n  this.references[alias].resolved = true;\n};\n\nContext.prototype.markRequested = function (aliasList) {\n  aliasList.forEach(\n  function (alias) {\n    this.references[alias].requested = true;\n  }.bind(this));\n\n};\n\nContext.prototype.getUnresolvedReferences = function () {\n  var references = this.references;\n  return Object.keys(this.references).filter(function (alias) {\n    return !references[alias].resolved && !references[alias].requested;\n  });\n};\n\n//----------------------------------------------------------------------------------------\n// private methods\n//----------------------------------------------------------------------------------------\n\nContext.interpolate = function (s) {\n  var re = /{\\d+}/g;\n  var matches = s.match(re);\n  var params = Array.prototype.slice.call(arguments, 1);\n\n  if (matches) {\n    matches.forEach(function (match) {\n      var index = parseInt(match.substr(1, match.length - 2), 10);\n      s = s.replace(match, params[index].toString());\n    });\n  }\n\n  return s;\n};\n\nexports.Context = Context;"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Buffer","Context","Long","window","self","PRIMITIVE_TYPES","UInt8","UInt16LE","UInt16BE","UInt32LE","UInt32BE","Int8","Int16LE","Int16BE","Int32LE","Int32BE","FloatLE","FloatBE","DoubleLE","DoubleBE","UInt64","Int64","aliasRegistry","FUNCTION_PREFIX","BIT_RANGE","i","push","NAME_MAP","Object","keys","concat","String","Array","Skip","Choice","Nest","Bit","Itf8","Ltf8","forEach","type","toLowerCase","Parser","this","varName","options","next","head","compiled","endian","constructorFn","alias","start","setNextParser","typeWithoutEndian","replace","toString","length","namely","skip","assert","Error","string","zeroTerminated","greedy","stripNull","encoding","buffer","readUntil","array","lengthInBytes","indexOf","choice","arguments","tag","choices","key","nest","endianess","create","Function","getCode","ctx","pushCode","generateError","addAliasedCode","addRawCode","code","generate","resolveReferences","markResolved","references","getUnresolvedReferences","markRequested","compile","src","call","globalThis","sizeOf","size","NaN","elementSize","parse","parser","generateAssert","generateVariable","formatter","generateFormatter","generateNext","generateBit","JSON","stringify","bitFields","sum","p","val","generateTmpVariable","val1","val2","bitOffset","isBigEndian","generateSkip","generateOption","generateString","name","generateBuffer","clone","generateArray","counter","lhs","item","isHash","undefined","tempVar","addReference","pushScope","popScope","generateChoiceCase","pushPath","popPath","generateChoice","t","Number","isNaN","parseInt","defaultChoice","generateNest","nestVar","isInteger","match","itf8","generateItf8","countFlags","ltf8","generateLtf8","exports","scopes","isAsync","tmpVariableCount","arr","apply","test","pop","join","args","slice","err","interpolate","resolved","requested","aliasList","bind","filter","s","matches","params","index","substr"],"sourceRoot":""}