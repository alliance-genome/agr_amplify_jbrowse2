{"version":3,"file":"static/js/1860.6997095e.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/ucsc-hub/src/genomesFile.ts","../../../node_modules/@gmod/ucsc-hub/src/hubFile.ts","../../../node_modules/@gmod/ucsc-hub/src/index.ts","../../../node_modules/@gmod/ucsc-hub/src/raFile.ts","../../../node_modules/@gmod/ucsc-hub/src/raStanza.ts","../../../node_modules/@gmod/ucsc-hub/src/trackDbFile.ts","../../../node_modules/@babel/runtime/helpers/get.js","../../../node_modules/@babel/runtime/helpers/superPropBase.js"],"sourcesContent":["import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n  constructor(genomesFile: string) {\n    super(genomesFile)\n    if (this.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n\n    // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n    const requiredFields = [\n      'genome',\n      'trackDb',\n      // 'twoBitPath',\n      // 'groups',\n    ]\n    this.forEach((genome, genomeName) => {\n      const missingFields = [] as string[]\n      requiredFields.forEach(field => {\n        if (!genome.get(field)) {\n          missingFields.push(field)\n        }\n      })\n      if (missingFields.length > 0) {\n        throw new Error(\n          `Genomes file entry ${genomeName} is missing required entr${\n            missingFields.length === 1 ? 'y' : 'ies'\n          }: ${missingFields.join(', ')}`,\n        )\n      }\n    })\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n  constructor(hubFile: string) {\n    super(hubFile)\n    if (this.nameKey !== 'hub') {\n      throw new Error('Hub file must begin with a line like \"hub <hub_name>\"')\n    }\n    const hubTxtFields = [\n      'hub',\n      'shortLabel',\n      'longLabel',\n      'genomesFile',\n      'email',\n      'descriptionUrl',\n    ]\n    const extraFields = [] as string[]\n    this.forEach((_value, key) => {\n      if (!hubTxtFields.includes(key)) {\n        extraFields.push(key)\n      }\n    })\n    if (extraFields.length > 0) {\n      throw new Error(\n        `Hub file has invalid entr${\n          extraFields.length === 1 ? 'y' : 'ies'\n        }: ${extraFields.join(', ')}`,\n      )\n    }\n    const missingFields = [] as string[]\n    hubTxtFields.forEach(field => {\n      if (field !== 'descriptionUrl' && !this.get(field)) {\n        missingFields.push(field)\n      }\n    })\n    if (missingFields.length > 0) {\n      throw new Error(\n        `Hub file is missing required entr${\n          missingFields.length === 1 ? 'y' : 'ies'\n        }: ${missingFields.join(', ')}`,\n      )\n    }\n  }\n}\n","import RaFile from './raFile'\nimport RaStanza from './raStanza'\nimport TrackDbFile from './trackDbFile'\nimport HubFile from './hubFile'\nimport GenomesFile from './genomesFile'\n\nexport { RaFile, RaStanza, TrackDbFile, HubFile, GenomesFile }\n","import RaStanza from './raStanza'\n\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile extends Map<string, RaStanza> {\n  _checkIndent: boolean\n\n  _stanzaAndCommentOrder: string[]\n\n  nameKey?: string\n\n  constructor(raFile: string, options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzas: string[]\n    if (typeof raFile === 'string') {\n      stanzas = raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n    } else if (!raFile) {\n      stanzas = []\n    } else {\n      stanzas = raFile\n    }\n    this._stanzaAndCommentOrder = []\n    stanzas.forEach(stanza => {\n      this.add(stanza)\n    })\n  }\n\n  /**\n   * Add a single stanza to the file\n   * @param {string} stanza A single stanza\n   * @returns {RaFile} The RaFile object\n   */\n  add(stanza: string) {\n    if (stanza === '') {\n      throw new Error('Invalid stanza, was empty')\n    }\n    if (stanza.trim().startsWith('#')) {\n      const stanzaLines = stanza\n        .trimEnd()\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n      if (stanzaLines.every(line => line.startsWith('#'))) {\n        this._stanzaAndCommentOrder.push(stanzaLines.join('\\n'))\n        return this\n      }\n    }\n    const raStanza = new RaStanza(stanza, { checkIndent: this._checkIndent })\n    if (!this.nameKey) {\n      this.nameKey = raStanza.nameKey\n    } else if (raStanza.nameKey !== this.nameKey) {\n      throw new Error(\n        'The first line in each stanza must have the same key. ' +\n          `Saw both ${this.nameKey} and ${raStanza.nameKey}`,\n      )\n    }\n    if (!raStanza.name) {\n      throw new Error(`No stanza name: ${raStanza.name}`)\n    }\n    if (this.has(raStanza.name)) {\n      throw new Error(`Got duplicate stanza name: ${raStanza.name}`)\n    }\n\n    this._stanzaAndCommentOrder.push(raStanza.name)\n    return super.set(raStanza.name, raStanza)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, empty stanzas, duplicate keys, etc.\n   * @param {string} key The key of the RaFile stanza\n   * @param {RaStanza} value The RaFile stanza used to replace the prior one\n   */\n  update(key: string, value: RaStanza) {\n    if (!(value instanceof RaStanza)) {\n      throw new Error(`Value of ${key} is not an RaStanza`)\n    }\n    super.set(key, value)\n  }\n\n  /**\n   * Delete a stanza\n   * @param {string} stanza The name of the stanza to delete (the value in its\n   * first key-value pair)\n   * @returns {boolean} true if the deleted stanza existed, false if it did not\n   */\n  delete(stanza: string) {\n    if (this._stanzaAndCommentOrder.includes(stanza)) {\n      this._stanzaAndCommentOrder = this._stanzaAndCommentOrder.filter(\n        value => value !== stanza,\n      )\n    }\n    return super.delete(stanza)\n  }\n\n  /**\n   * Clear all stanzas and comments\n   */\n  clear() {\n    this._stanzaAndCommentOrder.length = 0\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   *  as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const stanzas = [] as string[]\n    this._stanzaAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        stanzas.push(`${entry}\\n`)\n      } else {\n        const e = this.get(entry)\n        if (e) {\n          stanzas.push(e.toString())\n        }\n      }\n    })\n    return stanzas.join('\\n')\n  }\n}\n","/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza. An additional method `add()` is available to take a raw line of text\n * and break it up into a key and value and add them to the class. This should\n * be favored over `set()` when possible, as it performs more validity checks\n * than using `set()`.\n *\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of the\n * stanza (`undefined` if the stanza has no lines yet).\n *\n * @property {undefined|string} name - The value of the first line of the\n * stanza, by which it is identified in an ra file  (`undefined` if the stanza\n * has no lines yet).\n *\n * @property {undefined|string} indent - The leading indent of the stanza,\n * which is the same for every line (`undefined` if the stanza has no lines\n * yet, `''` if there is no indent).\n *\n * @throws {Error} Throws if the stanza has blank lines, if the first line\n * doesn't have both a key and a value, if a key in the stanza is\n * duplicated, or if lines in the stanza have inconsistent indentation.\n * @param {(string|string[])} [stanza=[]] - An ra file stanza, either as a\n * string or a array of strings with one line per entry. Supports both LF and\n * CRLF line terminators.\n *\n * @param {object} options\n *\n * @param {boolean} options.checkIndent [true] - Check if a stanza is indented\n * consistently and keep track of the indentation\n */\nexport default class RaStanza extends Map<string, string> {\n  _checkIndent: boolean\n\n  _keyAndCommentOrder: string[]\n\n  _continuedLine?: string\n\n  indent?: string\n\n  name?: string\n\n  nameKey?: string\n\n  constructor(stanza: string | string[], options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzaLines: string[]\n    if (typeof stanza === 'string') {\n      stanzaLines = stanza.trimEnd().split(/\\r?\\n/)\n    } else if (!stanza) {\n      stanzaLines = []\n    } else {\n      stanzaLines = stanza\n    }\n    this._keyAndCommentOrder = []\n    stanzaLines.forEach(line => {\n      this.add(line)\n    })\n  }\n\n  /**\n   * Add a single line to the stanza. If the exact line already exists, does\n   * nothing.\n   * @param {string} line A stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  add(line: string) {\n    if (line === '') {\n      throw new Error('Invalid stanza, contained blank lines')\n    }\n    if (line.trim().startsWith('#')) {\n      this._keyAndCommentOrder.push(line.trim())\n      return this\n    }\n    if (line.trimEnd().endsWith('\\\\')) {\n      const trimmedLine = line.trimEnd().slice(0, -1)\n      if (this._continuedLine) {\n        this._continuedLine += trimmedLine.trimStart()\n      } else {\n        this._continuedLine = trimmedLine\n      }\n      return this\n    }\n    let combinedLine = line\n    if (this._continuedLine) {\n      combinedLine = this._continuedLine + combinedLine.trimStart()\n      this._continuedLine = undefined\n    }\n    if (this.indent || this._checkIndent) {\n      const indent = combinedLine.match(/^([ \\t]+)/)\n      if (this.indent === undefined) {\n        if (indent) {\n          ;[, this.indent] = indent\n        } else {\n          this.indent = ''\n        }\n      } else if (\n        (this.indent === '' && indent !== null) ||\n        (this.indent && indent && this.indent !== indent[1])\n      ) {\n        throw new Error('Inconsistent indentation of stanza')\n      }\n    } else {\n      this.indent = ''\n    }\n    const trimmedLine = combinedLine.trim()\n    const sep = trimmedLine.indexOf(' ')\n    if (sep === -1) {\n      if (!this.nameKey) {\n        throw new Error(\n          'First line in a stanza must have both a key and a value',\n        )\n      }\n      // Adding a key that already exists and has no value is a no-op\n      if (this.has(trimmedLine)) {\n        return this\n      }\n      this._keyAndCommentOrder.push(trimmedLine)\n      return super.set(trimmedLine, '')\n    }\n    const key = trimmedLine.slice(0, sep)\n    const value = trimmedLine.slice(sep + 1)\n    if (this.has(key) && value !== this.get(key)) {\n      throw new Error(\n        'Got duplicate key with a different value in stanza: ' +\n          `\"${key}\" key has both ${this.get(key)} and ${value}`,\n      )\n    }\n    this._keyAndCommentOrder.push(key)\n    if (!this.nameKey) {\n      this.nameKey = key\n      this.name = trimmedLine.slice(sep + 1)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, indentation, duplicate keys, etc.\n   * @param {string} key The key of the stanza line\n   * @param {string} value The value of the stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  set(key: string, value: string) {\n    if (!(typeof value === 'string')) {\n      throw new Error(`Value of ${key} must be a string, got ${typeof value}`)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Delete a line\n   * @param {string} key The key of the line to delete\n   * @returns {boolean} true if the deleted line existed, false if it did not\n   */\n  delete(key: string) {\n    if (key === this.nameKey) {\n      throw new Error(\n        'Cannot delete the first line in a stanza (you can still overwrite it with set()).',\n      )\n    }\n    if (this._keyAndCommentOrder.includes(key)) {\n      this._keyAndCommentOrder = this._keyAndCommentOrder.filter(\n        value => value !== key,\n      )\n    }\n    return super.delete(key)\n  }\n\n  /**\n   * Clear all lines and comments\n   */\n  clear() {\n    this._keyAndCommentOrder.length = 0\n    this._continuedLine = undefined\n    this.indent = undefined\n    this.name = undefined\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   * as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const lines = [] as string[]\n    this._keyAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        lines.push(`${this.indent}${entry}`)\n      } else {\n        lines.push(`${this.indent}${entry} ${this.get(entry)}`.trimEnd())\n      }\n    })\n    return `${lines.join('\\n')}\\n`\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n  constructor(trackDbFile: string) {\n    super(trackDbFile, { checkIndent: false })\n    if (this.nameKey !== 'track') {\n      throw new Error(\n        `trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`,\n      )\n    }\n    this.forEach((track, trackName) => {\n      const trackKeys = Array.from(track.keys())\n      const missingKeys = [] as string[]\n      const requiredKeys = ['track', 'shortLabel']\n      requiredKeys.forEach(key => {\n        if (!trackKeys.includes(key)) {\n          missingKeys.push(key)\n        }\n      })\n      if (missingKeys.length > 0) {\n        throw new Error(\n          `Track ${trackName} is missing required key(s): ${missingKeys.join(\n            ', ',\n          )}`,\n        )\n      }\n      const parentTrackKeys = [\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n      ]\n      if (!trackKeys.some(key => parentTrackKeys.includes(key))) {\n        if (!trackKeys.includes('bigDataUrl')) {\n          throw new Error(\n            `Track ${trackName} is missing required key \"bigDataUrl\"`,\n          )\n        }\n        if (!trackKeys.includes('type')) {\n          const settings = this.settings(trackName)\n          const settingsKeys = Array.from(settings.keys())\n          if (!settingsKeys.includes('type')) {\n            throw new Error(\n              `Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`,\n            )\n          }\n        }\n      }\n      let indent = ''\n      let currentTrackName: string | undefined = trackName\n      do {\n        currentTrackName = this.get(currentTrackName)?.get('parent')\n        if (currentTrackName) {\n          ;[currentTrackName] = currentTrackName.split(' ')\n          indent += '    '\n        }\n      } while (currentTrackName)\n      const currentTrack = this.get(trackName)\n      if (currentTrack) {\n        currentTrack.indent = indent\n        this.set(trackName, currentTrack)\n      }\n    })\n  }\n\n  /**\n   * Gets all track entries including those of parent tracks, with closer\n   * entries overriding more distant ones\n   * @param {string} trackName The name of a track\n   * @throws {Error} Throws if track name does not exist in the trackDb\n   */\n  settings(trackName: string) {\n    if (!this.has(trackName)) {\n      throw new Error(`Track ${trackName} does not exist`)\n    }\n    const parentTracks = [trackName]\n    let currentTrackName: string | undefined = trackName\n    do {\n      currentTrackName = this.get(currentTrackName)?.get('parent')\n      if (currentTrackName) {\n        parentTracks.push(currentTrackName)\n      }\n    } while (currentTrackName)\n    const settings = new Map()\n    parentTracks.reverse()\n    parentTracks.forEach(parentTrack => {\n      this.get(parentTrack)?.forEach((value, key) => {\n        settings.set(key, value)\n      })\n    })\n    return settings\n  }\n}\n","var superPropBase = require(\"./superPropBase.js\");\nfunction _get() {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get.bind(), module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n      if (desc.get) {\n        return desc.get.call(arguments.length < 3 ? target : receiver);\n      }\n      return desc.value;\n    }, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;\n  }\n  return _get.apply(this, arguments);\n}\nmodule.exports = _get, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var getPrototypeOf = require(\"./getPrototypeOf.js\");\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n  return object;\n}\nmodule.exports = _superPropBase, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;"],"names":["GenomesFile","genomesFile","nameKey","Error","requiredFields","forEach","genome","genomeName","missingFields","field","get","push","length","join","raFile_1","exports","HubFile","hubFile","hubTxtFields","extraFields","_value","key","includes","raStanza_1","trackDbFile_1","hubFile_1","genomesFile_1","RaFile","raFile","options","checkIndent","stanzas","_checkIndent","trimEnd","split","_stanzaAndCommentOrder","stanza","add","trim","startsWith","stanzaLines","map","line","every","this","raStanza","name","has","value","filter","undefined","size","entry","e","toString","Map","RaStanza","_keyAndCommentOrder","endsWith","trimmedLine","slice","_continuedLine","trimStart","combinedLine","indent","match","sep","indexOf","lines","TrackDbFile","trackDbFile","track","trackName","trackKeys","Array","from","keys","missingKeys","parentTrackKeys","some","settings","currentTrackName","currentTrack","set","parentTracks","reverse","parentTrack","superPropBase","_get","Reflect","module","bind","__esModule","target","property","receiver","base","desc","Object","getOwnPropertyDescriptor","call","arguments","apply","getPrototypeOf","object","prototype","hasOwnProperty"],"sourceRoot":""}