{"version":3,"file":"static/js/8930.d5d6b2c2.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature'\n\nconst readVcf = (f: string) => {\n  const header: string[] = []\n  const rest: string[] = []\n  f.split(/\\n|\\r\\n|\\r/)\n    .map(f => f.trim())\n    .filter(f => !!f)\n    .forEach(line => {\n      if (line.startsWith('#')) {\n        header.push(line)\n      } else if (line) {\n        rest.push(line)\n      }\n    })\n  return { header: header.join('\\n'), lines: rest }\n}\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected vcfFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  // converts lines into an interval tree\n  public async setupP() {\n    const pm = this.pluginManager\n    const buf = await openLocation(this.getConf('vcfLocation'), pm).readFile()\n\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n\n    const str = new TextDecoder().decode(buffer)\n    const { header, lines } = readVcf(str)\n\n    const intervalTree = lines\n      .map((line, id) => {\n        const [refName, startP, , ref, , , , info] = line.split('\\t')\n        const start = +startP - 1\n        const end = +(info.match(/END=(\\d+)/)?.[1].trim() || start + ref.length)\n        return { line, refName, start, end, id }\n      })\n      .reduce((acc, obj) => {\n        const key = obj.refName\n        if (!acc[key]) {\n          acc[key] = new IntervalTree()\n        }\n        acc[key].insert([obj.start, obj.end], obj)\n        return acc\n      }, {} as Record<string, IntervalTree>)\n\n    return { header, intervalTree }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch(e => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTree } = await this.setup()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { header, intervalTree } = await this.setup()\n        const parser = new VCF({ header: header })\n        intervalTree[refName]?.search([start, end]).forEach(f =>\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(f.line),\n              parser,\n              id: `${this.id}-${f.id}`,\n            }),\n          ),\n        )\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["readVcf","f","header","rest","split","map","trim","filter","forEach","line","startsWith","push","join","lines","isGzip","buf","VcfAdapter","vcfFeatures","this","setup","parser","VCF","getMetadata","pm","pluginManager","openLocation","getConf","readFile","unzip","buffer","length","Error","str","TextDecoder","decode","intervalTree","id","refName","startP","ref","start","end","match","reduce","acc","obj","key","IntervalTree","insert","setupP","catch","e","undefined","Object","keys","region","opts","ObservableCreate","observer","search","next","VcfFeature","variant","parseLine","complete","error","signal","BaseFeatureDataAdapter","capabilities"],"sourceRoot":""}