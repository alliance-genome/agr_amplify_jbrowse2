"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[4284,7706],{94284:(e,t,r)=>{r.r(t),r.d(t,{default:()=>l,isGzip:()=>o});var n=r(7706),i=r(99546),a=r(99834),s=r(46377);function o(e){return 31===e[0]&&139===e[1]&&8===e[2]}class l extends s.BaseAdapter{async getData(){const e=this.pluginManager,t=this.getConf("cytobandLocation");if(""===t.uri||"/path/to/cytoband.txt.gz"===t.uri)return[];const r=await(0,a.openLocation)(t,e).readFile(),s=o(r)?await(0,n.unzip)(r):r;return new TextDecoder("utf8",{fatal:!0}).decode(s).split(/\n|\r\n|\r/).filter((e=>!!e.trim())).map(((e,t)=>{const[r,n,a,s,o]=e.split("\t");return new i.SimpleFeature({uniqueId:`${t}`,refName:r,start:+n,end:+a,name:s,type:o})}))}freeResources(){}}},7706:(e,t,r)=>{r.d(t,{sG:()=>d,unzip:()=>s,i2:()=>o});var n=r(35451),i=r(45834),a=r(57864);async function s(e){try{let t,r=0,i=0;const s=[];let o,l=0;do{const n=e.subarray(r);if(o=new a.Inflate,({strm:t}=o),o.push(n,a.Z_SYNC_FLUSH),o.err)throw new Error(o.msg);r+=t.next_in,s[i]=o.result,l+=s[i].length,i+=1}while(t.avail_in);const h=new Uint8Array(l);for(let e=0,t=0;e<s.length;e++)h.set(s[e],t),t+=s[e].length;return n.Buffer.from(h)}catch(e){if(`${e}`.match(/incorrect header check/))throw new Error("problem decompressing block: incorrect gzip header check");throw e}}async function o(e,t){try{let r;const{minv:i,maxv:s}=t;let o=i.blockPosition,l=i.dataPosition;const h=[],c=[],d=[];let f=0,u=0;do{const t=e.subarray(o-i.blockPosition),n=new a.Inflate;if(({strm:r}=n),n.push(t,a.Z_SYNC_FLUSH),n.err)throw new Error(n.msg);const w=n.result;h.push(w);let g=w.length;c.push(o),d.push(l),1===h.length&&i.dataPosition&&(h[0]=h[0].subarray(i.dataPosition),g=h[0].length);const p=o;if(o+=r.next_in,l+=g,p>=s.blockPosition){h[u]=h[u].subarray(0,s.blockPosition===i.blockPosition?s.dataPosition-i.dataPosition+1:s.dataPosition+1),c.push(o),d.push(l),f+=h[u].length;break}f+=h[u].length,u++}while(r.avail_in);const w=new Uint8Array(f);for(let e=0,t=0;e<h.length;e++)w.set(h[e],t),t+=h[e].length;return{buffer:n.Buffer.from(w),cpositions:c,dpositions:d}}catch(e){if(`${e}`.match(/incorrect header check/))throw new Error("problem decompressing block: incorrect gzip header check");throw e}}var l=r(59086),h=r.n(l);class c{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else{if(!t)throw new TypeError("either filehandle or path must be defined");this.filehandle=new i.EY(t)}}_readLongWithOverflow(e,t=0,r=!0){const n=h().fromBytesLE(e.slice(t,t+8),r);if(n.greaterThan(Number.MAX_SAFE_INTEGER)||n.lessThan(Number.MIN_SAFE_INTEGER))throw new TypeError("integer overflow");return n.toNumber()}_getIndex(){return this.index||(this.index=this._readIndex()),this.index}async _readIndex(){let e=n.Buffer.allocUnsafe(8);await this.filehandle.read(e,0,8,0);const t=this._readLongWithOverflow(e,0,!0);if(!t)return[[0,0]];const r=new Array(t+1);r[0]=[0,0];const i=16*t;if(i>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");e=n.Buffer.allocUnsafe(i),await this.filehandle.read(e,0,i,8);for(let n=0;n<t;n+=1){const t=this._readLongWithOverflow(e,16*n),i=this._readLongWithOverflow(e,16*n+8);r[n+1]=[t,i]}return r}async getLastBlock(){const e=await this._getIndex();if(e.length)return e[e.length-1]}async getRelevantBlocksForRead(e,t){const r=t+e;if(0===e)return[];const n=await this._getIndex(),i=[],a=(e,r)=>{const n=e[1],i=r?r[1]:1/0;return n<=t&&i>t?0:n<t?-1:1};let s=0,o=n.length-1,l=Math.floor(n.length/2),h=a(n[l],n[l+1]);for(;0!==h;)h>0?o=l-1:h<0&&(s=l+1),l=Math.ceil((o-s)/2)+s,h=a(n[l],n[l+1]);i.push(n[l]);let c=l+1;for(;c<n.length&&(i.push(n[c]),!(n[c][1]>=r));c+=1);return i[i.length-1][1]<r&&i.push([]),i}}class d{constructor({filehandle:e,path:t,gziFilehandle:r,gziPath:n}){if(e)this.filehandle=e;else{if(!t)throw new TypeError("either filehandle or path must be defined");this.filehandle=new i.EY(t)}if(!r&&!n&&!t)throw new TypeError("either gziFilehandle or gziPath must be defined");this.gzi=new c({filehandle:r,path:r||n||!t?`${t}.gzi`:n})}async stat(){const e=await this.filehandle.stat();return Object.assign(e,{size:await this.getUncompressedFileSize(),blocks:void 0,blksize:void 0})}async getUncompressedFileSize(){const[,e]=await this.gzi.getLastBlock(),{size:t}=await this.filehandle.stat(),r=n.Buffer.allocUnsafe(4),{bytesRead:i}=await this.filehandle.read(r,0,4,t-28-4);if(4!==i)throw new Error("read error");return e+r.readUInt32LE(0)}async _readAndUncompressBlock(e,[t],[r]){let n=r;n||(n=(await this.filehandle.stat()).size);const i=n-t;return await this.filehandle.read(e,0,i,t),await s(e.slice(0,i))}async read(e,t,r,i){const a=await this.gzi.getRelevantBlocksForRead(r,i),s=n.Buffer.allocUnsafe(65536);let o=t,l=0;for(let t=0;t<a.length-1;t+=1){const n=await this._readAndUncompressBlock(s,a[t],a[t+1]),[,h]=a[t],c=h>=i?0:i-h,d=Math.min(i+r,h+n.length)-h;c>=0&&c<n.length&&(n.copy(e,o,c,d),o+=d-c,l+=d-c)}return{bytesRead:l,buffer:e}}}}}]);
//# sourceMappingURL=4284.b70965c6.chunk.js.map