{"version":3,"file":"static/js/305.2f954d6b.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nimport gff, { GFF3FeatureLineWithRefs } from '@gmod/gff'\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class extends BaseFeatureDataAdapter {\n  protected gffFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  private async loadDataP() {\n    const pm = this.pluginManager\n    const buf = await openLocation(this.getConf('gffLocation'), pm).readFile()\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/)\n    const headerLines = []\n    for (let i = 0; i < lines.length && lines[i].startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n\n    const feats = gff.parseStringSync(data, {\n      parseFeatures: true,\n      parseComments: false,\n      parseDirectives: false,\n      parseSequences: false,\n      disableDerivesFromReferences: true,\n    })\n\n    const intervalTree = {} as Record<string, IntervalTree>\n    for (const obj of feats.flat().map(\n      (f, i) =>\n        new SimpleFeature({\n          data: this.featureData(f),\n          id: `${this.id}-offset-${i}`,\n        }),\n    )) {\n      const key = obj.get('refName')\n      if (!intervalTree[key]) {\n        intervalTree[key] = new IntervalTree()\n      }\n      intervalTree[key].insert([obj.get('start'), obj.get('end')], obj)\n    }\n\n    return { header, intervalTree }\n  }\n\n  private async loadData() {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP().catch(e => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(_opts: BaseOptions = {}) {\n    const { intervalTree } = await this.loadData()\n    return Object.keys(intervalTree)\n  }\n\n  public async getHeader() {\n    const { header } = await this.loadData()\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTree } = await this.loadData()\n        intervalTree[refName]\n          ?.search([start, end])\n          .forEach(f => observer.next(f))\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  private featureData(data: GFF3FeatureLineWithRefs) {\n    const f: Record<string, unknown> = { ...data }\n    ;(f.start as number) -= 1 // convert to interbase\n    if (data.strand === '+') {\n      f.strand = 1\n    } else if (data.strand === '-') {\n      f.strand = -1\n    } else if (data.strand === '.') {\n      f.strand = 0\n    } else {\n      f.strand = undefined\n    }\n    f.phase = Number(data.phase)\n    f.refName = data.seq_id\n    if (data.score === null) {\n      delete f.score\n    }\n    if (data.phase === null) {\n      delete f.score\n    }\n    const defaultFields = new Set([\n      'start',\n      'end',\n      'seq_id',\n      'score',\n      'type',\n      'source',\n      'phase',\n      'strand',\n    ])\n    const dataAttributes = data.attributes || {}\n    for (const a of Object.keys(dataAttributes)) {\n      let b = a.toLowerCase()\n      if (defaultFields.has(b)) {\n        // add \"suffix\" to tag name if it already exists\n        // reproduces behavior of NCList\n        b += '2'\n      }\n      if (dataAttributes[a] !== null) {\n        let attr: string | string[] | undefined = dataAttributes[a]\n        if (Array.isArray(attr) && attr.length === 1) {\n          ;[attr] = attr\n        }\n        f[b] = attr\n      }\n    }\n    f.refName = f.seq_id\n\n    // the SimpleFeature constructor takes care of recursively inflating subfeatures\n    if (data.child_features && data.child_features.length > 0) {\n      f.subfeatures = data.child_features.flatMap(childLocs =>\n        childLocs.map(childLoc => this.featureData(childLoc)),\n      )\n    }\n\n    delete f.child_features\n    delete f.data\n    // delete f.derived_features\n    delete f.attributes\n    delete f.seq_id\n    return f\n  }\n\n  public freeResources(/* { region } */) {}\n}\n"],"names":["BaseFeatureDataAdapter","loadDataP","pm","this","pluginManager","buf","openLocation","getConf","readFile","buffer","isGzip","unzip","length","Error","data","TextDecoder","fatal","decode","lines","split","headerLines","i","startsWith","push","header","join","feats","gff","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","intervalTree","obj","flat","map","f","SimpleFeature","featureData","id","key","get","IntervalTree","insert","loadData","gffFeatures","catch","e","undefined","getRefNames","_opts","Object","keys","getHeader","getFeatures","query","opts","ObservableCreate","async","start","end","refName","search","forEach","observer","next","complete","error","signal","strand","phase","Number","seq_id","score","defaultFields","Set","dataAttributes","attributes","a","b","toLowerCase","has","attr","Array","isArray","child_features","subfeatures","flatMap","childLocs","childLoc","freeResources"],"sourceRoot":""}