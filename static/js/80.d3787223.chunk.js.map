{"version":3,"sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"names":["readVcf","f","lines","split","header","rest","forEach","line","startsWith","push","join","isGzip","buf","VcfAdapter","vcfFeatures","this","setup","a","parser","VCF","getMetadata","openLocation","readConfObject","config","pluginManager","readFile","buffer","unzip","length","Error","str","TextDecoder","decode","intervalTree","map","id","refName","startP","ref","start","end","match","trim","reduce","acc","obj","key","IntervalTree","insert","setupP","catch","e","undefined","Object","keys","region","opts","ObservableCreate","observer","search","next","VcfFeature","variant","parseLine","complete","error","signal","BaseFeatureDataAdapter","capabilities"],"mappings":"iTAcMA,EAAU,SAACC,GACf,IAAMC,EAAQD,EAAEE,MAAM,MAChBC,EAAmB,GACnBC,EAAiB,GAQvB,OAPAH,EAAMI,SAAQ,SAAAC,GACRA,EAAKC,WAAW,KAClBJ,EAAOK,KAAKF,GACHA,GACTF,EAAKI,KAAKF,MAGP,CAAEH,OAAQA,EAAOM,KAAK,MAAOR,MAAOG,IAG7C,SAASM,EAAOC,GACd,OAAkB,KAAXA,EAAI,IAAwB,MAAXA,EAAI,IAAyB,IAAXA,EAAI,G,IAG3BC,E,4MAGTC,iB,wFAKV,sGAC2BC,KAAKC,QADhC,uBACUZ,EADV,EACUA,OADV,kBAESA,GAFT,gD,sHAKA,gCAAAa,EAAA,sEAC2BF,KAAKC,QADhC,uBACUZ,EADV,EACUA,OACFc,EAAS,IAAIC,IAAI,CAAEf,OAAQA,IAFnC,kBAGSc,EAAOE,eAHhB,gD,iHAOA,gHACuBC,uBACnBC,yBAAeP,KAAKQ,OAAQ,eAC5BR,KAAKS,eACLC,WAJJ,WAMcd,EALNe,EADR,wCAMqCC,gBAAMD,GAN3C,+CAMqDA,EANrD,cAMQd,EANR,MASUgB,OAAS,WATnB,uBAUU,IAAIC,MAAM,8CAVpB,eAaQC,GAAM,IAAIC,aAAcC,OAAOpB,GAbvC,EAc4BZ,EAAQ8B,GAA1B1B,EAdV,EAcUA,OAAQF,EAdlB,EAckBA,MAEV+B,EAAe/B,EAClBgC,KAAI,SAAC3B,EAAM4B,GAAO,MACjB,EAA6C5B,EAAKJ,MAAM,MAAxD,mBAAOiC,EAAP,KAAgBC,EAAhB,KAA0BC,EAA1B,KACMC,GAASF,EAAS,EAExB,MAAO,CAAE9B,OAAM6B,UAASG,QAAOC,OADjB,UAFd,KAEmBC,MAAM,oBAAX,eAA0B,GAAGC,SAAUH,EAAQD,EAAIV,QAC7BO,SAErCQ,QAAO,SAACC,EAAKC,GACZ,IAAMC,EAAMD,EAAIT,QAKhB,OAJKQ,EAAIE,KACPF,EAAIE,GAAO,IAAIC,KAEjBH,EAAIE,GAAKE,OAAO,CAACH,EAAIN,MAAOM,EAAIL,KAAMK,GAC/BD,IACN,IA9BP,kBAgCS,CAAExC,SAAQ6B,iBAhCnB,iD,gHAmCA,gGACOlB,KAAKD,cACRC,KAAKD,YAAcC,KAAKkC,SAASC,OAAM,SAAAC,GAErC,MADA,EAAKrC,iBAAcsC,EACbD,MAJZ,kBAOSpC,KAAKD,aAPd,gD,sHAUA,wIAA0C,GAA1C,SACiCC,KAAKC,QADtC,uBACUiB,EADV,EACUA,aADV,kBAESoB,OAAOC,KAAKrB,IAFrB,gD,+EAKA,SAAmBsB,GAAwC,WAAxBC,EAAwB,uDAAJ,GACrD,OAAOC,2BAAgB,uCAAU,WAAMC,GAAN,6BAAAzC,EAAA,sEAErBsB,EAAwBgB,EAAxBhB,MAAOC,EAAiBe,EAAjBf,IAAKJ,EAAYmB,EAAZnB,QAFS,SAGU,EAAKpB,QAHf,gBAGrBZ,EAHqB,EAGrBA,OAAQ6B,EAHa,EAGbA,aACVf,EAAS,IAAIC,IAAI,CAAEf,OAAQA,IACjC,UAAA6B,EAAaG,UAAb,SAAuBuB,OAAO,CAACpB,EAAOC,IAAMlC,SAAQ,SAAAL,GAAC,OACnDyD,EAASE,KACP,IAAIC,IAAW,CACbC,QAAS5C,EAAO6C,UAAU9D,EAAEM,MAC5BW,SACAiB,GAAI,GAAF,OAAK,EAAKA,GAAV,YAAgBlC,EAAEkC,UAI1BuB,EAASM,WAdoB,kDAgB7BN,EAASO,MAAT,MAhB6B,0DAAV,sDAkBpBT,EAAKU,U,2BAGV,gB,GA5FsCC,0BAAnBtD,EACLuD,aAAe,CAAC,cAAe","file":"static/js/80.d3787223.chunk.js","sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\nimport VcfFeature from '../VcfTabixAdapter/VcfFeature'\n\nconst readVcf = (f: string) => {\n  const lines = f.split('\\n')\n  const header: string[] = []\n  const rest: string[] = []\n  lines.forEach(line => {\n    if (line.startsWith('#')) {\n      header.push(line)\n    } else if (line) {\n      rest.push(line)\n    }\n  })\n  return { header: header.join('\\n'), lines: rest }\n}\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected vcfFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  // converts lines into an interval tree\n  public async setupP() {\n    const buffer = await openLocation(\n      readConfObject(this.config, 'vcfLocation'),\n      this.pluginManager,\n    ).readFile()\n\n    const buf = isGzip(buffer) ? await unzip(buffer) : buffer\n\n    // 512MB  max chrome string length is 512MB\n    if (buf.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n\n    const str = new TextDecoder().decode(buf)\n    const { header, lines } = readVcf(str)\n\n    const intervalTree = lines\n      .map((line, id) => {\n        const [refName, startP, , ref, , , , info] = line.split('\\t')\n        const start = +startP - 1\n        const end = +(info.match(/END=(\\d+)/)?.[1].trim() || start + ref.length)\n        return { line, refName, start, end, id }\n      })\n      .reduce((acc, obj) => {\n        const key = obj.refName\n        if (!acc[key]) {\n          acc[key] = new IntervalTree()\n        }\n        acc[key].insert([obj.start, obj.end], obj)\n        return acc\n      }, {} as Record<string, IntervalTree>)\n\n    return { header, intervalTree }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch(e => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTree } = await this.setup()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { header, intervalTree } = await this.setup()\n        const parser = new VCF({ header: header })\n        intervalTree[refName]?.search([start, end]).forEach(f =>\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(f.line),\n              parser,\n              id: `${this.id}-${f.id}`,\n            }),\n          ),\n        )\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"sourceRoot":""}