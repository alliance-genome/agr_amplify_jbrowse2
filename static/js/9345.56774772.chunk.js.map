{"version":3,"file":"static/js/9345.56774772.chunk.js","mappings":"sOAkCe,MAAMA,UAAmBC,EAAAA,uBACtC,oBAA6B,CAAC,cAAe,eAO7C,eAAaC,GACX,MAAM,OAAEC,SAAiBC,KAAKC,QAC9B,OAAOF,CACT,CAEA,iBAAMG,GACJ,MAAM,OAAEH,SAAiBC,KAAKC,QAE9B,OADe,IAAIE,EAAAA,EAAI,CAAEJ,OAAQA,IACnBG,aAChB,CAGA,YAAaE,GACX,MAAMC,EAAKL,KAAKM,cACVC,QAAYC,EAAAA,EAAAA,cAAaR,KAAKS,QAAQ,eAAgBJ,GAAIK,WAE1DC,EA5BV,SAAgBJ,GACd,OAAkB,KAAXA,EAAI,IAAwB,MAAXA,EAAI,IAAyB,IAAXA,EAAI,EAChD,CA0BmBK,CAAOL,SAAaM,EAAAA,EAAAA,OAAMN,GAAOA,EAGhD,GAAII,EAAOG,OAAS,UAClB,MAAM,IAAIC,MAAM,8CAGlB,MAAMC,GAAM,IAAIC,aAAcC,OAAOP,IAC/B,OAAEZ,EAAM,MAAEoB,GApDHC,KACf,MAAMrB,EAAmB,GACnBsB,EAAiB,GAWvB,OAVAD,EAAEE,MAAM,cACLC,KAAIH,GAAKA,EAAEI,SACXC,QAAOL,KAAOA,IACdM,SAAQC,IACHA,EAAKC,WAAW,KAClB7B,EAAO8B,KAAKF,GACHA,GACTN,EAAKQ,KAAKF,EACZ,IAEG,CAAE5B,OAAQA,EAAO+B,KAAK,MAAOX,MAAOE,EAAM,EAuCrBU,CAAQf,GAC5BgB,EAAe,CAAC,EAEtB,IAAK,MAAMC,KAAOd,EAAMI,KAAI,CAACI,EAAMO,KACjC,MAAOC,EAASC,EAAO,CAAGC,EAAI,CAAD,EAAQC,GAAQX,EAAKL,MAAM,MAClDiB,GAASH,EAAS,EAClBI,EAAMD,EAAQF,EAAIvB,OAExB,MAAO,CAAEa,OAAMQ,UAASI,QAAOE,MADjBH,EAAKI,MAAM,eAAe,GAAGlB,QAAUgB,GACjBN,KAAI,IACtC,CACF,MAAMS,EAAMV,EAAIE,QACXH,EAAaW,KAChBX,EAAaW,GAAO,IAAIC,EAAAA,IAE1BZ,EAAaW,GAAKE,OAAO,CAACZ,EAAIM,MAAON,EAAIQ,KAAMR,EACjD,CAEA,MAAO,CAAElC,SAAQiC,eACnB,CAEA,WAAa/B,GAOX,OANKD,KAAK8C,cACR9C,KAAK8C,YAAc9C,KAAKI,SAAS2C,OAAMC,IAErC,MADAhD,KAAK8C,iBAAcG,EACbD,CAAC,KAGJhD,KAAK8C,WACd,CAEA,iBAAaI,CAAYC,EAAiB,CAAC,GACzC,MAAM,aAAEnB,SAAuBhC,KAAKC,QACpC,OAAOmD,OAAOC,KAAKrB,EACrB,CAEOsB,WAAAA,CAAYC,EAAgBC,EAAoB,CAAC,GACtD,OAAOC,EAAAA,EAAAA,mBAA0BC,UAC/B,IACE,MAAM,MAAEnB,EAAK,IAAEE,EAAG,QAAEN,GAAYoB,GAC1B,OAAExD,EAAM,aAAEiC,SAAuBhC,KAAKC,QACtC0D,EAAS,IAAIxD,EAAAA,EAAI,CAAEJ,WACzBiC,EAAaG,IAAUyB,OAAO,CAACrB,EAAOE,IAAMf,SAAQN,GAClDyC,EAASC,KACP,IAAIC,EAAAA,EAAW,CACbC,QAASL,EAAOM,UAAU7C,EAAEO,MAC5BgC,SACAzB,GAAK,GAAElC,KAAKkC,MAAMd,EAAEc,UAI1B2B,EAASK,UACX,CAAE,MAAOlB,GACPa,EAASM,MAAMnB,EACjB,IACCQ,EAAKY,OACV,CAEOC,aAAAA,GAAuB,E","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\n\n// local\nimport VcfFeature from '../VcfFeature'\n\nconst readVcf = (f: string) => {\n  const header: string[] = []\n  const rest: string[] = []\n  f.split(/\\n|\\r\\n|\\r/)\n    .map(f => f.trim())\n    .filter(f => !!f)\n    .forEach(line => {\n      if (line.startsWith('#')) {\n        header.push(line)\n      } else if (line) {\n        rest.push(line)\n      }\n    })\n  return { header: header.join('\\n'), lines: rest }\n}\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected vcfFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  // converts lines into an interval tree\n  public async setupP() {\n    const pm = this.pluginManager\n    const buf = await openLocation(this.getConf('vcfLocation'), pm).readFile()\n\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n\n    const str = new TextDecoder().decode(buffer)\n    const { header, lines } = readVcf(str)\n    const intervalTree = {} as Record<string, IntervalTree>\n\n    for (const obj of lines.map((line, id) => {\n      const [refName, startP, , ref, , , , info] = line.split('\\t')\n      const start = +startP - 1\n      const def = start + ref.length\n      const end = +(info.match(/END=(\\d+)/)?.[1].trim() || def)\n      return { line, refName, start, end, id }\n    })) {\n      const key = obj.refName\n      if (!intervalTree[key]) {\n        intervalTree[key] = new IntervalTree()\n      }\n      intervalTree[key].insert([obj.start, obj.end], obj)\n    }\n\n    return { header, intervalTree }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch(e => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTree } = await this.setup()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { header, intervalTree } = await this.setup()\n        const parser = new VCF({ header })\n        intervalTree[refName]?.search([start, end]).forEach(f =>\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(f.line),\n              parser,\n              id: `${this.id}-${f.id}`,\n            }),\n          ),\n        )\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","getHeader","header","this","setup","getMetadata","VCF","setupP","pm","pluginManager","buf","openLocation","getConf","readFile","buffer","isGzip","unzip","length","Error","str","TextDecoder","decode","lines","f","rest","split","map","trim","filter","forEach","line","startsWith","push","join","readVcf","intervalTree","obj","id","refName","startP","ref","info","start","def","end","match","key","IntervalTree","insert","vcfFeatures","catch","e","undefined","getRefNames","_","Object","keys","getFeatures","region","opts","ObservableCreate","async","parser","search","observer","next","VcfFeature","variant","parseLine","complete","error","signal","freeResources"],"sourceRoot":""}