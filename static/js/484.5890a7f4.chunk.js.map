{"version":3,"file":"static/js/484.5890a7f4.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/cram/src/unzip-pako.ts","../../../node_modules/@gmod/cram/src/errors.ts","../../../node_modules/@gmod/cram/src/rans/constants.js","../../../node_modules/@gmod/cram/src/rans/decoding.js","../../../node_modules/@gmod/cram/src/rans/frequencies.js","../../../node_modules/@gmod/cram/src/rans/index.js","../../../node_modules/@gmod/cram/src/cramFile/sectionParsers.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/getBits.ts","../../../node_modules/@gmod/cram/src/cramFile/util.ts","../../../node_modules/@gmod/cram/src/cramFile/constants.ts","../../../node_modules/@gmod/cram/src/cramFile/record.ts","../../../node_modules/@gmod/cram/src/cramFile/slice/decodeRecord.ts","../../../node_modules/@gmod/cram/src/cramFile/slice/index.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/_base.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/byteArrayLength.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/index.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/external.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/huffman.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/byteArrayStop.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/beta.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/subexp.ts","../../../node_modules/@gmod/cram/src/cramFile/codecs/gamma.ts","../../../node_modules/@gmod/cram/src/cramFile/container/compressionScheme.ts","../../../node_modules/@gmod/cram/src/cramFile/container/index.ts","../../../node_modules/@gmod/cram/src/io/index.ts","../../../node_modules/@gmod/cram/src/typescript.ts","../../../node_modules/@gmod/cram/src/sam.ts","../../../node_modules/@gmod/cram/src/cramFile/file.ts","../../../node_modules/@gmod/cram/src/rans/d04.js","../../../node_modules/@gmod/cram/src/rans/d14.js","../../../node_modules/@gmod/cram/src/cramFile/index.ts","../../../node_modules/@gmod/cram/src/indexedCramFile.ts","../../../node_modules/@gmod/cram/src/craiIndex.ts","../../../node_modules/@jkbonfield/htscodecs/arith_gen.js","../../../node_modules/@jkbonfield/htscodecs/arith_sh.js","../../../node_modules/@jkbonfield/htscodecs/byte_model.js","../../../node_modules/@jkbonfield/htscodecs/fqzcomp.js","../../../node_modules/@jkbonfield/htscodecs/index.js","../../../node_modules/@jkbonfield/htscodecs/iostream.js","../../../node_modules/@jkbonfield/htscodecs/rans.js","../../../node_modules/@jkbonfield/htscodecs/rans4x16.js","../../../node_modules/@jkbonfield/htscodecs/tok3.js","../../../node_modules/bzip2/bzip2.js","../../../node_modules/charenc/charenc.js","../../../node_modules/crypt/crypt.js","../../../node_modules/is-buffer/index.js","../../../node_modules/md5/md5.js"],"sourcesContent":["import { inflate } from 'pako'\n\nexport function unzip(input: Buffer) {\n  return Buffer.from(inflate(input))\n}\n","export class CramError extends Error {}\n\n/** Error caused by encountering a part of the CRAM spec that has not yet been implemented */\nexport class CramUnimplementedError extends Error {}\n\n/** An error caused by malformed data.  */\nexport class CramMalformedError extends CramError {}\n\n/**\n * An error caused by data being too big, exceeding a size limit.\n */\nexport class CramSizeLimitError extends CramError {}\n\n/**\n * An invalid argument was supplied to a cram-js method or object.\n */\nexport class CramArgumentError extends CramError {}\n","const TF_SHIFT = 12\nconst TOTFREQ = 1 << TF_SHIFT\nconst RANS_BYTE_L = 1 << 23\n\nexport { TF_SHIFT, TOTFREQ, RANS_BYTE_L }\n","import { CramMalformedError } from '../errors'\n\nimport { RANS_BYTE_L } from './constants'\n\nclass FC {\n  // int F, C;\n  constructor() {\n    this.F = undefined\n    this.C = undefined\n  }\n}\n\nclass AriDecoder {\n  // final FC[] fc = new FC[256];\n  // byte[] R;\n\n  constructor() {\n    this.fc = new Array(256)\n    for (let i = 0; i < this.fc.length; i += 1) {\n      this.fc[i] = new FC()\n    }\n    this.R = null\n  }\n}\n\nclass Symbol {\n  // int start; // Start of range.\n  // int freq; // Symbol frequency.\n  constructor() {\n    this.start = undefined\n    this.freq = undefined\n  }\n}\n\n// Initialize a decoder symbol to start \"start\" and frequency \"freq\"\nfunction symbolInit(sym, start, freq) {\n  if (!(start <= 1 << 16)) {\n    throw new CramMalformedError(`assertion failed: start <= 1<<16`)\n  }\n  if (!(freq <= (1 << 16) - start)) {\n    throw new CramMalformedError(`assertion failed: freq <= 1<<16`)\n  }\n  sym.start = start\n  sym.freq = freq\n}\n\n// Advances in the bit stream by \"popping\" a single symbol with range start\n// \"start\" and frequency \"freq\". All frequencies are assumed to sum to\n// \"1 << scaleBits\".\n// No renormalization or output happens.\n/* private static int */ function advanceStep(\n  /* final int */ r,\n  /* final int */ start,\n  /* final int */ freq,\n  /* final int */ scaleBits,\n) {\n  /* final int */ const mask = (1 << scaleBits) - 1\n\n  // s, x = D(x)\n  return freq * (r >> scaleBits) + (r & mask) - start\n}\n\n// Equivalent to RansDecAdvanceStep that takes a symbol.\n/* static int  */ function advanceSymbolStep(\n  /* final int */ r,\n  /* final RansDecSymbol */ sym,\n  /* final int */ scaleBits,\n) {\n  return advanceStep(r, sym.start, sym.freq, scaleBits)\n}\n\n// Returns the current cumulative frequency (map it to a symbol yourself!)\n/* static int */ function get(/* final int */ r, /* final int */ scaleBits) {\n  return r & ((1 << scaleBits) - 1)\n}\n\n// Advances in the bit stream by \"popping\" a single symbol with range start\n// \"start\" and frequency \"freq\". All frequencies are assumed to sum to\n// \"1 << scaleBits\",\n// and the resulting bytes get written to ptr (which is updated).\n/* private static int */ function advance(\n  /* int */ r,\n  /* final ByteBuffer */ pptr,\n  /* final int */ start,\n  /* final int */ freq,\n  /* final int */ scaleBits,\n) {\n  /* final int */ const mask = (1 << scaleBits) - 1\n\n  // s, x = D(x)\n  r = freq * (r >> scaleBits) + (r & mask) - start\n\n  // re-normalize\n  if (r < RANS_BYTE_L) {\n    do {\n      /* final int */ const b = 0xff & pptr.get()\n      r = (r << 8) | b\n    } while (r < RANS_BYTE_L)\n  }\n\n  return r\n}\n\n// Equivalent to RansDecAdvance that takes a symbol.\n/*  static int */ function advanceSymbol(\n  /* final int */ r,\n  /* final ByteBuffer */ pptr,\n  /* final RansDecSymbol */ sym,\n  /* final int */ scaleBits,\n) {\n  return advance(r, pptr, sym.start, sym.freq, scaleBits)\n}\n\n// Re-normalize.\n/*  static int */ function renormalize(\n  /* int */ r,\n  /* final ByteBuffer */ pptr,\n) {\n  // re-normalize\n  if (r < RANS_BYTE_L) {\n    do {\n      r = (r << 8) | (0xff & pptr.get())\n    } while (r < RANS_BYTE_L)\n  }\n\n  return r\n}\n\nconst Decode = {\n  FC,\n  AriDecoder,\n  Symbol,\n  symbolInit,\n  advanceStep,\n  advanceSymbolStep,\n  get,\n  advanceSymbol,\n  renormalize,\n}\n\nexport default Decode\n","import { CramMalformedError } from '../errors'\n\nimport { TOTFREQ } from './constants'\nimport Decoding from './decoding'\n\nfunction assert(result) {\n  if (!result) {\n    throw new CramMalformedError('assertion failed')\n  }\n}\n\nexport function readStatsO0(\n  /* ByteBuffer */ cp,\n  /* Decoding.AriDecoder */ decoder,\n  /* Decoding.RansDecSymbol[] */ syms,\n) {\n  // Pre-compute reverse lookup of frequency.\n  let rle = 0\n  let x = 0\n  let j = cp.get() & 0xff\n  do {\n    if (decoder.fc[j] == null) {\n      decoder.fc[j] = new Decoding.FC()\n    }\n    decoder.fc[j].F = cp.get() & 0xff\n    if (decoder.fc[j].F >= 128) {\n      decoder.fc[j].F &= ~128\n      decoder.fc[j].F = ((decoder.fc[j].F & 127) << 8) | (cp.get() & 0xff)\n    }\n    decoder.fc[j].C = x\n\n    Decoding.symbolInit(syms[j], decoder.fc[j].C, decoder.fc[j].F)\n\n    /* Build reverse lookup table */\n    if (!decoder.R) {\n      decoder.R = new Array(TOTFREQ)\n    }\n    decoder.R.fill(j, x, x + decoder.fc[j].F)\n\n    x += decoder.fc[j].F\n\n    if (rle === 0 && j + 1 === (0xff & cp.getByteAt(cp.position()))) {\n      j = cp.get() & 0xff\n      rle = cp.get() & 0xff\n    } else if (rle !== 0) {\n      rle -= 1\n      j += 1\n    } else {\n      j = cp.get() & 0xff\n    }\n  } while (j !== 0)\n\n  assert(x < TOTFREQ)\n}\n\nexport function readStatsO1(\n  /* ByteBuffer */ cp,\n  /*  Decoding.AriDecoder[] */ D,\n  /* Decoding.RansDecSymbol[][] */ syms,\n) {\n  let rlei = 0\n  let i = 0xff & cp.get()\n  do {\n    let rlej = 0\n    let x = 0\n    let j = 0xff & cp.get()\n    if (D[i] == null) {\n      D[i] = new Decoding.AriDecoder()\n    }\n    do {\n      if (D[i].fc[j] == null) {\n        D[i].fc[j] = new Decoding.FC()\n      }\n      D[i].fc[j].F = 0xff & cp.get()\n      if (D[i].fc[j].F >= 128) {\n        D[i].fc[j].F &= ~128\n        D[i].fc[j].F = ((D[i].fc[j].F & 127) << 8) | (0xff & cp.get())\n      }\n      D[i].fc[j].C = x\n\n      if (D[i].fc[j].F === 0) {\n        D[i].fc[j].F = TOTFREQ\n      }\n\n      if (syms[i][j] == null) {\n        syms[i][j] = new Decoding.RansDecSymbol()\n      }\n\n      Decoding.symbolInit(syms[i][j], D[i].fc[j].C, D[i].fc[j].F)\n\n      /* Build reverse lookup table */\n      if (D[i].R == null) {\n        D[i].R = new Array(TOTFREQ)\n      }\n      D[i].R.fill(j, x, x + D[i].fc[j].F)\n\n      x += D[i].fc[j].F\n      assert(x <= TOTFREQ)\n\n      if (rlej === 0 && j + 1 === (0xff & cp.getByteAt(cp.position()))) {\n        j = 0xff & cp.get()\n        rlej = 0xff & cp.get()\n      } else if (rlej !== 0) {\n        rlej -= 1\n        j += 1\n      } else {\n        j = 0xff & cp.get()\n      }\n    } while (j !== 0)\n\n    if (rlei === 0 && i + 1 === (0xff & cp.getByteAt(cp.position()))) {\n      i = 0xff & cp.get()\n      rlei = 0xff & cp.get()\n    } else if (rlei !== 0) {\n      rlei -= 1\n      i += 1\n    } else {\n      i = 0xff & cp.get()\n    }\n  } while (i !== 0)\n}\n","import { CramMalformedError } from '../errors'\n\nimport Decoding from './decoding'\nimport { readStatsO0, readStatsO1 } from './frequencies'\n\nimport D04 from './d04'\nimport D14 from './d14'\n\n// const /* int */ ORDER_BYTE_LENGTH = 1\n// const /* int */ COMPRESSED_BYTE_LENGTH = 4\nconst /* int */ RAW_BYTE_LENGTH = 4\n// const /* int */ PREFIX_BYTE_LENGTH =\n//   ORDER_BYTE_LENGTH + COMPRESSED_BYTE_LENGTH + RAW_BYTE_LENGTH\n\n// enum ORDER {\n//     ZERO, ONE;\n\n//     static ORDER fromInt(const /* int */ value) {\n//         try {\n//             return ORDER.values()[value];\n//         } catch (const ArrayIndexOutOfBoundsException e) {\n//             throw new RuntimeException(\"Unknown rANS order: \" + value);\n//         }\n//     }\n// }\n\n// static ByteBuffer compress(const ByteBuffer input, const ORDER order, const ByteBuffer out) {\n//     if (input.remaining() == 0)\n//         return EMPTY_BUFFER;\n\n//     if (input.remaining() < 4)\n//         return encode_order0_way4(input, out);\n\n//     switch (order) {\n//         case ZERO:\n//             return encode_order0_way4(input, out);\n//         case ONE:\n//             return encode_order1_way4(input, out);\n\n//         default:\n//             throw new RuntimeException(\"Unknown rANS order: \" + order);\n//     }\n// }\n\n// static /* ByteBuffer */ allocateIfNeeded(/* const int */ in_size,\n//                                            /* const ByteBuffer */ out_buf) {\n//     const /* int */ compressedSize = (/* int */) (1.05 * in_size + 257 * 257 * 3 + 4);\n//     if (out_buf == null)\n//         return ByteBuffer.allocate(compressedSize);\n//     if (out_buf.remaining() < compressedSize)\n//         throw new RuntimeException(\"Insufficient buffer size.\");\n//     out_buf.order(ByteOrder.LITTLE_ENDIAN);\n//     return out_buf;\n// }\n\n// static ByteBuffer encode_order0_way4(const ByteBuffer input,\n//                                              ByteBuffer out_buf) {\n//     const /* int */ in_size = input.remaining();\n//     out_buf = allocateIfNeeded(in_size, out_buf);\n//     const /* int */ freqTableStart = PREFIX_BYTE_LENGTH;\n//     out_buf.position(freqTableStart);\n\n//     const /* int */[] F = Frequencies.calcFrequencies_o0(in);\n//     const RansEncSymbol[] syms = Frequencies.buildSyms_o0(F);\n\n//     const ByteBuffer cp = out_buf.slice();\n//     const /* int */ frequencyTable_size = Frequencies.writeFrequencies_o0(cp, F);\n\n//     input.rewind();\n//     const /* int */ compressedBlob_size = E04.compress(input, syms, cp);\n\n//     finalizeCompressed(0, out_buf, in_size, frequencyTable_size,\n//             compressedBlob_size);\n//     return out_buf;\n// }\n\n// static ByteBuffer encode_order1_way4(const ByteBuffer input,\n//                                              ByteBuffer out_buf) {\n//     const /* int */ in_size = input.remaining();\n//     out_buf = allocateIfNeeded(in_size, out_buf);\n//     const /* int */ freqTableStart = PREFIX_BYTE_LENGTH;\n//     out_buf.position(freqTableStart);\n\n//     const /* int */[][] F = Frequencies.calcFrequencies_o1(in);\n//     const RansEncSymbol[][] syms = Frequencies.buildSyms_o1(F);\n\n//     const ByteBuffer cp = out_buf.slice();\n//     const /* int */ frequencyTable_size = Frequencies.writeFrequencies_o1(cp, F);\n\n//     input.rewind();\n//     const /* int */ compressedBlob_size = E14.compress(input, syms, cp);\n\n//     finalizeCompressed(1, out_buf, in_size, frequencyTable_size,\n//             compressedBlob_size);\n//     return out_buf;\n// }\n\n// static void finalizeCompressed(const /* int */ order, const ByteBuffer out_buf,\n//                                        const /* int */ in_size, const /* int */ frequencyTable_size, const /* int */ compressedBlob_size) {\n//     out_buf.limit(PREFIX_BYTE_LENGTH + frequencyTable_size\n//             + compressedBlob_size);\n//     out_buf.put(0, (byte) order);\n//     out_buf.order(ByteOrder.LITTLE_ENDIAN);\n//     const /* int */ compressedSizeOffset = ORDER_BYTE_LENGTH;\n//     out_buf.putInt(compressedSizeOffset, frequencyTable_size\n//             + compressedBlob_size);\n//     const /* int */ rawSizeOffset = ORDER_BYTE_LENGTH + COMPRESSED_BYTE_LENGTH;\n//     out_buf.putInt(rawSizeOffset, in_size);\n//     out_buf.rewind();\n// }\n\nfunction /* static ByteBuffer */ uncompressOrder0Way4(\n  /* const ByteBuffer  */ input,\n  /* const ByteBuffer  */ out,\n) {\n  // input.order(ByteOrder.LITTLE_ENDIAN);\n  const D = new Decoding.AriDecoder()\n  const syms = new Array(256)\n  for (let i = 0; i < syms.length; i += 1) {\n    syms[i] = new Decoding.Symbol()\n  }\n\n  readStatsO0(input, D, syms)\n\n  D04(input, D, syms, out)\n\n  return out\n}\n\nfunction /* static ByteBuffer */ uncompressOrder1Way4(\n  /* const ByteBuffer */ input,\n  /* const ByteBuffer */ output,\n) {\n  const D = new Array(256)\n  for (let i = 0; i < D.length; i += 1) {\n    D[i] = new Decoding.AriDecoder()\n  }\n  const /* Decoding.RansDecSymbol[][]  */ syms = new Array(256)\n  for (let i = 0; i < syms.length; i += 1) {\n    syms[i] = new Array(256)\n    for (let j = 0; j < syms[i].length; j += 1) {\n      syms[i][j] = new Decoding.Symbol()\n    }\n  }\n  readStatsO1(input, D, syms)\n\n  D14(input, output, D, syms)\n\n  return output\n}\n\n/* compat layer to make a node buffer act like a java ByteBuffer */\nclass ByteBuffer {\n  constructor(nodeBuffer, initialInputPosition = 0) {\n    this._buffer = nodeBuffer\n    this._position = initialInputPosition\n    this.length = nodeBuffer.length\n  }\n\n  get() {\n    const b = this._buffer[this._position]\n    this._position += 1\n    return b\n  }\n\n  getByte() {\n    return this.get()\n  }\n\n  getByteAt(position) {\n    return this._buffer[position]\n  }\n\n  position() {\n    return this._position\n  }\n\n  put(val) {\n    this._buffer[this._position] = val\n    this._position += 1\n    return val\n  }\n\n  putAt(position, val) {\n    this._buffer[position] = val\n    return val\n  }\n\n  setPosition(pos) {\n    this._position = pos\n    return pos\n  }\n\n  getInt() {\n    const i = this._buffer.readInt32LE(this._position)\n    this._position += 4\n    return i\n  }\n\n  remaining() {\n    return this._buffer.length - this._position\n  }\n}\n\n// static /* const */ ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\nexport default function uncompress(\n  inputBuffer,\n  outputBuffer,\n  initialInputPosition = 0,\n) {\n  if (inputBuffer.length === 0) {\n    outputBuffer.fill(0)\n    return outputBuffer\n  }\n\n  const input = new ByteBuffer(inputBuffer, initialInputPosition)\n  // input.order(ByteOrder.LITTLE_ENDIAN);\n\n  const order = input.get()\n  if (order !== 0 && order !== 1) {\n    throw new CramMalformedError(`Invalid rANS order ${order}`)\n  }\n\n  const /* int */ inputSize = input.getInt()\n  if (inputSize !== input.remaining() - RAW_BYTE_LENGTH) {\n    throw new CramMalformedError('Incorrect input length.')\n  }\n\n  const /* int */ outputSize = input.getInt()\n  const output = new ByteBuffer(outputBuffer || Buffer.allocUnsafe(outputSize))\n  // TODO output.limit(outputSize)\n\n  if (output.length < outputSize) {\n    throw new CramMalformedError(\n      `Output buffer too small to fit ${outputSize} bytes.`,\n    )\n  }\n\n  switch (order) {\n    case 0:\n      return uncompressOrder0Way4(input, output)\n\n    case 1:\n      return uncompressOrder1Way4(input, output)\n\n    default:\n      throw new CramMalformedError(`Invalid rANS order: ${order}`)\n  }\n}\n","import { Parser } from '@gmod/binary-parser'\nimport { TupleOf } from '../typescript'\nimport { ParsedItem } from './util'\nimport { DataSeriesEncodingMap } from './codecs/dataSeriesTypes'\nimport { CramEncoding } from './encoding'\n\nconst singleItf8 = new Parser().itf8()\n\nconst cramFileDefinition = {\n  parser: new Parser()\n    .string('magic', { length: 4 })\n    .uint8('majorVersion')\n    .uint8('minorVersion')\n    .string('fileId', { length: 20, stripNull: true }),\n  maxLength: 26,\n}\n\nconst cramBlockHeader = {\n  parser: new Parser()\n    .uint8('compressionMethod', {\n      formatter: /* istanbul ignore next */ b => {\n        const method = [\n          'raw',\n          'gzip',\n          'bzip2',\n          'lzma',\n          'rans',\n          'rans4x16',\n          'arith',\n          'fqzcomp',\n          'tok3',\n        ][b]\n        if (!method) {\n          throw new Error(`compression method number ${b} not implemented`)\n        }\n        return method\n      },\n    })\n    .uint8('contentType', {\n      formatter: /* istanbul ignore next */ b => {\n        const type = [\n          'FILE_HEADER',\n          'COMPRESSION_HEADER',\n          'MAPPED_SLICE_HEADER',\n          'UNMAPPED_SLICE_HEADER', // < only used in cram v1\n          'EXTERNAL_DATA',\n          'CORE_DATA',\n        ][b]\n        if (!type) {\n          throw new Error(`invalid block content type id ${b}`)\n        }\n        return type\n      },\n    })\n    .itf8('contentId')\n    .itf8('compressedSize')\n    .itf8('uncompressedSize'),\n  maxLength: 17,\n}\n\nconst cramBlockCrc32 = {\n  parser: new Parser().uint32('crc32'),\n  maxLength: 4,\n}\n\n// const ENCODING_NAMES = [\n//   'NULL', // 0\n//   'EXTERNAL', // 1\n//   'GOLOMB', // 2\n//   'HUFFMAN_INT', // 3\n//   'BYTE_ARRAY_LEN', // 4\n//   'BYTE_ARRAY_STOP', // 5\n//   'BETA', // 6\n//   'SUBEXP', // 7\n//   'GOLOMB_RICE', // 8\n//   'GAMMA', // 9\n// ]\n\nexport type CramTagDictionary = string[][]\n\nconst cramTagDictionary = new Parser().itf8('size').buffer('ents', {\n  length: 'size',\n  formatter: /* istanbul ignore next */ buffer => {\n    function makeTagSet(stringStart: number, stringEnd: number) {\n      const str = buffer.toString('utf8', stringStart, stringEnd)\n      const tags = []\n      for (let i = 0; i < str.length; i += 3) {\n        tags.push(str.substr(i, 3))\n      }\n      return tags\n    }\n\n    /* eslint-disable */\n    var tagSets = []\n    var stringStart = 0\n    var i\n    /* eslint-enable */\n    for (i = 0; i < buffer.length; i += 1) {\n      if (!buffer[i]) {\n        tagSets.push(makeTagSet(stringStart, i))\n        stringStart = i + 1\n      }\n    }\n    if (i > stringStart) {\n      tagSets.push(makeTagSet(stringStart, i))\n    }\n    return tagSets\n  },\n})\n\n// const cramPreservationMapKeys = 'XX RN AP RR SM TD'.split(' ')\nconst parseByteAsBool = new Parser().uint8(null, {\n  formatter: /* istanbul ignore next */ val => !!val,\n})\n\nexport type CramPreservationMap = {\n  MI: boolean\n  UI: boolean\n  PI: boolean\n  RN: boolean\n  AP: boolean\n  RR: boolean\n  SM: [number, number, number, number, number]\n  TD: CramTagDictionary\n}\n\nconst cramPreservationMap = new Parser()\n  .itf8('mapSize')\n  .itf8('mapCount')\n  .array('ents', {\n    length: 'mapCount',\n    type: new Parser()\n      .string('key', {\n        length: 2,\n        stripNull: false,\n        // formatter: val => cramPreservationMapKeys[val] || 0,\n      })\n      .choice('value', {\n        tag: 'key',\n        choices: {\n          MI: parseByteAsBool,\n          UI: parseByteAsBool,\n          PI: parseByteAsBool,\n          RN: parseByteAsBool,\n          AP: parseByteAsBool,\n          RR: parseByteAsBool,\n          SM: new Parser().array(null, { type: 'uint8', length: 5 }),\n          TD: new Parser().nest(null, {\n            type: cramTagDictionary,\n            formatter: /* istanbul ignore next */ data => data.ents,\n          }),\n        },\n      }),\n  })\n\n/* istanbul ignore next */\nfunction formatMap<T>(data: { ents: { key: string; value: T }[] }) {\n  const map: { [x: string]: T } = {}\n  for (let i = 0; i < data.ents.length; i += 1) {\n    const { key, value } = data.ents[i]\n    if (map[key]) {\n      console.warn(`duplicate key ${key} in map`)\n    }\n    map[key] = value\n  }\n  return map\n}\n\nconst unversionedParsers = {\n  cramFileDefinition,\n  cramBlockHeader,\n  cramBlockCrc32,\n}\n\nexport type MappedSliceHeader = {\n  refSeqId: number\n  refSeqStart: number\n  refSeqSpan: number\n  numRecords: number\n  recordCounter: number\n  numBlocks: number\n  numContentIds: number\n  contentIds: number[]\n  refBaseBlockId: number\n  md5: TupleOf<number, 16>\n}\n\nexport type UnmappedSliceHeader = {\n  numRecords: number\n  recordCounter: number\n  numBlocks: number\n  numContentIds: number\n  contentIds: number[]\n  md5: TupleOf<number, 16>\n}\n\nexport function isMappedSliceHeader(\n  header: MappedSliceHeader | UnmappedSliceHeader,\n): header is MappedSliceHeader {\n  return typeof (header as any).refSeqId === 'number'\n}\n\n// each of these is a function of the major and minor version\nconst versionedParsers = {\n  // assemble a section parser for the unmapped slice header, with slight\n  // variations depending on the major version of the cram file\n  cramUnmappedSliceHeader(majorVersion: number) {\n    let maxLength = 0\n    let parser = new Parser().itf8('numRecords')\n    maxLength += 5\n\n    // recordCounter is itf8 in a CRAM v2 file, absent in CRAM v1\n    if (majorVersion >= 3) {\n      parser = parser.ltf8('recordCounter')\n      maxLength += 9\n    } else if (majorVersion === 2) {\n      parser = parser.itf8('recordCounter')\n      maxLength += 5\n    }\n\n    parser = parser\n      .itf8('numBlocks')\n      .itf8('numContentIds')\n      .array('contentIds', {\n        type: singleItf8,\n        length: 'numContentIds',\n      })\n    maxLength += 5 * 2 // + numContentIds*5\n\n    // the md5 sum is missing in cram v1\n    if (majorVersion >= 2) {\n      parser = parser.array('md5', { type: 'uint8', length: 16 })\n      maxLength += 16\n    }\n\n    const maxLengthFunc = (numContentIds: number) =>\n      maxLength + numContentIds * 5\n\n    return { parser, maxLength: maxLengthFunc } // : p, maxLength: numContentIds => 5 + 9 + 5 * 2 + 5 * numContentIds + 16 }\n  },\n\n  // assembles a section parser for the unmapped slice header, with slight\n  // variations depending on the major version of the cram file\n  cramMappedSliceHeader(majorVersion: number) {\n    let parser = new Parser()\n      .itf8('refSeqId')\n      .itf8('refSeqStart')\n      .itf8('refSeqSpan')\n      .itf8('numRecords')\n    let maxLength = 5 * 4\n\n    if (majorVersion >= 3) {\n      parser = parser.ltf8('recordCounter')\n      maxLength += 9\n    } else if (majorVersion === 2) {\n      parser = parser.itf8('recordCounter')\n      maxLength += 5\n    }\n\n    parser = parser\n      .itf8('numBlocks')\n      .itf8('numContentIds')\n      .array('contentIds', {\n        type: singleItf8,\n        length: 'numContentIds',\n      })\n      .itf8('refBaseBlockId')\n    maxLength += 5 * 3\n\n    // the md5 sum is missing in cram v1\n    if (majorVersion >= 2) {\n      parser = parser.array('md5', { type: 'uint8', length: 16 })\n      maxLength += 16\n    }\n\n    const maxLengthFunc = (numContentIds: number) =>\n      maxLength + numContentIds * 5\n\n    return { parser, maxLength: maxLengthFunc }\n  },\n\n  cramEncoding(majorVersion: number) {\n    const parser = new Parser()\n      .namely('cramEncoding')\n      .itf8('codecId')\n      .itf8('parametersBytes')\n      .choice('parameters', {\n        tag: 'codecId',\n        choices: {\n          0: new Parser(), // NULL\n          1: new Parser().itf8('blockContentId'), // EXTERNAL\n          2: new Parser().itf8('offset').itf8('M'), // GOLOMB,\n          // HUFFMAN_INT\n          3: Parser.start()\n            .itf8('numCodes')\n            .array('symbols', { length: 'numCodes', type: singleItf8 })\n            .itf8('numLengths')\n            .array('bitLengths', { length: 'numLengths', type: singleItf8 }),\n          4: Parser.start() // BYTE_ARRAY_LEN\n            .nest('lengthsEncoding', { type: 'cramEncoding' })\n            .nest('valuesEncoding', { type: 'cramEncoding' }),\n          // BYTE_ARRAY_STOP is a little different for CRAM v1\n          5: new Parser().uint8('stopByte').itf8('blockContentId'),\n          6: new Parser().itf8('offset').itf8('length'), // BETA\n          7: new Parser().itf8('offset').itf8('K'), // SUBEXP\n          8: new Parser().itf8('offset').itf8('log2m'), // GOLOMB_RICE\n          9: new Parser().itf8('offset'), // GAMMA\n        },\n      })\n\n    return { parser }\n  },\n\n  cramDataSeriesEncodingMap(majorVersion: number) {\n    return new Parser()\n      .itf8('mapSize')\n      .itf8('mapCount')\n      .array('ents', {\n        length: 'mapCount',\n        type: new Parser()\n          .string('key', { length: 2, stripNull: false })\n          .nest('value', { type: this.cramEncoding(majorVersion).parser }),\n      })\n  },\n\n  cramTagEncodingMap(majorVersion: number) {\n    return new Parser()\n      .itf8('mapSize')\n      .itf8('mapCount')\n      .array('ents', {\n        length: 'mapCount',\n        type: new Parser()\n          .itf8('key', {\n            formatter: /* istanbul ignore next */ integerRepresentation =>\n              /* istanbul ignore next */\n              String.fromCharCode((integerRepresentation >> 16) & 0xff) +\n              String.fromCharCode((integerRepresentation >> 8) & 0xff) +\n              String.fromCharCode(integerRepresentation & 0xff),\n          })\n          .nest('value', { type: this.cramEncoding(majorVersion).parser }),\n      })\n  },\n\n  cramCompressionHeader(majorVersion: number) {\n    let parser = new Parser()\n    // TODO: if we want to support CRAM v1, we will need to refactor\n    // compression header into 2 parts to parse the landmarks,\n    // like the container header\n    parser = parser\n      .nest('preservation', {\n        type: cramPreservationMap,\n        formatter: formatMap,\n      })\n      .nest('dataSeriesEncoding', {\n        type: this.cramDataSeriesEncodingMap(majorVersion),\n        formatter: formatMap,\n      })\n      .nest('tagEncoding', {\n        type: this.cramTagEncodingMap(majorVersion),\n        formatter: formatMap,\n      })\n    return { parser }\n  },\n\n  cramContainerHeader1(majorVersion: number) {\n    let parser = new Parser()\n      .int32('length') // byte size of the container data (blocks)\n      .itf8('refSeqId') // reference sequence identifier, -1 for unmapped reads, -2 for multiple reference sequences\n      .itf8('refSeqStart') // the alignment start position or 0 for unmapped reads\n      .itf8('alignmentSpan') // the length of the alignment or 0 for unmapped reads\n      .itf8('numRecords') // number of records in the container\n    let maxLength = 4 + 5 * 4\n\n    if (majorVersion >= 3) {\n      parser = parser.ltf8('recordCounter') // 1-based sequential index of records in the file/stream.\n      maxLength += 9\n    } else if (majorVersion === 2) {\n      parser = parser.itf8('recordCounter')\n      maxLength += 5\n    }\n\n    if (majorVersion > 1) {\n      parser = parser.ltf8('numBases') // number of read bases\n      maxLength += 9\n    }\n    parser = parser\n      .itf8('numBlocks') // the number of blocks\n      .itf8('numLandmarks') // the number of landmarks\n    maxLength += 5 + 5\n\n    return { parser, maxLength }\n  },\n\n  cramContainerHeader2(majorVersion: number) {\n    let parser = new Parser()\n      .itf8('numLandmarks') // the number of blocks\n      // Each integer value of this array is a byte offset\n      // into the blocks byte array. Landmarks are used for\n      // random access indexing.\n      .array('landmarks', {\n        type: new Parser().itf8(),\n        length: 'numLandmarks',\n      })\n\n    let crcLength = 0\n    if (majorVersion >= 3) {\n      parser = parser.uint32('crc32')\n      crcLength = 4\n    }\n    return {\n      parser,\n      maxLength: (numLandmarks: number) => 5 + numLandmarks * 5 + crcLength,\n    }\n  },\n}\n\nexport type CompressionMethod =\n  | 'raw'\n  | 'gzip'\n  | 'bzip2'\n  | 'lzma'\n  | 'rans'\n  | 'rans4x16'\n  | 'arith'\n  | 'fqzcomp'\n  | 'tok3'\n\nexport type BlockHeader = {\n  compressionMethod: CompressionMethod\n  contentType:\n    | 'FILE_HEADER'\n    | 'COMPRESSION_HEADER'\n    | 'MAPPED_SLICE_HEADER'\n    | 'UNMAPPED_SLICE_HEADER' // < only used in cram v1\n    | 'EXTERNAL_DATA'\n    | 'CORE_DATA'\n  contentId: number\n  compressedSize: number\n  uncompressedSize: number\n}\n\nexport type CramCompressionHeader = ParsedItem<{\n  preservation: CramPreservationMap\n  dataSeriesEncoding: DataSeriesEncodingMap\n  tagEncoding: Record<string, CramEncoding>\n}>\n\nfunction getSectionParsers(majorVersion: number): {\n  cramFileDefinition: {\n    parser: Parser<{\n      magic: string\n      majorVersion: number\n      minorVersion: number\n      fileId: string\n    }>\n    maxLength: number\n  }\n  cramContainerHeader1: {\n    parser: Parser<{\n      length: number\n      refSeqId: number\n      refSeqStart: number\n      alignmentSpan: number\n      numRecords: number\n      recordCounter: number\n      numBases: number\n      numBlocks: number\n      numLandmarks: number\n    }>\n    maxLength: number\n  }\n  cramContainerHeader2: {\n    parser: Parser<{\n      numLandmarks: number\n      landmarks: number[]\n      crc32: number\n    }>\n    maxLength: (x: number) => number\n  }\n  cramBlockHeader: {\n    parser: Parser<BlockHeader>\n    maxLength: number\n  }\n  cramBlockCrc32: {\n    parser: Parser<{ crc32: number }>\n    maxLength: number\n  }\n  cramCompressionHeader: {\n    parser: Parser<CramCompressionHeader>\n  }\n  cramMappedSliceHeader: {\n    parser: Parser<MappedSliceHeader>\n    maxLength: (numContentIds: number) => number\n  }\n  cramUnmappedSliceHeader: {\n    parser: Parser<UnmappedSliceHeader>\n    maxLength: (numContentIds: number) => number\n  }\n} {\n  const parsers: any = Object.assign({}, unversionedParsers)\n  Object.keys(versionedParsers).forEach(parserName => {\n    parsers[parserName] = (versionedParsers as any)[parserName](majorVersion)\n  })\n  return parsers\n}\n\nexport { cramFileDefinition, getSectionParsers }\n","export class CramBufferOverrunError extends Error {}\n\nexport function getBits(\n  data: Buffer,\n  cursor: { bytePosition: number; bitPosition: number },\n  numBits: number,\n) {\n  let val = 0\n  if (\n    cursor.bytePosition + (7 - cursor.bitPosition + numBits) / 8 >\n    data.length\n  ) {\n    throw new CramBufferOverrunError(\n      'read error during decoding. the file seems to be truncated.',\n    )\n  }\n  for (let dlen = numBits; dlen; dlen--) {\n    // get the next `dlen` bits in the input, put them in val\n    val <<= 1\n    val |= (data[cursor.bytePosition] >> cursor.bitPosition) & 1\n    cursor.bitPosition -= 1\n    if (cursor.bitPosition < 0) {\n      cursor.bytePosition += 1\n    }\n    cursor.bitPosition &= 7\n  }\n  return val\n}\n","import md5 from 'md5'\nimport { Parser } from '@gmod/binary-parser'\nimport { CramBufferOverrunError } from './codecs/getBits'\n\nexport function itf8Size(v: number) {\n  if (!(v & ~0x7f)) {\n    return 1\n  }\n  if (!(v & ~0x3fff)) {\n    return 2\n  }\n  if (!(v & ~0x1fffff)) {\n    return 3\n  }\n  if (!(v & ~0xfffffff)) {\n    return 4\n  }\n  return 5\n}\n\nexport function parseItf8(\n  buffer: Uint8Array,\n  initialOffset: number,\n): [number, number] {\n  let offset = initialOffset\n  const countFlags = buffer[offset]\n  let result\n  if (countFlags < 0x80) {\n    result = countFlags\n    offset = offset + 1\n  } else if (countFlags < 0xc0) {\n    result = ((countFlags << 8) | buffer[offset + 1]) & 0x3fff\n    offset = offset + 2\n  } else if (countFlags < 0xe0) {\n    result =\n      ((countFlags << 16) | (buffer[offset + 1] << 8) | buffer[offset + 2]) &\n      0x1fffff\n    offset = offset + 3\n  } else if (countFlags < 0xf0) {\n    result =\n      ((countFlags << 24) |\n        (buffer[offset + 1] << 16) |\n        (buffer[offset + 2] << 8) |\n        buffer[offset + 3]) &\n      0x0fffffff\n    offset = offset + 4\n  } else {\n    result =\n      ((countFlags & 0x0f) << 28) |\n      (buffer[offset + 1] << 20) |\n      (buffer[offset + 2] << 12) |\n      (buffer[offset + 3] << 4) |\n      (buffer[offset + 4] & 0x0f)\n    // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);\n    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n    offset = offset + 5\n  }\n  if (offset > buffer.length) {\n    throw new CramBufferOverrunError(\n      'Attempted to read beyond end of buffer; this file seems truncated.',\n    )\n  }\n  return [result, offset - initialOffset]\n}\n\n// parseLtf8(buffer, initialOffset) {\n//   let offset = initialOffset\n//   const countFlags = buffer[offset]\n//   let result\n//   if (countFlags < 0x80) {\n//     result = countFlags\n//     offset += 1\n//   } else if (countFlags < 0xc0) {\n//     result = ((buffer[offset] << 8) | buffer[offset + 1]) & 0x3fff\n//     offset += 2\n//   } else if (countFlags < 0xe0) {\n//     result =\n//       ((buffer[offset] << 16) |\n//         (buffer[offset + 1] << 8) |\n//         buffer[offset + 2]) &\n//       0x1fffff\n//     offset += 3\n//   } else if (countFlags < 0xf0) {\n//     result =\n//       ((buffer[offset] << 24) |\n//         (buffer[offset + 1] << 16) |\n//         (buffer[offset + 2] << 8) |\n//         buffer[offset + 3]) &\n//       0x0fffffff\n//     offset += 4\n//   } else if (countFlags < 0xf8) {\n//     result =\n//       ((buffer[offset] & 15) * Math.pow(2,32) + (buffer[offset + 1] << 24)) |\n//       ((buffer[offset + 2] << 16) |\n//         (buffer[offset + 3] << 8) |\n//         buffer[offset + 4])\n//     // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n//     offset += 5\n//   } else if (countFlags < 0xfc) {\n//     result =\n//       ((((buffer[offset] & 7) << 8) | buffer[offset + 1]) * Math.pow(2,32) +\n//         (buffer[offset + 2] << 24)) |\n//       ((buffer[offset + 3] << 16) |\n//         (buffer[offset + 4] << 8) |\n//         buffer[offset + 5])\n//     offset += 6\n//   } else if (countFlags < 0xfe) {\n//     result =\n//       ((((buffer[offset] & 3) << 16) |\n//         (buffer[offset + 1] << 8) |\n//         buffer[offset + 2]) *\n//         Math.pow(2,32) +\n//         (buffer[offset + 3] << 24)) |\n//       ((buffer[offset + 4] << 16) |\n//         (buffer[offset + 5] << 8) |\n//         buffer[offset + 6])\n//     offset += 7\n//   } else if (countFlags < 0xff) {\n//     result = Long.fromBytesBE(buffer.slice(offset + 1, offset + 8))\n//     if (\n//       result.greaterThan(Number.MAX_SAFE_INTEGER) ||\n//       result.lessThan(Number.MIN_SAFE_INTEGER)\n//     )\n//       throw new CramUnimplementedError('integer overflow')\n//     result = result.toNumber()\n//     offset += 8\n//   } else {\n//     result = Long.fromBytesBE(buffer.slice(offset + 1, offset + 9))\n//     if (\n//       result.greaterThan(Number.MAX_SAFE_INTEGER) ||\n//       result.lessThan(Number.MIN_SAFE_INTEGER)\n//     )\n//       throw new CramUnimplementedError('integer overflow')\n//     result = result.toNumber()\n//     offset += 9\n//   }\n//   return [result, offset - initialOffset]\n// },\n\nexport type ParsedItem<T> = T & {\n  _endPosition: number\n  _size: number\n}\n\nexport function parseItem<T>(\n  buffer: Buffer,\n  parser: Parser<T>,\n  startBufferPosition = 0,\n  startFilePosition = 0,\n): ParsedItem<T> {\n  const { offset, result } = parser.parse(buffer)\n  return {\n    ...result,\n    _endPosition: offset + startFilePosition,\n    _size: offset - startBufferPosition,\n  }\n}\n\n// this would be nice as a decorator, but i'm a little worried about\n// babel support for it going away or changing.\n// memoizes a method in the stupidest possible way, with no regard for the\n// arguments.  actually, this only works on methods that take no arguments\nexport function tinyMemoize(_class: any, methodName: any) {\n  const method = _class.prototype[methodName]\n  const memoAttrName = `_memo_${methodName}`\n  _class.prototype[methodName] = function _tinyMemoized() {\n    if (!(memoAttrName in this)) {\n      const res = method.call(this)\n      this[memoAttrName] = res\n      Promise.resolve(res).catch(() => {\n        delete this[memoAttrName]\n      })\n    }\n    return this[memoAttrName]\n  }\n}\n\nexport function sequenceMD5(seq: string) {\n  return md5(seq.toUpperCase().replace(/[^\\x21-\\x7e]/g, ''))\n}\n","const Constants = {\n  CRAM_FLAG_PRESERVE_QUAL_SCORES: 1 << 0,\n  CRAM_FLAG_DETACHED: 1 << 1,\n  CRAM_FLAG_MATE_DOWNSTREAM: 1 << 2,\n  CRAM_FLAG_NO_SEQ: 1 << 3,\n  CRAM_FLAG_MASK: (1 << 4) - 1,\n\n  // mate read is reversed\n  CRAM_M_REVERSE: 1,\n  // mated read is unmapped\n  CRAM_M_UNMAP: 2,\n\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n\n  BAM_CMATCH: 0,\n  BAM_CINS: 1,\n  BAM_CDEL: 2,\n  BAM_CREF_SKIP: 3,\n  BAM_CSOFT_CLIP: 4,\n  BAM_CHARD_CLIP: 5,\n  BAM_CPAD: 6,\n  BAM_CEQUAL: 7,\n  BAM_CDIFF: 8,\n  BAM_CBACK: 9,\n\n  BAM_CIGAR_STR: 'MIDNSHP:XB',\n  BAM_CIGAR_SHIFT: 4,\n  BAM_CIGAR_MASK: 0xf,\n  BAM_CIGAR_TYPE: 0x3c1a7,\n}\n\nexport default Constants\n","import Constants from './constants'\nimport CramContainerCompressionScheme from './container/compressionScheme'\nimport decodeRecord from './slice/decodeRecord'\n\nexport type RefRegion = {\n  start: number\n  end: number\n  seq: string\n}\n\nexport type ReadFeature = {\n  code: string\n  pos: number\n  refPos: number\n  data: any\n\n  ref?: string\n  sub?: string\n}\n\nfunction decodeReadSequence(\n  cramRecord: CramRecord,\n  refRegion: RefRegion,\n): string | null {\n  // if it has no length, it has no sequence\n  if (!cramRecord.lengthOnRef && !cramRecord.readLength) {\n    return null\n  }\n\n  if (cramRecord.isUnknownBases()) {\n    return null\n  }\n\n  // remember: all coordinates are 1-based closed\n  const regionSeqOffset = cramRecord.alignmentStart - refRegion.start\n\n  if (!cramRecord.readFeatures) {\n    return refRegion.seq\n      .substr(regionSeqOffset, cramRecord.lengthOnRef)\n      .toUpperCase()\n  }\n\n  let bases = ''\n  let regionPos = regionSeqOffset\n  let currentReadFeature = 0\n  while (bases.length < cramRecord.readLength) {\n    if (currentReadFeature < cramRecord.readFeatures.length) {\n      const feature = cramRecord.readFeatures[currentReadFeature]\n      if (feature.code === 'Q' || feature.code === 'q') {\n        currentReadFeature += 1\n      } else if (feature.pos === bases.length + 1) {\n        // process the read feature\n        currentReadFeature += 1\n\n        if (feature.code === 'b') {\n          // specify a base pair for some reason\n          const added = feature.data\n          bases += added\n          regionPos += added.length\n        } else if (feature.code === 'B') {\n          // base pair and associated quality\n          // TODO: do we need to set the quality in the qual scores?\n          bases += feature.data[0]\n          regionPos += 1\n        } else if (feature.code === 'X') {\n          // base substitution\n          bases += feature.sub\n          regionPos += 1\n        } else if (feature.code === 'I') {\n          // insertion\n          bases += feature.data\n        } else if (feature.code === 'D') {\n          // deletion\n          regionPos += feature.data\n        } else if (feature.code === 'i') {\n          // insert single base\n          bases += feature.data\n        } else if (feature.code === 'N') {\n          // reference skip. delete some bases\n          // do nothing\n          // seqBases.splice(feature.pos - 1, feature.data)\n          regionPos += feature.data\n        } else if (feature.code === 'S') {\n          // soft clipped bases that should be present in the read seq\n          // seqBases.splice(feature.pos - 1, 0, ...feature.data.split(''))\n          bases += feature.data\n        } else if (feature.code === 'P') {\n          // padding, do nothing\n        } else if (feature.code === 'H') {\n          // hard clip, do nothing\n        }\n      } else if (currentReadFeature < cramRecord.readFeatures.length) {\n        // put down a chunk of sequence up to the next read feature\n        const chunk = refRegion.seq.substr(\n          regionPos,\n          cramRecord.readFeatures[currentReadFeature].pos - bases.length - 1,\n        )\n        bases += chunk\n        regionPos += chunk.length\n      }\n    } else {\n      // put down a chunk of reference up to the full read length\n      const chunk = refRegion.seq.substr(\n        regionPos,\n        cramRecord.readLength - bases.length,\n      )\n      bases += chunk\n      regionPos += chunk.length\n    }\n  }\n\n  return bases.toUpperCase()\n}\n\nconst baseNumbers = {\n  a: 0,\n  A: 0,\n  c: 1,\n  C: 1,\n  g: 2,\n  G: 2,\n  t: 3,\n  T: 3,\n  n: 4,\n  N: 4,\n}\n\nfunction decodeBaseSubstitution(\n  cramRecord: CramRecord,\n  refRegion: RefRegion,\n  compressionScheme: CramContainerCompressionScheme,\n  readFeature: ReadFeature,\n) {\n  if (!refRegion) {\n    return\n  }\n\n  // decode base substitution code using the substitution matrix\n  const refCoord = readFeature.refPos - refRegion.start\n  const refBase = refRegion.seq.charAt(refCoord)\n  if (refBase) {\n    readFeature.ref = refBase\n  }\n  let baseNumber = (baseNumbers as any)[refBase]\n  if (baseNumber === undefined) {\n    baseNumber = 4\n  }\n  const substitutionScheme = compressionScheme.substitutionMatrix[baseNumber]\n  const base = substitutionScheme[readFeature.data]\n  if (base) {\n    readFeature.sub = base\n  }\n}\n\nexport type MateRecord = {\n  readName?: string\n  sequenceId: number\n  alignmentStart: number\n  flags?: number\n\n  uniqueId?: number\n}\n\nexport const BamFlags = [\n  [0x1, 'Paired'],\n  [0x2, 'ProperlyPaired'],\n  [0x4, 'SegmentUnmapped'],\n  [0x8, 'MateUnmapped'],\n  [0x10, 'ReverseComplemented'],\n  //  the mate is mapped to the reverse strand\n  [0x20, 'MateReverseComplemented'],\n  //  this is read1\n  [0x40, 'Read1'],\n  //  this is read2\n  [0x80, 'Read2'],\n  //  not primary alignment\n  [0x100, 'Secondary'],\n  //  QC failure\n  [0x200, 'FailedQc'],\n  //  optical or PCR duplicate\n  [0x400, 'Duplicate'],\n  //  supplementary alignment\n  [0x800, 'Supplementary'],\n] as const\n\nexport const CramFlags = [\n  [0x1, 'PreservingQualityScores'],\n  [0x2, 'Detached'],\n  [0x4, 'WithMateDownstream'],\n  [0x8, 'DecodeSequenceAsStar'],\n] as const\n\nexport const MateFlags = [\n  [0x1, 'OnNegativeStrand'],\n  [0x2, 'Unmapped'],\n] as const\n\ntype FlagsDecoder<Type> = {\n  [Property in Type as `is${Capitalize<string & Property>}`]: (\n    flags: number,\n  ) => boolean\n}\n\ntype FlagsEncoder<Type> = {\n  [Property in Type as `set${Capitalize<string & Property>}`]: (\n    flags: number,\n  ) => number\n}\n\nfunction makeFlagsHelper<T>(\n  x: ReadonlyArray<readonly [number, T]>,\n): FlagsDecoder<T> & FlagsEncoder<T> {\n  const r: any = {}\n  for (const [code, name] of x) {\n    r['is' + name] = (flags: number) => !!(flags & code)\n    r['set' + name] = (flags: number) => flags | code\n  }\n\n  return r\n}\n\nexport const BamFlagsDecoder = makeFlagsHelper(BamFlags)\nexport const CramFlagsDecoder = makeFlagsHelper(CramFlags)\nexport const MateFlagsDecoder = makeFlagsHelper(MateFlags)\n\n/**\n * Class of each CRAM record returned by this API.\n */\nexport default class CramRecord {\n  public tags: Record<string, string>\n  public flags: number\n  public cramFlags: number\n  public readBases?: string | null\n  public _refRegion?: RefRegion\n  public readFeatures?: ReadFeature[]\n  public alignmentStart: number\n  public lengthOnRef: number | undefined\n  public readLength: number\n  public templateLength?: number\n  public templateSize?: number\n  public readName?: string\n  public mateRecordNumber?: number\n  public mate?: MateRecord\n  public uniqueId: number\n  public sequenceId: number\n  public readGroupId: number\n  public mappingQuality: number | undefined\n  public qualityScores: number[] | null | undefined\n\n  constructor({\n    flags,\n    cramFlags,\n    readLength,\n    mappingQuality,\n    lengthOnRef,\n    qualityScores,\n    mateRecordNumber,\n    readBases,\n    readFeatures,\n    mateToUse,\n    readGroupId,\n    readName,\n    sequenceId,\n    uniqueId,\n    templateSize,\n    alignmentStart,\n    tags,\n  }: ReturnType<typeof decodeRecord> & { uniqueId: number }) {\n    this.flags = flags\n    this.cramFlags = cramFlags\n    this.readLength = readLength\n    this.mappingQuality = mappingQuality\n    this.lengthOnRef = lengthOnRef\n    this.qualityScores = qualityScores\n    if (readBases) {\n      this.readBases = readBases\n    }\n\n    this.readGroupId = readGroupId\n    this.readName = readName\n    this.sequenceId = sequenceId\n    this.uniqueId = uniqueId\n    this.templateSize = templateSize\n    this.alignmentStart = alignmentStart\n    this.tags = tags\n\n    // backwards compatibility\n    if (readFeatures) {\n      this.readFeatures = readFeatures\n    }\n    if (mateToUse) {\n      this.mate = {\n        flags: mateToUse.mateFlags,\n        readName: mateToUse.mateReadName,\n        sequenceId: mateToUse.mateSequenceId,\n        alignmentStart: mateToUse.mateAlignmentStart,\n      }\n    }\n    if (mateRecordNumber) {\n      this.mateRecordNumber = mateRecordNumber\n    }\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  /**\n   * @returns {boolean} true if the read is detached\n   */\n  isDetached() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_DETACHED)\n  }\n\n  /** @returns {boolean} true if the read has a mate in this same CRAM segment */\n  hasMateDownStream() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_MATE_DOWNSTREAM)\n  }\n\n  /** @returns {boolean} true if the read contains qual scores */\n  isPreservingQualityScores() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_PRESERVE_QUAL_SCORES)\n  }\n\n  /** @returns {boolean} true if the read has no sequence bases */\n  isUnknownBases() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_NO_SEQ)\n  }\n\n  /**\n   * Get the original sequence of this read.\n   * @returns {String} sequence basepairs\n   */\n  getReadBases() {\n    if (!this.readBases && this._refRegion) {\n      const decoded = decodeReadSequence(this, this._refRegion)\n      if (decoded) {\n        this.readBases = decoded\n      }\n    }\n    return this.readBases\n  }\n\n  /**\n   * Get the pair orientation of a paired read. Adapted from igv.js\n   * @returns {String} of paired orientatin\n   */\n  getPairOrientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      this.isPaired() &&\n      !this.isMateUnmapped() &&\n      this.mate &&\n      this.sequenceId === this.mate.sequenceId\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      let isize = this.templateLength || this.templateSize\n      if (isize === undefined) {\n        throw new Error('One of templateSize and templateLength must be set')\n      }\n      if (this.alignmentStart > this.mate.alignmentStart && isize > 0) {\n        isize = -isize\n      }\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return null\n  }\n\n  /**\n   * Annotates this feature with the given reference sequence basepair\n   * information. This will add a `sub` and a `ref` item to base\n   * substitution read features given the actual substituted and reference\n   * base pairs, and will make the `getReadSequence()` method work.\n   *\n   * @param {object} refRegion\n   * @param {number} refRegion.start\n   * @param {number} refRegion.end\n   * @param {string} refRegion.seq\n   * @param {CramContainerCompressionScheme} compressionScheme\n   * @returns {undefined} nothing\n   */\n  addReferenceSequence(\n    refRegion: RefRegion,\n    compressionScheme: CramContainerCompressionScheme,\n  ) {\n    if (this.readFeatures) {\n      // use the reference bases to decode the bases\n      // substituted in each base substitution\n      this.readFeatures.forEach(readFeature => {\n        if (readFeature.code === 'X') {\n          decodeBaseSubstitution(\n            this,\n            refRegion,\n            compressionScheme,\n            readFeature,\n          )\n        }\n      })\n    }\n\n    // if this region completely covers this read,\n    // keep a reference to it\n    if (\n      !this.readBases &&\n      refRegion.start <= this.alignmentStart &&\n      refRegion.end >=\n        this.alignmentStart + (this.lengthOnRef || this.readLength) - 1\n    ) {\n      this._refRegion = refRegion\n    }\n  }\n\n  toJSON() {\n    const data: any = {}\n    Object.keys(this).forEach(k => {\n      if (k.charAt(0) === '_') {\n        return\n      }\n      data[k] = (this as any)[k]\n    })\n\n    data.readBases = this.getReadBases()\n\n    return data\n  }\n}\n","import Long from 'long'\nimport { CramMalformedError } from '../../errors'\nimport {\n  BamFlagsDecoder,\n  CramFlagsDecoder,\n  MateFlagsDecoder,\n  ReadFeature,\n} from '../record'\nimport CramSlice, { SliceHeader } from './index'\nimport { isMappedSliceHeader } from '../sectionParsers'\nimport CramContainerCompressionScheme, {\n  DataSeriesTypes,\n} from '../container/compressionScheme'\nimport { CramFileBlock } from '../file'\nimport { Cursors, DataTypeMapping } from '../codecs/_base'\nimport { DataSeriesEncodingKey } from '../codecs/dataSeriesTypes'\n\n/**\n * given a Buffer, read a string up to the first null character\n * @private\n */\nfunction readNullTerminatedString(buffer: Uint8Array) {\n  let r = ''\n  for (let i = 0; i < buffer.length && buffer[i] !== 0; i++) {\n    r += String.fromCharCode(buffer[i])\n  }\n  return r\n}\n\n/**\n * parse a BAM tag's array value from a binary buffer\n * @private\n */\nfunction parseTagValueArray(buffer: Buffer) {\n  const arrayType = String.fromCharCode(buffer[0])\n  const length = Int32Array.from(buffer.slice(1))[0]\n\n  const array: number[] = new Array(length)\n  buffer = buffer.slice(5)\n\n  if (arrayType === 'c') {\n    const arr = new Int8Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else if (arrayType === 'C') {\n    const arr = new Uint8Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else if (arrayType === 's') {\n    const arr = new Int16Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else if (arrayType === 'S') {\n    const arr = new Uint16Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else if (arrayType === 'i') {\n    const arr = new Int32Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else if (arrayType === 'I') {\n    const arr = new Uint32Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else if (arrayType === 'f') {\n    const arr = new Float32Array(buffer.buffer)\n    for (let i = 0; i < length; i += 1) {\n      array[i] = arr[i]\n    }\n  } else {\n    throw new Error('unknown type: ' + arrayType)\n  }\n\n  return array\n}\n\nfunction parseTagData(tagType: string, buffer: any) {\n  if (tagType === 'Z') {\n    return readNullTerminatedString(buffer)\n  }\n  if (tagType === 'A') {\n    return String.fromCharCode(buffer[0])\n  }\n  if (tagType === 'I') {\n    return Long.fromBytesLE(buffer).toNumber()\n  }\n  if (tagType === 'i') {\n    return new Int32Array(buffer.buffer)[0]\n  }\n  if (tagType === 's') {\n    return new Int16Array(buffer.buffer)[0]\n  }\n  if (tagType === 'S') {\n    return new Uint16Array(buffer.buffer)[0]\n  }\n  if (tagType === 'c') {\n    return new Int8Array(buffer.buffer)[0]\n  }\n  if (tagType === 'C') {\n    return buffer[0] as number\n  }\n  if (tagType === 'f') {\n    return new Float32Array(buffer.buffer)[0]\n  }\n  if (tagType === 'H') {\n    return Number.parseInt(\n      readNullTerminatedString(buffer).replace(/^0x/, ''),\n      16,\n    )\n  }\n  if (tagType === 'B') {\n    return parseTagValueArray(buffer)\n  }\n\n  throw new CramMalformedError(`Unrecognized tag type ${tagType}`)\n}\n\nfunction decodeReadFeatures(\n  alignmentStart: number,\n  readFeatureCount: number,\n  decodeDataSeries: any,\n  compressionScheme: CramContainerCompressionScheme,\n  majorVersion: number,\n) {\n  let currentReadPos = 0\n  let currentRefPos = alignmentStart - 1\n  const readFeatures: ReadFeature[] = new Array(readFeatureCount)\n\n  function decodeRFData([type, dataSeriesName]: readonly [\n    type: string,\n    dataSeriesName: string,\n  ]) {\n    const data = decodeDataSeries(dataSeriesName)\n    if (type === 'character') {\n      return String.fromCharCode(data)\n    }\n    if (type === 'string') {\n      let r = ''\n      for (let i = 0; i < data.byteLength; i++) {\n        r += String.fromCharCode(data[i])\n      }\n      return r\n    }\n    if (type === 'numArray') {\n      return data.toArray()\n    }\n    // else if (type === 'number') {\n    //   return data[0]\n    // }\n    return data\n  }\n\n  for (let i = 0; i < readFeatureCount; i += 1) {\n    const code = String.fromCharCode(decodeDataSeries('FC'))\n\n    const readPosDelta = decodeDataSeries('FP')\n\n    // map of operator name -> data series name\n    const data1Schema = {\n      B: ['character', 'BA'] as const,\n      S: ['string', majorVersion > 1 ? 'SC' : 'IN'] as const, // IN if cram v1, SC otherwise\n      X: ['number', 'BS'] as const,\n      D: ['number', 'DL'] as const,\n      I: ['string', 'IN'] as const,\n      i: ['character', 'BA'] as const,\n      b: ['string', 'BB'] as const,\n      q: ['numArray', 'QQ'] as const,\n      Q: ['number', 'QS'] as const,\n      H: ['number', 'HC'] as const,\n      P: ['number', 'PD'] as const,\n      N: ['number', 'RS'] as const,\n    }[code]\n\n    if (!data1Schema) {\n      throw new CramMalformedError(`invalid read feature code \"${code}\"`)\n    }\n\n    let data = decodeRFData(data1Schema)\n\n    // if this is a tag with two data items, make the data an array and add the second item\n    const data2Schema = { B: ['number', 'QS'] as const }[code]\n    if (data2Schema) {\n      data = [data, decodeRFData(data2Schema)]\n    }\n\n    currentReadPos += readPosDelta\n    const pos = currentReadPos\n\n    currentRefPos += readPosDelta\n    const refPos = currentRefPos\n\n    // for gapping features, adjust the reference position for read features that follow\n    if (code === 'D' || code === 'N') {\n      currentRefPos += data\n    } else if (code === 'I' || code === 'S') {\n      currentRefPos -= data.length\n    } else if (code === 'i') {\n      currentRefPos -= 1\n    }\n\n    readFeatures[i] = { code, pos, refPos, data }\n  }\n  return readFeatures\n}\n\nexport type DataSeriesDecoder = <T extends DataSeriesEncodingKey>(\n  dataSeriesName: T,\n) => DataTypeMapping[DataSeriesTypes[T]]\n\nexport default function decodeRecord(\n  slice: CramSlice,\n  decodeDataSeries: DataSeriesDecoder,\n  compressionScheme: CramContainerCompressionScheme,\n  sliceHeader: SliceHeader,\n  coreDataBlock: CramFileBlock,\n  blocksByContentId: Record<number, CramFileBlock>,\n  cursors: Cursors,\n  majorVersion: number,\n  recordNumber: number,\n) {\n  let flags = decodeDataSeries('BF') as number\n\n  // note: the C data type of compressionFlags is byte in cram v1\n  // and int32 in cram v2+, but that does not matter for us here\n  // in javascript land.\n  const cramFlags = decodeDataSeries('CF') as number\n\n  if (!isMappedSliceHeader(sliceHeader.parsedContent)) {\n    throw new Error()\n  }\n\n  let sequenceId\n  if (majorVersion > 1 && sliceHeader.parsedContent.refSeqId === -2) {\n    sequenceId = decodeDataSeries('RI')\n  } else {\n    sequenceId = sliceHeader.parsedContent.refSeqId\n  }\n\n  const readLength = decodeDataSeries('RL')\n  // if APDelta, will calculate the true start in a second pass\n  let alignmentStart = decodeDataSeries('AP')\n  if (compressionScheme.APdelta) {\n    alignmentStart = alignmentStart + cursors.lastAlignmentStart\n  }\n  cursors.lastAlignmentStart = alignmentStart\n  const readGroupId = decodeDataSeries('RG')\n\n  let readName\n  if (compressionScheme.readNamesIncluded) {\n    readName = readNullTerminatedString(decodeDataSeries('RN'))\n  }\n\n  let mateToUse\n  let templateSize\n  let mateRecordNumber\n  // mate record\n  if (CramFlagsDecoder.isDetached(cramFlags)) {\n    // note: the MF is a byte in 1.0, int32 in 2+, but once again this doesn't matter for javascript\n    // const mate: any = {}\n    const mateFlags = decodeDataSeries('MF') as number\n    let mateReadName\n    if (!compressionScheme.readNamesIncluded) {\n      mateReadName = readNullTerminatedString(decodeDataSeries('RN'))\n      readName = mateReadName\n    }\n    const mateSequenceId = decodeDataSeries('NS') as number\n    const mateAlignmentStart = decodeDataSeries('NP') as number\n    if (mateFlags || mateSequenceId > -1) {\n      mateToUse = {\n        mateFlags,\n        mateSequenceId,\n        mateAlignmentStart,\n        mateReadName,\n      }\n    }\n\n    templateSize = decodeDataSeries('TS')\n\n    // set mate unmapped if needed\n    if (MateFlagsDecoder.isUnmapped(mateFlags)) {\n      flags = BamFlagsDecoder.setMateUnmapped(flags)\n    }\n    // set mate reversed if needed\n    if (MateFlagsDecoder.isOnNegativeStrand(mateFlags)) {\n      flags = BamFlagsDecoder.setMateReverseComplemented(flags)\n    }\n\n    // detachedCount++\n  } else if (CramFlagsDecoder.isWithMateDownstream(cramFlags)) {\n    mateRecordNumber = (decodeDataSeries('NF') as number) + recordNumber + 1\n  }\n\n  // TODO: the aux tag parsing will have to be refactored if we want to support\n  // cram v1\n  const TLindex = decodeDataSeries('TL')\n  if (TLindex < 0) {\n    /* TODO: check nTL: TLindex >= compressionHeader.tagEncoding.size */\n    throw new CramMalformedError('invalid TL index')\n  }\n\n  const tags: Record<string, any> = {}\n  // TN = tag names\n  const TN = compressionScheme.getTagNames(TLindex)\n  const ntags = TN.length\n\n  for (let i = 0; i < ntags; i += 1) {\n    const tagId = TN[i]\n    const tagName = tagId.substr(0, 2)\n    const tagType = tagId.substr(2, 1)\n\n    const tagCodec = compressionScheme.getCodecForTag(tagId)\n    if (!tagCodec) {\n      throw new CramMalformedError(\n        `no codec defined for auxiliary tag ${tagId}`,\n      )\n    }\n    const tagData = tagCodec.decode(\n      slice,\n      coreDataBlock,\n      blocksByContentId,\n      cursors,\n    )\n    tags[tagName] = parseTagData(tagType, tagData)\n  }\n\n  let readFeatures\n  let lengthOnRef\n  let mappingQuality\n  let qualityScores: number[] | undefined | null\n  let readBases = undefined\n  if (!BamFlagsDecoder.isSegmentUnmapped(flags)) {\n    // reading read features\n    const readFeatureCount = decodeDataSeries('FN') as number\n    if (readFeatureCount) {\n      readFeatures = decodeReadFeatures(\n        alignmentStart,\n        readFeatureCount,\n        decodeDataSeries,\n        compressionScheme,\n        majorVersion,\n      )\n    }\n\n    // compute the read's true span on the reference sequence, and the end coordinate of the alignment on the reference\n    lengthOnRef = readLength\n    if (readFeatures) {\n      for (const { code, data } of readFeatures) {\n        if (code === 'D' || code === 'N') {\n          lengthOnRef += data\n        } else if (code === 'I' || code === 'S') {\n          lengthOnRef = lengthOnRef - data.length\n        } else if (code === 'i') {\n          lengthOnRef = lengthOnRef - 1\n        }\n      }\n    }\n    if (Number.isNaN(lengthOnRef)) {\n      console.warn(\n        `${\n          readName || `${sequenceId}:${alignmentStart}`\n        } record has invalid read features`,\n      )\n      lengthOnRef = readLength\n    }\n\n    // mapping quality\n    mappingQuality = decodeDataSeries('MQ') as number\n    if (CramFlagsDecoder.isPreservingQualityScores(cramFlags)) {\n      qualityScores = new Array(readLength)\n      for (let i = 0; i < qualityScores.length; i++) {\n        qualityScores[i] = decodeDataSeries('QS')\n      }\n    }\n  } else if (CramFlagsDecoder.isDecodeSequenceAsStar(cramFlags)) {\n    readBases = null\n    qualityScores = null\n  } else {\n    const bases = new Array(readLength) as number[]\n    for (let i = 0; i < bases.length; i += 1) {\n      bases[i] = decodeDataSeries('BA')\n    }\n    readBases = String.fromCharCode(...bases)\n\n    if (CramFlagsDecoder.isPreservingQualityScores(cramFlags)) {\n      qualityScores = new Array(readLength)\n      for (let i = 0; i < bases.length; i += 1) {\n        qualityScores[i] = decodeDataSeries('QS')\n      }\n    }\n  }\n\n  return {\n    readLength,\n    sequenceId,\n    cramFlags,\n    flags,\n    alignmentStart,\n    readGroupId,\n    readName,\n    mateToUse,\n    templateSize,\n    mateRecordNumber,\n    readFeatures,\n    lengthOnRef,\n    mappingQuality,\n    qualityScores,\n    readBases,\n    tags,\n  }\n}\n","import { CramArgumentError, CramMalformedError } from '../../errors'\nimport { parseItem, sequenceMD5, tinyMemoize } from '../util'\n\nimport Constants from '../constants'\nimport decodeRecord, { DataSeriesDecoder } from './decodeRecord'\nimport CramRecord from '../record'\nimport CramContainer from '../container'\nimport CramFile, { CramFileBlock } from '../file'\nimport {\n  isMappedSliceHeader,\n  MappedSliceHeader,\n  UnmappedSliceHeader,\n} from '../sectionParsers'\nimport { CramBufferOverrunError } from '../codecs/getBits'\nimport { Cursors, DataTypeMapping } from '../codecs/_base'\nimport { DataSeriesEncodingKey } from '../codecs/dataSeriesTypes'\nimport { DataSeriesTypes } from '../container/compressionScheme'\n\nexport type SliceHeader = CramFileBlock & {\n  parsedContent: MappedSliceHeader | UnmappedSliceHeader\n}\n\n/**\n * @private\n * Try to estimate the template length from a bunch of interrelated multi-segment reads.\n * @param {Array[CramRecord]} allRecords\n * @param {number} currentRecordNumber\n * @param {CramRecord} thisRecord\n */\nfunction calculateMultiSegmentMatedTemplateLength(\n  allRecords: CramRecord[],\n  currentRecordNumber: number,\n  thisRecord: CramRecord,\n) {\n  function getAllMatedRecords(startRecord: CramRecord) {\n    const records = [startRecord]\n    if (\n      startRecord.mateRecordNumber !== undefined &&\n      startRecord.mateRecordNumber >= 0\n    ) {\n      const mateRecord = allRecords[startRecord.mateRecordNumber]\n      if (!mateRecord) {\n        throw new CramMalformedError(\n          'intra-slice mate record not found, this file seems malformed',\n        )\n      }\n      records.push(...getAllMatedRecords(mateRecord))\n    }\n    return records\n  }\n\n  const matedRecords = getAllMatedRecords(thisRecord)\n  const starts = matedRecords.map(r => r.alignmentStart)\n  const ends = matedRecords.map(r => r.alignmentStart + r.readLength - 1)\n  const estimatedTemplateLength = Math.max(...ends) - Math.min(...starts) + 1\n  if (estimatedTemplateLength >= 0) {\n    matedRecords.forEach(r => {\n      if (r.templateLength !== undefined) {\n        throw new CramMalformedError(\n          'mate pair group has some members that have template lengths already, this file seems malformed',\n        )\n      }\n      r.templateLength = estimatedTemplateLength\n    })\n  }\n}\n\n/**\n * @private\n * Attempt to calculate the `templateLength` for a pair of intra-slice paired reads.\n * Ported from htslib. Algorithm is imperfect.\n * @param {CramRecord} thisRecord\n * @param {CramRecord} mateRecord\n */\nfunction calculateIntraSliceMatePairTemplateLength(\n  thisRecord: CramRecord,\n  mateRecord: CramRecord,\n) {\n  // this just estimates the template length by using the simple (non-gapped) end coordinate of each\n  // read, because gapping in the alignment doesn't mean the template is longer or shorter\n  const start = Math.min(thisRecord.alignmentStart, mateRecord.alignmentStart)\n  const end = Math.max(\n    thisRecord.alignmentStart + thisRecord.readLength - 1,\n    mateRecord.alignmentStart + mateRecord.readLength - 1,\n  )\n  const lengthEstimate = end - start + 1\n  thisRecord.templateLength = lengthEstimate\n  mateRecord.templateLength = lengthEstimate\n}\n\n/**\n * @private establishes a mate-pair relationship between two records in the same slice.\n * CRAM compresses mate-pair relationships between records in the same slice down into\n * just one record having the index in the slice of its mate\n */\nfunction associateIntraSliceMate(\n  allRecords: CramRecord[],\n  currentRecordNumber: number,\n  thisRecord: CramRecord,\n  mateRecord: CramRecord,\n) {\n  if (!mateRecord) {\n    throw new CramMalformedError(\n      'could not resolve intra-slice mate pairs, file seems truncated or malformed',\n    )\n  }\n\n  const complicatedMultiSegment = !!(\n    mateRecord.mate ||\n    (mateRecord.mateRecordNumber !== undefined &&\n      mateRecord.mateRecordNumber !== currentRecordNumber)\n  )\n\n  // Deal with lossy read names\n  if (!thisRecord.readName) {\n    thisRecord.readName = String(thisRecord.uniqueId)\n    mateRecord.readName = thisRecord.readName\n  }\n\n  thisRecord.mate = {\n    sequenceId: mateRecord.sequenceId,\n    alignmentStart: mateRecord.alignmentStart,\n    uniqueId: mateRecord.uniqueId,\n  }\n  if (mateRecord.readName) {\n    thisRecord.mate.readName = mateRecord.readName\n  }\n\n  // the mate record might have its own mate pointer, if this is some kind of\n  // multi-segment (more than paired) scheme, so only relate that one back to this one\n  // if it does not have any other relationship\n  if (!mateRecord.mate && mateRecord.mateRecordNumber === undefined) {\n    mateRecord.mate = {\n      sequenceId: thisRecord.sequenceId,\n      alignmentStart: thisRecord.alignmentStart,\n      uniqueId: thisRecord.uniqueId,\n    }\n    if (thisRecord.readName) {\n      mateRecord.mate.readName = thisRecord.readName\n    }\n  }\n\n  // make sure the proper flags and cramFlags are set on both records\n  // paired\n  thisRecord.flags |= Constants.BAM_FPAIRED\n\n  // set mate unmapped if needed\n  if (mateRecord.flags & Constants.BAM_FUNMAP) {\n    thisRecord.flags |= Constants.BAM_FMUNMAP\n    // thisRecord.templateLength = 0\n  }\n  if (thisRecord.flags & Constants.BAM_FUNMAP) {\n    // thisRecord.templateLength = 0\n    mateRecord.flags |= Constants.BAM_FMUNMAP\n  }\n\n  // set mate reversed if needed\n  if (mateRecord.flags & Constants.BAM_FREVERSE) {\n    thisRecord.flags |= Constants.BAM_FMREVERSE\n  }\n  if (thisRecord.flags & Constants.BAM_FREVERSE) {\n    mateRecord.flags |= Constants.BAM_FMREVERSE\n  }\n\n  if (thisRecord.templateLength === undefined) {\n    if (complicatedMultiSegment) {\n      calculateMultiSegmentMatedTemplateLength(\n        allRecords,\n        currentRecordNumber,\n        thisRecord,\n      )\n    } else {\n      calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord)\n    }\n  }\n\n  // delete this last because it's used by the\n  // complicated template length estimation\n  delete thisRecord.mateRecordNumber\n}\n\nexport default class CramSlice {\n  private file: CramFile\n\n  constructor(\n    public container: CramContainer,\n    public containerPosition: number,\n    _unused: number,\n  ) {\n    this.file = container.file\n  }\n\n  // memoize\n  async getHeader(): Promise<SliceHeader> {\n    // fetch and parse the slice header\n    const sectionParsers = await this.file.getSectionParsers()\n    const containerHeader = await this.container.getHeader()\n    const header = await this.file.readBlock(\n      containerHeader._endPosition + this.containerPosition,\n    )\n    if (header === undefined) {\n      throw new Error()\n    }\n    if (header.contentType === 'MAPPED_SLICE_HEADER') {\n      const content = parseItem(\n        header.content,\n        sectionParsers.cramMappedSliceHeader.parser,\n        0,\n        containerHeader._endPosition,\n      )\n      return { ...header, parsedContent: content }\n    } else if (header.contentType === 'UNMAPPED_SLICE_HEADER') {\n      const content = parseItem(\n        header.content,\n        sectionParsers.cramUnmappedSliceHeader.parser,\n        0,\n        containerHeader._endPosition,\n      )\n      return { ...header, parsedContent: content }\n    } else {\n      throw new CramMalformedError(\n        `error reading slice header block, invalid content type ${header.contentType}`,\n      )\n    }\n  }\n\n  // memoize\n  async getBlocks() {\n    const header = await this.getHeader()\n    // read all the blocks into memory and store them\n    let blockPosition = header._endPosition\n    const blocks: CramFileBlock[] = new Array(header.parsedContent.numBlocks)\n    for (let i = 0; i < blocks.length; i += 1) {\n      const block = await this.file.readBlock(blockPosition)\n      if (block === undefined) {\n        throw new Error()\n      }\n      blocks[i] = block\n      blockPosition = blocks[i]._endPosition\n    }\n\n    return blocks\n  }\n\n  // no memoize\n  async getCoreDataBlock() {\n    const blocks = await this.getBlocks()\n    // the core data block is always the first block in the slice\n    return blocks[0]\n  }\n\n  // memoize\n  async _getBlocksContentIdIndex(): Promise<Record<number, CramFileBlock>> {\n    const blocks = await this.getBlocks()\n    const blocksByContentId: Record<number, CramFileBlock> = {}\n    blocks.forEach(block => {\n      if (block.contentType === 'EXTERNAL_DATA') {\n        blocksByContentId[block.contentId] = block\n      }\n    })\n    return blocksByContentId\n  }\n\n  async getBlockByContentId(id: number) {\n    const blocksByContentId = await this._getBlocksContentIdIndex()\n    return blocksByContentId[id]\n  }\n\n  async getReferenceRegion() {\n    // read the slice header\n    const sliceHeader = (await this.getHeader()).parsedContent\n    if (!isMappedSliceHeader(sliceHeader)) {\n      throw new Error()\n    }\n\n    if (sliceHeader.refSeqId < 0) {\n      return undefined\n    }\n\n    const compressionScheme = await this.container.getCompressionScheme()\n    if (compressionScheme === undefined) {\n      throw new Error()\n    }\n\n    // console.log(JSON.stringify(sliceHeader, null, '  '))\n\n    if (sliceHeader.refBaseBlockId >= 0) {\n      const refBlock = await this.getBlockByContentId(\n        sliceHeader.refBaseBlockId,\n      )\n      if (!refBlock) {\n        throw new CramMalformedError(\n          'embedded reference specified, but reference block does not exist',\n        )\n      }\n\n      // TODO: we do not read anything named 'span'\n      // if (sliceHeader.span > refBlock.uncompressedSize) {\n      //   throw new CramMalformedError('Embedded reference is too small')\n      // }\n\n      // TODO verify\n      return {\n        seq: (refBlock as any).data.toString('utf8'),\n        start: sliceHeader.refSeqStart,\n        end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,\n        span: sliceHeader.refSeqSpan,\n      }\n    }\n    if (\n      compressionScheme.referenceRequired ||\n      this.file.fetchReferenceSequenceCallback\n    ) {\n      if (!this.file.fetchReferenceSequenceCallback) {\n        throw new Error(\n          'reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence',\n        )\n      }\n\n      const seq = await this.file.fetchReferenceSequenceCallback(\n        sliceHeader.refSeqId,\n        sliceHeader.refSeqStart,\n        sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,\n      )\n\n      if (seq.length !== sliceHeader.refSeqSpan) {\n        throw new CramArgumentError(\n          'seqFetch callback returned a reference sequence of the wrong length',\n        )\n      }\n\n      return {\n        seq,\n        start: sliceHeader.refSeqStart,\n        end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,\n        span: sliceHeader.refSeqSpan,\n      }\n    }\n\n    return undefined\n  }\n\n  getAllRecords() {\n    return this.getRecords(() => true)\n  }\n\n  async _fetchRecords() {\n    const { majorVersion } = await this.file.getDefinition()\n\n    const compressionScheme = await this.container.getCompressionScheme()\n    if (compressionScheme === undefined) {\n      throw new Error()\n    }\n\n    const sliceHeader = await this.getHeader()\n    if (sliceHeader === undefined) {\n      throw new Error()\n    }\n\n    const blocksByContentId = await this._getBlocksContentIdIndex()\n\n    // check MD5 of reference if available\n    if (\n      majorVersion > 1 &&\n      this.file.options.checkSequenceMD5 &&\n      isMappedSliceHeader(sliceHeader.parsedContent) &&\n      sliceHeader.parsedContent.refSeqId >= 0 &&\n      sliceHeader.parsedContent.md5.join('') !== '0000000000000000'\n    ) {\n      const refRegion = await this.getReferenceRegion()\n      if (refRegion) {\n        const { seq, start, end } = refRegion\n        const seqMd5 = sequenceMD5(seq)\n        const storedMd5 = sliceHeader.parsedContent.md5\n          .map(byte => (byte < 16 ? '0' : '') + byte.toString(16))\n          .join('')\n        if (seqMd5 !== storedMd5) {\n          throw new CramMalformedError(\n            `MD5 checksum reference mismatch for ref ${sliceHeader.parsedContent.refSeqId} pos ${start}..${end}. recorded MD5: ${storedMd5}, calculated MD5: ${seqMd5}`,\n          )\n        }\n      }\n    }\n\n    // tracks the read position within the block. codec.decode() methods\n    // advance the byte and bit positions in the cursor as they decode\n    // data note that we are only decoding a single block here, the core\n    // data block\n    const coreDataBlock = await this.getCoreDataBlock()\n    const cursors: Cursors = {\n      lastAlignmentStart: isMappedSliceHeader(sliceHeader.parsedContent)\n        ? sliceHeader.parsedContent.refSeqStart\n        : 0,\n      coreBlock: { bitPosition: 7, bytePosition: 0 },\n      externalBlocks: {\n        map: new Map(),\n        getCursor(contentId: number) {\n          let r = this.map.get(contentId)\n          if (r === undefined) {\n            r = { bitPosition: 7, bytePosition: 0 }\n            this.map.set(contentId, r)\n          }\n          return r\n        },\n      },\n    }\n\n    const decodeDataSeries: DataSeriesDecoder = <\n      T extends DataSeriesEncodingKey,\n    >(\n      dataSeriesName: T,\n    ): DataTypeMapping[DataSeriesTypes[T]] => {\n      const codec = compressionScheme.getCodecForDataSeries(dataSeriesName)\n      if (!codec) {\n        throw new CramMalformedError(\n          `no codec defined for ${dataSeriesName} data series`,\n        )\n      }\n      // console.log(dataSeriesName, Object.getPrototypeOf(codec))\n      const decoded = codec.decode(\n        this,\n        coreDataBlock,\n        blocksByContentId,\n        cursors,\n      )\n      return decoded\n    }\n    let records: CramRecord[] = new Array(sliceHeader.parsedContent.numRecords)\n    for (let i = 0; i < records.length; i += 1) {\n      try {\n        const init = decodeRecord(\n          this,\n          decodeDataSeries,\n          compressionScheme,\n          sliceHeader,\n          coreDataBlock,\n          blocksByContentId,\n          cursors,\n          majorVersion,\n          i,\n        )\n        records[i] = new CramRecord({\n          ...init,\n          uniqueId:\n            sliceHeader.contentPosition +\n            sliceHeader.parsedContent.recordCounter +\n            i +\n            1,\n        })\n      } catch (e) {\n        if (e instanceof CramBufferOverrunError) {\n          console.warn(\n            'read attempted beyond end of buffer, file seems truncated.',\n          )\n          records = records.filter(r => !!r)\n          break\n        } else {\n          throw e\n        }\n      }\n    }\n\n    // interpret `recordsToNextFragment` attributes to make standard `mate`\n    // objects Resolve mate pair cross-references between records in this slice\n    for (let i = 0; i < records.length; i += 1) {\n      const { mateRecordNumber } = records[i]\n      if (mateRecordNumber !== undefined && mateRecordNumber >= 0) {\n        associateIntraSliceMate(\n          records,\n          i,\n          records[i],\n          records[mateRecordNumber],\n        )\n      }\n    }\n\n    return records\n  }\n\n  async getRecords(filterFunction: (r: CramRecord) => boolean) {\n    // fetch the features if necessary, using the file-level feature cache\n    const cacheKey = this.container.filePosition + this.containerPosition\n    let recordsPromise = this.file.featureCache.get(cacheKey.toString())\n    if (!recordsPromise) {\n      recordsPromise = this._fetchRecords()\n      this.file.featureCache.set(cacheKey.toString(), recordsPromise)\n    }\n\n    const unfiltered = await recordsPromise\n    const records = unfiltered.filter(filterFunction)\n\n    // if we can fetch reference sequence, add the reference sequence to the records\n    if (records.length && this.file.fetchReferenceSequenceCallback) {\n      const sliceHeader = await this.getHeader()\n      if (\n        isMappedSliceHeader(sliceHeader.parsedContent) &&\n        (sliceHeader.parsedContent.refSeqId >= 0 || // single-ref slice\n          sliceHeader.parsedContent.refSeqId === -2) // multi-ref slice\n      ) {\n        const singleRefId =\n          sliceHeader.parsedContent.refSeqId >= 0\n            ? sliceHeader.parsedContent.refSeqId\n            : undefined\n        const compressionScheme = await this.container.getCompressionScheme()\n        if (compressionScheme === undefined) {\n          throw new Error()\n        }\n        const refRegions: Record<\n          string,\n          { id: number; start: number; end: number; seq: string | null }\n        > = {} // seqId => { start, end, seq }\n\n        // iterate over the records to find the spans of the reference sequences we need to fetch\n        for (let i = 0; i < records.length; i += 1) {\n          const seqId =\n            singleRefId !== undefined ? singleRefId : records[i].sequenceId\n          let refRegion = refRegions[seqId]\n          if (!refRegion) {\n            refRegion = {\n              id: seqId,\n              start: records[i].alignmentStart,\n              end: -Infinity,\n              seq: null,\n            }\n            refRegions[seqId] = refRegion\n          }\n\n          const end =\n            records[i].alignmentStart +\n            (records[i].lengthOnRef || records[i].readLength) -\n            1\n          if (end > refRegion.end) {\n            refRegion.end = end\n          }\n          if (records[i].alignmentStart < refRegion.start) {\n            refRegion.start = records[i].alignmentStart\n          }\n        }\n\n        // fetch the `seq` for all of the ref regions\n        await Promise.all(\n          Object.values(refRegions).map(async refRegion => {\n            if (refRegion.id !== -1 && refRegion.start <= refRegion.end) {\n              refRegion.seq = await this.file.fetchReferenceSequenceCallback(\n                refRegion.id,\n                refRegion.start,\n                refRegion.end,\n              )\n            }\n          }),\n        )\n\n        // now decorate all the records with them\n        for (let i = 0; i < records.length; i += 1) {\n          const seqId =\n            singleRefId !== undefined ? singleRefId : records[i].sequenceId\n          const refRegion = refRegions[seqId]\n          if (refRegion && refRegion.seq) {\n            const seq = refRegion.seq\n            records[i].addReferenceSequence(\n              { ...refRegion, seq },\n              compressionScheme,\n            )\n          }\n        }\n      }\n    }\n\n    return records\n  }\n}\n\n// memoize several methods in the class for performance\n'getHeader getBlocks _getBlocksContentIdIndex'\n  .split(' ')\n  .forEach(method => tinyMemoize(CramSlice, method))\n","import CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\nimport { DataType } from './dataSeriesTypes'\n\nexport type DataTypeMapping = {\n  byte: number\n  int: number\n  long: number\n  byteArray: Uint8Array\n}\n\nexport type Cursor = {\n  bitPosition: 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7\n  bytePosition: number\n}\n\nexport type Cursors = {\n  lastAlignmentStart: number\n  coreBlock: Cursor\n  externalBlocks: {\n    map: Map<any, any>\n    getCursor: (contentId: number) => Cursor\n  }\n}\n\n// codec base class\nexport default abstract class CramCodec<\n  TResult extends DataType = DataType,\n  TParameters = unknown,\n> {\n  public parameters: TParameters\n  public dataType: DataType\n\n  constructor(parameters: TParameters, dataType: TResult) {\n    this.parameters = parameters\n    this.dataType = dataType\n  }\n\n  abstract decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ): DataTypeMapping[TResult]\n}\n","import { tinyMemoize } from '../util'\n\nimport CramCodec, { Cursors } from './_base'\nimport { ByteArrayLengthEncoding, CramEncoding } from '../encoding'\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\nimport { DataType } from './dataSeriesTypes'\n\ntype CramCodecFactory = <TData extends DataType = DataType>(\n  encodingData: CramEncoding,\n  dataType: TData | 'ignore',\n) => CramCodec<TData>\n\nexport default class ByteArrayStopCodec extends CramCodec<\n  'byteArray',\n  ByteArrayLengthEncoding['parameters']\n> {\n  private instantiateCodec: CramCodecFactory\n\n  constructor(\n    parameters: ByteArrayLengthEncoding['parameters'],\n    dataType: 'byteArray',\n    instantiateCodec: CramCodecFactory,\n  ) {\n    super(parameters, dataType)\n    this.instantiateCodec = instantiateCodec\n    if (dataType !== 'byteArray') {\n      throw new TypeError(\n        `byteArrayLength does not support data type ${dataType}`,\n      )\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    const lengthCodec = this._getLengthCodec()\n    const arrayLength = lengthCodec.decode(\n      slice,\n      coreDataBlock,\n      blocksByContentId,\n      cursors,\n    )\n\n    const dataCodec = this._getDataCodec()\n    const data = new Uint8Array(arrayLength)\n    for (let i = 0; i < arrayLength; i += 1) {\n      data[i] = dataCodec.decode(\n        slice,\n        coreDataBlock,\n        blocksByContentId,\n        cursors,\n      )\n    }\n\n    return data\n  }\n\n  // memoize\n  _getLengthCodec() {\n    const encodingParams = this.parameters.lengthsEncoding\n    return this.instantiateCodec(encodingParams, 'int')\n  }\n\n  // memoize\n  _getDataCodec() {\n    const encodingParams = this.parameters.valuesEncoding\n    return this.instantiateCodec(encodingParams, 'byte')\n  }\n}\n\n'_getLengthCodec _getDataCodec'\n  .split(' ')\n  .forEach(method => tinyMemoize(ByteArrayStopCodec, method))\n","import { CramUnimplementedError } from '../../errors'\n\nimport HuffmanIntCodec from './huffman'\nimport ExternalCodec from './external'\nimport ByteArrayStopCodec from './byteArrayStop'\nimport ByteArrayLengthCodec from './byteArrayLength'\nimport BetaCodec from './beta'\nimport GammaCodec from './gamma'\nimport SubexpCodec from './subexp'\nimport CramCodec from './_base'\nimport { CramEncoding } from '../encoding'\nimport { DataType } from './dataSeriesTypes'\n\nconst codecClasses = {\n  1: ExternalCodec,\n  // 2: GolombCodec,\n  3: HuffmanIntCodec,\n  4: ByteArrayLengthCodec,\n  5: ByteArrayStopCodec,\n  6: BetaCodec,\n  7: SubexpCodec,\n  // 8: GolombRiceCodec,\n  9: GammaCodec,\n}\n\nfunction getCodecClassWithId(id: number) {\n  return (codecClasses as any)[id]\n}\n\nexport function instantiateCodec<TResult extends DataType = DataType>(\n  encodingData: CramEncoding,\n  dataType: DataType | 'ignore',\n): CramCodec<TResult> {\n  const CodecClass = getCodecClassWithId(\n    dataType === 'ignore' ? 0 : encodingData.codecId,\n  )\n  if (!CodecClass) {\n    throw new CramUnimplementedError(\n      `no codec implemented for codec ID ${encodingData.codecId}`,\n    )\n  }\n\n  return new CodecClass(encodingData.parameters, dataType, instantiateCodec)\n}\n","import { CramMalformedError, CramUnimplementedError } from '../../errors'\nimport CramCodec, { Cursor, Cursors } from './_base'\nimport { parseItf8 } from '../util'\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\nimport { CramBufferOverrunError } from './getBits'\nimport { ExternalCramEncoding } from '../encoding'\n\nexport default class ExternalCodec extends CramCodec<\n  'int' | 'byte',\n  ExternalCramEncoding['parameters']\n> {\n  private readonly _decodeData: (\n    contentBlock: CramFileBlock,\n    cursor: Cursor,\n  ) => number\n\n  constructor(\n    parameters: ExternalCramEncoding['parameters'],\n    dataType: 'int' | 'byte',\n  ) {\n    super(parameters, dataType)\n    if (this.dataType === 'int') {\n      this._decodeData = this._decodeInt\n    } else if (this.dataType === 'byte') {\n      this._decodeData = this._decodeByte\n    } else {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by EXTERNAL codec`,\n      )\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    const { blockContentId } = this.parameters\n    const contentBlock = blocksByContentId[blockContentId]\n    if (!contentBlock) {\n      throw new CramMalformedError(\n        `no block found with content ID ${blockContentId}`,\n      )\n    }\n    const cursor = cursors.externalBlocks.getCursor(blockContentId)\n    return this._decodeData(contentBlock, cursor)\n  }\n\n  _decodeInt(contentBlock: CramFileBlock, cursor: Cursor) {\n    const [result, bytesRead] = parseItf8(\n      contentBlock.content,\n      cursor.bytePosition,\n    )\n    cursor.bytePosition = cursor.bytePosition + bytesRead\n    return result\n  }\n\n  _decodeByte(contentBlock: CramFileBlock, cursor: Cursor) {\n    if (cursor.bytePosition >= contentBlock.content.length) {\n      throw new CramBufferOverrunError(\n        'attempted to read beyond end of block. this file seems truncated.',\n      )\n    }\n    return contentBlock.content[cursor.bytePosition++]\n  }\n}\n","import { CramMalformedError } from '../../errors'\nimport CramCodec, { Cursor, Cursors } from './_base'\nimport { getBits } from './getBits'\nimport { HuffmanEncoding } from '../encoding'\n\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\n\nfunction numberOfSetBits(ii: number) {\n  let i = (ii - (ii >> 1)) & 0x55555555\n  i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n  return (((i + (i >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24\n}\n\ntype Code = { bitLength: number; value: number; bitCode: number }\n\nexport default class HuffmanIntCodec extends CramCodec<\n  'byte' | 'int',\n  HuffmanEncoding['parameters']\n> {\n  private codes: Record<number, Code> = {}\n  private codeBook: Record<number, number[]> = {}\n  private sortedByValue: Code[] = []\n  private sortedCodes: Code[] = []\n  private sortedValuesByBitCode: number[] = []\n  private sortedBitCodes: number[] = []\n  private sortedBitLengthsByBitCode: number[] = []\n  private bitCodeToValue: number[] = []\n\n  constructor(\n    parameters: HuffmanEncoding['parameters'],\n    dataType: 'byte' | 'int',\n  ) {\n    super(parameters, dataType)\n    if (!['byte', 'int'].includes(this.dataType)) {\n      throw new TypeError(\n        `${this.dataType} decoding not yet implemented by HUFFMAN_INT codec`,\n      )\n    }\n\n    this.buildCodeBook()\n    this.buildCodes()\n    this.buildCaches()\n\n    // if this is a degenerate zero-length huffman code, special-case the decoding\n    if (this.sortedCodes[0].bitLength === 0) {\n      this._decode = this._decodeZeroLengthCode\n    }\n  }\n\n  buildCodeBook() {\n    // parse the parameters together into a `codes` data structure\n    let codes: Array<{ symbol: number; bitLength: number }> = new Array(\n      this.parameters.numCodes,\n    )\n    for (let i = 0; i < this.parameters.numCodes; i += 1) {\n      codes[i] = {\n        symbol: this.parameters.symbols[i],\n        bitLength: this.parameters.bitLengths[i],\n      }\n    }\n    // sort the codes by bit length and symbol value\n    codes = codes.sort(\n      (a, b) => a.bitLength - b.bitLength || a.symbol - b.symbol,\n    )\n\n    this.codeBook = {}\n    codes.forEach(code => {\n      if (!this.codeBook[code.bitLength]) {\n        this.codeBook[code.bitLength] = []\n      }\n      this.codeBook[code.bitLength].push(code.symbol)\n    })\n  }\n\n  buildCodes() {\n    this.codes = {} /*  new TreeMap<Integer, HuffmanBitCode>(); */\n    let codeLength = 0\n    let codeValue = -1\n    Object.entries(this.codeBook).forEach(([bitLength, symbols]) => {\n      const bitLengthInt = parseInt(bitLength, 10)\n      symbols.forEach(symbol => {\n        const code = {\n          bitLength: bitLengthInt,\n          value: symbol,\n          bitCode: 0,\n        }\n        codeValue = codeValue + 1\n        const delta = bitLengthInt - codeLength // new length?\n        codeValue = codeValue << delta // pad with 0's\n        code.bitCode = codeValue // calculated: huffman code\n        codeLength = codeLength + delta // adjust current code length\n\n        if (numberOfSetBits(codeValue) > bitLengthInt) {\n          throw new CramMalformedError('Symbol out of range')\n        }\n\n        this.codes[symbol] = code\n      })\n    })\n  }\n\n  buildCaches() {\n    this.sortedCodes = Object.values(this.codes).sort(\n      (a, b) => a.bitLength - b.bitLength || a.bitCode - b.bitCode,\n    )\n\n    // this.sortedValues = this.parameters.values.sort((a,b) => a-b)\n    this.sortedByValue = Object.values(this.codes).sort(\n      (a, b) => a.value - b.value,\n    )\n\n    this.sortedValuesByBitCode = this.sortedCodes.map(c => c.value)\n    this.sortedBitCodes = this.sortedCodes.map(c => c.bitCode)\n    this.sortedBitLengthsByBitCode = this.sortedCodes.map(c => c.bitLength)\n    const maxBitCode = Math.max(...this.sortedBitCodes)\n\n    this.bitCodeToValue = new Array(maxBitCode + 1).fill(-1)\n    for (let i = 0; i < this.sortedBitCodes.length; i += 1) {\n      this.bitCodeToValue[this.sortedCodes[i].bitCode] = i\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    return this._decode(slice, coreDataBlock, cursors.coreBlock)\n  }\n\n  // _decodeNull() {\n  //   return -1\n  // }\n\n  // the special case for zero-length codes\n  _decodeZeroLengthCode() {\n    return this.sortedCodes[0].value\n  }\n\n  _decode(slice: CramSlice, coreDataBlock: CramFileBlock, coreCursor: Cursor) {\n    const input = coreDataBlock.content\n\n    let prevLen = 0\n    let bits = 0\n    for (let i = 0; i < this.sortedCodes.length; i += 1) {\n      const length = this.sortedCodes[i].bitLength\n      bits <<= length - prevLen\n      bits |= getBits(input, coreCursor, length - prevLen)\n      prevLen = length\n      {\n        const index = this.bitCodeToValue[bits]\n        if (index > -1 && this.sortedBitLengthsByBitCode[index] === length) {\n          return this.sortedValuesByBitCode[index]\n        }\n\n        for (\n          let j = i;\n          this.sortedCodes[j + 1].bitLength === length &&\n          j < this.sortedCodes.length;\n          j += 1\n        ) {\n          i += 1\n        }\n      }\n    }\n    throw new CramMalformedError('Huffman symbol not found.')\n  }\n}\n","import { CramMalformedError } from '../../errors'\n\nimport CramCodec, { Cursor, Cursors } from './_base'\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\nimport { ByteArrayStopCramEncoding } from '../encoding'\nimport { CramBufferOverrunError } from './getBits'\n\nexport default class ByteArrayStopCodec extends CramCodec<\n  'byteArray',\n  ByteArrayStopCramEncoding['parameters']\n> {\n  constructor(\n    parameters: ByteArrayStopCramEncoding['parameters'],\n    dataType: 'byteArray',\n  ) {\n    super(parameters, dataType)\n    if (dataType !== 'byteArray') {\n      throw new TypeError(\n        `byteArrayStop codec does not support data type ${dataType}`,\n      )\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    const { blockContentId } = this.parameters\n    const contentBlock = blocksByContentId[blockContentId]\n    if (!contentBlock) {\n      throw new CramMalformedError(\n        `no block found with content ID ${blockContentId}`,\n      )\n    }\n    const cursor = cursors.externalBlocks.getCursor(blockContentId)\n    return this._decodeByteArray(contentBlock, cursor)\n  }\n\n  _decodeByteArray(contentBlock: CramFileBlock, cursor: Cursor) {\n    const dataBuffer = contentBlock.content\n    const { stopByte } = this.parameters\n    // scan to the next stop byte\n    const startPosition = cursor.bytePosition\n    let stopPosition = cursor.bytePosition\n    while (\n      dataBuffer[stopPosition] !== stopByte &&\n      stopPosition < dataBuffer.length\n    ) {\n      if (stopPosition === dataBuffer.length) {\n        throw new CramBufferOverrunError(\n          `byteArrayStop reading beyond length of data buffer?`,\n        )\n      }\n      stopPosition = stopPosition + 1\n    }\n    cursor.bytePosition = stopPosition + 1\n    return dataBuffer.subarray(startPosition, stopPosition)\n  }\n}\n","import { CramUnimplementedError } from '../../errors'\nimport CramCodec, { Cursors } from './_base'\nimport { getBits } from './getBits'\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\nimport { BetaEncoding } from '../encoding'\n\nexport default class BetaCodec extends CramCodec<\n  'int',\n  BetaEncoding['parameters']\n> {\n  constructor(parameters: BetaEncoding['parameters'], dataType: 'int') {\n    super(parameters, dataType)\n    if (this.dataType !== 'int') {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by BETA codec`,\n      )\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    const fromBits = getBits(\n      coreDataBlock.content,\n      cursors.coreBlock,\n      this.parameters.length,\n    )\n    return fromBits - this.parameters.offset\n  }\n}\n","import { CramUnimplementedError } from '../../errors'\nimport CramCodec, { Cursors } from './_base'\nimport { getBits } from './getBits'\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\nimport { SubexpEncoding } from '../encoding'\n\nexport default class SubexpCodec extends CramCodec<\n  'int',\n  SubexpEncoding['parameters']\n> {\n  constructor(parameters: SubexpEncoding['parameters'], dataType: 'int') {\n    super(parameters, dataType)\n    if (this.dataType !== 'int') {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by SUBEXP codec`,\n      )\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    let numLeadingOnes = 0\n    while (getBits(coreDataBlock.content, cursors.coreBlock, 1)) {\n      numLeadingOnes = numLeadingOnes + 1\n    }\n\n    let b\n    let n\n    if (numLeadingOnes === 0) {\n      b = this.parameters.K\n      n = getBits(coreDataBlock.content, cursors.coreBlock, b)\n    } else {\n      b = numLeadingOnes + this.parameters.K - 1\n      const bits = getBits(coreDataBlock.content, cursors.coreBlock, b)\n      n = (1 << b) | bits\n    }\n\n    return n - this.parameters.offset\n  }\n}\n","import { CramUnimplementedError } from '../../errors'\nimport CramCodec, { Cursors } from './_base'\nimport { getBits } from './getBits'\nimport { GammaEncoding } from '../encoding'\nimport CramSlice from '../slice'\nimport { CramFileBlock } from '../file'\n\nexport default class GammaCodec extends CramCodec<\n  'int',\n  GammaEncoding['parameters']\n> {\n  constructor(parameters: GammaEncoding['parameters'], dataType: 'int') {\n    super(parameters, dataType)\n    if (this.dataType !== 'int') {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by GAMMA codec`,\n      )\n    }\n  }\n\n  decode(\n    slice: CramSlice,\n    coreDataBlock: CramFileBlock,\n    blocksByContentId: Record<number, CramFileBlock>,\n    cursors: Cursors,\n  ) {\n    let length = 1\n\n    while (getBits(coreDataBlock.content, cursors.coreBlock, 1) === 0) {\n      length = length + 1\n    }\n\n    const readBits = getBits(\n      coreDataBlock.content,\n      cursors.coreBlock,\n      length - 1,\n    )\n\n    const value = readBits | (1 << (length - 1))\n    return value - this.parameters.offset\n  }\n}\n","import { instantiateCodec } from '../codecs'\nimport CramCodec from '../codecs/_base'\nimport { CramCompressionHeader, CramPreservationMap } from '../sectionParsers'\nimport { CramEncoding } from '../encoding'\nimport { CramMalformedError } from '../../errors'\nimport {\n  DataSeriesEncodingKey,\n  DataSeriesEncodingMap,\n} from '../codecs/dataSeriesTypes'\n\n// the hardcoded data type to be decoded for each core\n// data field\nconst dataSeriesTypes = {\n  BF: 'int',\n  CF: 'int',\n  RI: 'int',\n  RL: 'int',\n  AP: 'int',\n  RG: 'int',\n  MF: 'int',\n  NS: 'int',\n  NP: 'int',\n  TS: 'int',\n  NF: 'int',\n  TC: 'byte',\n  TN: 'int',\n  FN: 'int',\n  FC: 'byte',\n  FP: 'int',\n  BS: 'byte',\n  IN: 'byteArray',\n  SC: 'byteArray',\n  DL: 'int',\n  BA: 'byte',\n  BB: 'byteArray',\n  RS: 'int',\n  PD: 'int',\n  HC: 'int',\n  MQ: 'int',\n  RN: 'byteArray',\n  QS: 'byte',\n  QQ: 'byteArray',\n  TL: 'int',\n  // TM: 'ignore',\n  // TV: 'ignore',\n} as const\n\nexport type DataSeriesTypes = typeof dataSeriesTypes\n\nfunction parseSubstitutionMatrix(byteArray: number[]) {\n  const matrix: string[][] = new Array(5)\n  for (let i = 0; i < 5; i += 1) {\n    matrix[i] = new Array(4)\n  }\n\n  matrix[0][(byteArray[0] >> 6) & 3] = 'C'\n  matrix[0][(byteArray[0] >> 4) & 3] = 'G'\n  matrix[0][(byteArray[0] >> 2) & 3] = 'T'\n  matrix[0][(byteArray[0] >> 0) & 3] = 'N'\n\n  matrix[1][(byteArray[1] >> 6) & 3] = 'A'\n  matrix[1][(byteArray[1] >> 4) & 3] = 'G'\n  matrix[1][(byteArray[1] >> 2) & 3] = 'T'\n  matrix[1][(byteArray[1] >> 0) & 3] = 'N'\n\n  matrix[2][(byteArray[2] >> 6) & 3] = 'A'\n  matrix[2][(byteArray[2] >> 4) & 3] = 'C'\n  matrix[2][(byteArray[2] >> 2) & 3] = 'T'\n  matrix[2][(byteArray[2] >> 0) & 3] = 'N'\n\n  matrix[3][(byteArray[3] >> 6) & 3] = 'A'\n  matrix[3][(byteArray[3] >> 4) & 3] = 'C'\n  matrix[3][(byteArray[3] >> 2) & 3] = 'G'\n  matrix[3][(byteArray[3] >> 0) & 3] = 'N'\n\n  matrix[4][(byteArray[4] >> 6) & 3] = 'A'\n  matrix[4][(byteArray[4] >> 4) & 3] = 'C'\n  matrix[4][(byteArray[4] >> 2) & 3] = 'G'\n  matrix[4][(byteArray[4] >> 0) & 3] = 'T'\n\n  return matrix\n}\n\ntype DataSeriesCache = {\n  [K in DataSeriesEncodingKey]?: CramCodec<DataSeriesTypes[K]>\n}\n\nexport default class CramContainerCompressionScheme {\n  public readNamesIncluded: boolean\n  public APdelta: boolean\n  public referenceRequired: boolean\n  public tagIdsDictionary: Record<number, string[]>\n  public substitutionMatrix: string[][]\n  public dataSeriesCodecCache: DataSeriesCache = {}\n  public tagCodecCache: Record<string, CramCodec> = {}\n  public tagEncoding: Record<string, CramEncoding> = {}\n  public dataSeriesEncoding: DataSeriesEncodingMap\n  private preservation: CramPreservationMap\n  private _endPosition: number\n  private _size: number\n\n  constructor(content: CramCompressionHeader) {\n    // Object.assign(this, content)\n    // interpret some of the preservation map tags for convenient use\n    this.readNamesIncluded = content.preservation.RN\n    this.APdelta = content.preservation.AP\n    this.referenceRequired = !!content.preservation.RR\n    this.tagIdsDictionary = content.preservation.TD\n    this.substitutionMatrix = parseSubstitutionMatrix(content.preservation.SM)\n    this.dataSeriesEncoding = content.dataSeriesEncoding\n    this.tagEncoding = content.tagEncoding\n    this.preservation = content.preservation\n    this._size = content._size\n    this._endPosition = content._endPosition\n  }\n\n  /**\n   * @param {string} tagName three-character tag name\n   * @private\n   */\n  getCodecForTag(tagName: string): CramCodec {\n    if (!this.tagCodecCache[tagName]) {\n      const encodingData = this.tagEncoding[tagName]\n      if (encodingData) {\n        this.tagCodecCache[tagName] = instantiateCodec(\n          encodingData,\n          'byteArray', // all tags are byte array data\n        )\n      }\n    }\n    return this.tagCodecCache[tagName]\n  }\n\n  /**\n   *\n   * @param {number} tagListId ID of the tag list to fetch from the tag dictionary\n   * @private\n   */\n  getTagNames(tagListId: number) {\n    return this.tagIdsDictionary[tagListId]\n  }\n\n  getCodecForDataSeries<TDataSeries extends DataSeriesEncodingKey>(\n    dataSeriesName: TDataSeries,\n  ): CramCodec<DataSeriesTypes[TDataSeries]> | undefined {\n    let r: CramCodec<DataSeriesTypes[TDataSeries]> | undefined =\n      this.dataSeriesCodecCache[dataSeriesName]\n    if (r === undefined) {\n      const encodingData = this.dataSeriesEncoding[dataSeriesName]\n      if (encodingData) {\n        const dataType = dataSeriesTypes[dataSeriesName]\n        if (!dataType) {\n          throw new CramMalformedError(\n            `data series name ${dataSeriesName} not defined in file compression header`,\n          )\n        }\n        r = instantiateCodec(encodingData, dataType)\n        // didn't find a way to make TS understand this\n        this.dataSeriesCodecCache[dataSeriesName] = r as CramCodec<any>\n      }\n    }\n    return r\n  }\n\n  toJSON() {\n    const data: any = {}\n    Object.keys(this).forEach(k => {\n      if (/Cache$/.test(k)) {\n        return\n      }\n      data[k] = (this as any)[k]\n    })\n    return data\n  }\n}\n","import { CramMalformedError } from '../../errors'\n\nimport { itf8Size, parseItem, tinyMemoize } from '../util'\nimport CramSlice from '../slice'\nimport CramContainerCompressionScheme from './compressionScheme'\nimport CramFile from '../file'\n\nexport default class CramContainer {\n  constructor(public file: CramFile, public filePosition: number) {}\n\n  // memoize\n  getHeader() {\n    return this._readContainerHeader(this.filePosition)\n  }\n\n  // memoize\n  async getCompressionHeaderBlock() {\n    const containerHeader = await this.getHeader()\n\n    // if there are no records in the container, there will be no compression header\n    if (!containerHeader.numRecords) {\n      return null\n    }\n    const sectionParsers = await this.file.getSectionParsers()\n    const block = await this.getFirstBlock()\n    if (block === undefined) {\n      return undefined\n    }\n    if (block.contentType !== 'COMPRESSION_HEADER') {\n      throw new CramMalformedError(\n        `invalid content type ${block.contentType} in what is supposed to be the compression header block`,\n      )\n    }\n    const content = parseItem(\n      block.content,\n      sectionParsers.cramCompressionHeader.parser,\n      0,\n      block.contentPosition,\n    )\n    return {\n      ...block,\n      parsedContent: content,\n    }\n  }\n\n  async getFirstBlock() {\n    const containerHeader = await this.getHeader()\n    return this.file.readBlock(containerHeader._endPosition)\n  }\n\n  // parses the compression header data into a CramContainerCompressionScheme object\n  // memoize\n  async getCompressionScheme() {\n    const header = await this.getCompressionHeaderBlock()\n    if (!header) {\n      return undefined\n    }\n    return new CramContainerCompressionScheme(header.parsedContent)\n  }\n\n  getSlice(slicePosition: number, sliceSize: number) {\n    // note: slicePosition is relative to the end of the container header\n    // TODO: perhaps we should cache slices?\n    return new CramSlice(this, slicePosition, sliceSize)\n  }\n\n  async _readContainerHeader(position: number) {\n    const sectionParsers = await this.file.getSectionParsers()\n    const { cramContainerHeader1, cramContainerHeader2 } = sectionParsers\n    const { size: fileSize } = await this.file.stat()\n\n    if (position >= fileSize) {\n      return undefined\n    }\n\n    // parse the container header. do it in 2 pieces because you cannot tell\n    // how much to buffer until you read numLandmarks\n    const bytes1 = Buffer.allocUnsafe(cramContainerHeader1.maxLength)\n    await this.file.read(bytes1, 0, cramContainerHeader1.maxLength, position)\n    const header1 = parseItem(bytes1, cramContainerHeader1.parser) as any\n    const numLandmarksSize = itf8Size(header1.numLandmarks)\n    if (position + header1.length >= fileSize) {\n      console.warn(\n        `${this.file}: container header at ${position} indicates that the container has length ${header1.length}, which extends beyond the length of the file. Skipping this container.`,\n      )\n      return undefined\n    }\n    const bytes2 = Buffer.allocUnsafe(\n      cramContainerHeader2.maxLength(header1.numLandmarks),\n    )\n    await this.file.read(\n      bytes2,\n      0,\n      cramContainerHeader2.maxLength(header1.numLandmarks),\n      position + header1._size - numLandmarksSize,\n    )\n    const header2 = parseItem(bytes2, cramContainerHeader2.parser)\n\n    if (this.file.validateChecksums && header2.crc32 !== undefined) {\n      await this.file.checkCrc32(\n        position,\n        header1._size + header2._size - numLandmarksSize - 4,\n        header2.crc32,\n        `container header beginning at position ${position}`,\n      )\n    }\n\n    const completeHeader = Object.assign(header1, header2, {\n      _size: header1._size + header2._size - numLandmarksSize,\n      _endPosition: header1._size + header2._size - numLandmarksSize + position,\n    })\n\n    return completeHeader\n  }\n}\n\n'getHeader getCompressionHeaderBlock getCompressionScheme'\n  .split(' ')\n  .forEach(method => tinyMemoize(CramContainer, method))\n","import url from 'url'\nimport { ensureNotNullish } from '../typescript'\nimport { Filehandle } from '../cramFile/filehandle'\nimport { LocalFile, RemoteFile } from 'generic-filehandle'\n\nfunction fromUrl(source: string) {\n  const { protocol, pathname } = url.parse(source)\n  if (protocol === 'file:') {\n    return new LocalFile(unescape(ensureNotNullish(pathname)))\n  }\n  return new RemoteFile(source)\n}\n\nfunction open(\n  maybeUrl?: string,\n  maybePath?: string,\n  maybeFilehandle?: Filehandle,\n): Filehandle {\n  if (maybeFilehandle) {\n    return maybeFilehandle\n  }\n  if (maybeUrl) {\n    return fromUrl(maybeUrl)\n  }\n  if (maybePath) {\n    return new LocalFile(maybePath)\n  }\n  throw new Error('no url, path, or filehandle provided, cannot open')\n}\n\nexport { LocalFile, RemoteFile, fromUrl, open }\n","export function ensureNotNullish<T>(x: T | null | undefined): T {\n  if (x === null || x === undefined) {\n    throw new Error('Value must not be nullish.')\n  }\n  return x\n}\n\nexport type TupleOf<T, N extends number> = N extends N\n  ? number extends N\n    ? T[]\n    : _TupleOf<T, N, []>\n  : never\nexport type _TupleOf<\n  T,\n  N extends number,\n  R extends unknown[],\n> = R['length'] extends N ? R : _TupleOf<T, N, [T, ...R]>\n","export type HeaderDataItem = {\n  tag: string\n  data: Array<{ tag: string; value: string }>\n}\n\nexport function parseHeaderText(text: string): HeaderDataItem[] {\n  const lines = text.split(/\\r?\\n/)\n  const data: HeaderDataItem[] = []\n  lines.forEach(line => {\n    const [tag, ...fields] = line.split(/\\t/)\n    const parsedFields = fields.map(f => {\n      const [fieldTag, value] = f.split(':', 2)\n      return { tag: fieldTag, value }\n    })\n    if (tag) {\n      data.push({ tag: tag.substr(1), data: parsedFields })\n    }\n  })\n  return data\n}\n","import { unzip } from '../unzip'\nimport crc32 from 'buffer-crc32'\nimport QuickLRU from 'quick-lru'\n// @ts-expect-error\nimport bzip2 from 'bzip2'\n\nimport { CramMalformedError, CramUnimplementedError } from '../errors'\nimport ransuncompress from '../rans'\nimport {\n  BlockHeader,\n  CompressionMethod,\n  cramFileDefinition as cramFileDefinitionParser,\n  getSectionParsers,\n} from './sectionParsers'\nimport htscodecs from '@jkbonfield/htscodecs'\nimport CramContainer from './container'\n\nimport { open } from '../io'\nimport { parseItem, tinyMemoize } from './util'\nimport { parseHeaderText } from '../sam'\nimport { Parser } from '@gmod/binary-parser'\nimport CramRecord from './record'\nimport { Filehandle } from './filehandle'\n\n//source:https://abdulapopoola.com/2019/01/20/check-endianness-with-javascript/\nfunction getEndianness() {\n  const uInt32 = new Uint32Array([0x11223344])\n  const uInt8 = new Uint8Array(uInt32.buffer)\n\n  if (uInt8[0] === 0x44) {\n    return 0 //little-endian\n  } else if (uInt8[0] === 0x11) {\n    return 1 //big-endian\n  } else {\n    return 2 //mixed-endian?\n  }\n}\n\n// export type CramFileSource =\n//   | { url: string; path?: undefined; filehandle?: undefined }\n//   | { path: string; url?: undefined; filehandle?: undefined }\n//   | { filehandle: Filehandle; url?: undefined; path?: undefined }\n\nexport type CramFileSource = {\n  filehandle?: Filehandle\n  url?: string\n  path?: string\n}\n\nexport type SeqFetch = (\n  seqId: number,\n  start: number,\n  end: number,\n) => Promise<string>\n\nexport type CramFileArgs = CramFileSource & {\n  checkSequenceMD5: boolean\n  cacheSize?: number\n  seqFetch: SeqFetch\n}\n\nexport type CramFileBlock = BlockHeader & {\n  _endPosition: number\n  contentPosition: number\n  _size: number\n  content: Buffer\n  crc32?: number\n}\n\nexport default class CramFile {\n  private file: Filehandle\n  public validateChecksums: boolean\n  public fetchReferenceSequenceCallback: SeqFetch\n  public options: {\n    checkSequenceMD5: boolean\n    cacheSize: number\n  }\n  public featureCache: QuickLRU<string, Promise<CramRecord[]>>\n  private header: string | undefined\n\n  constructor(args: CramFileArgs) {\n    this.file = open(args.url, args.path, args.filehandle)\n    this.validateChecksums = true\n    this.fetchReferenceSequenceCallback = args.seqFetch\n    this.options = {\n      checkSequenceMD5: args.checkSequenceMD5,\n      cacheSize: args.cacheSize ?? 20000,\n    }\n\n    // cache of features in a slice, keyed by the\n    // slice offset. caches all of the features in a slice, or none.\n    // the cache is actually used by the slice object, it's just\n    // kept here at the level of the file\n    this.featureCache = new QuickLRU({\n      maxSize: this.options.cacheSize,\n    })\n    if (getEndianness() > 0) {\n      throw new Error('Detected big-endian machine, may be unable to run')\n    }\n  }\n\n  // toString() {\n  //   if (this.file.filename) {\n  //     return this.file.filename\n  //   }\n  //   if (this.file.url) {\n  //     return this.file.url\n  //   }\n  //\n  //   return '(cram file)'\n  // }\n\n  // can just read this object like a filehandle\n  read(\n    buffer: Buffer,\n    offset: number,\n    length: number,\n    position: number,\n  ): Promise<{\n    bytesRead: number\n    buffer: Buffer\n  }> {\n    return this.file.read(buffer, offset, length, position)\n  }\n\n  // can just stat this object like a filehandle\n  stat() {\n    return this.file.stat()\n  }\n\n  // memoized\n  async getDefinition() {\n    const headbytes = Buffer.allocUnsafe(cramFileDefinitionParser.maxLength)\n    await this.file.read(headbytes, 0, cramFileDefinitionParser.maxLength, 0)\n    const definition = cramFileDefinitionParser.parser.parse(headbytes)\n      .result as any\n    if (definition.majorVersion !== 2 && definition.majorVersion !== 3) {\n      throw new CramUnimplementedError(\n        `CRAM version ${definition.majorVersion} not supported`,\n      )\n    }\n    return definition\n  }\n\n  // memoize\n  async getSamHeader() {\n    const firstContainer = await this.getContainerById(0)\n    if (!firstContainer) {\n      throw new CramMalformedError('file contains no containers')\n    }\n\n    const firstBlock = await firstContainer.getFirstBlock()\n    if (firstBlock === undefined) {\n      return parseHeaderText('')\n    }\n    const content = firstBlock.content\n    // find the end of the trailing zeros in the header text\n    const headerLength = content.readInt32LE(0)\n    const textStart = 4\n    // let textEnd = content.length - 1\n    // while (textEnd >= textStart && !content[textEnd]) textEnd -= 1\n    // trim off the trailing zeros\n    const text = content.toString('utf8', textStart, textStart + headerLength)\n    this.header = text\n    return parseHeaderText(text)\n  }\n\n  async getHeaderText() {\n    await this.getSamHeader()\n    return this.header\n  }\n\n  // memoize\n  async getSectionParsers() {\n    const { majorVersion } = await this.getDefinition()\n    return getSectionParsers(majorVersion)\n  }\n\n  async getContainerById(containerNumber: number) {\n    const sectionParsers = await this.getSectionParsers()\n    let position = sectionParsers.cramFileDefinition.maxLength\n    const { size: fileSize } = await this.file.stat()\n    const { cramContainerHeader1 } = sectionParsers\n\n    // skip with a series of reads to the proper container\n    let currentContainer\n    for (let i = 0; i <= containerNumber; i += 1) {\n      // if we are about to go off the end of the file\n      // and have not found that container, it does not exist\n      if (position + cramContainerHeader1.maxLength + 8 >= fileSize) {\n        return undefined\n      }\n\n      currentContainer = this.getContainerAtPosition(position)\n      const currentHeader = await currentContainer.getHeader()\n      if (!currentHeader) {\n        throw new CramMalformedError(\n          `container ${containerNumber} not found in file`,\n        )\n      }\n      // if this is the first container, read all the blocks in the\n      // container to determine its length, because we cannot trust\n      // the container header's given length due to a bug somewhere\n      // in htslib\n      if (i === 0) {\n        position = currentHeader._endPosition\n        for (let j = 0; j < currentHeader.numBlocks; j += 1) {\n          const block = await this.readBlock(position)\n          if (block === undefined) {\n            return undefined\n          }\n          position = block._endPosition\n        }\n      } else {\n        // otherwise, just traverse to the next container using the container's length\n        position += currentHeader._size + currentHeader.length\n      }\n    }\n\n    return currentContainer\n  }\n\n  async checkCrc32(\n    position: number,\n    length: number,\n    recordedCrc32: number,\n    description: string,\n  ) {\n    const b = Buffer.allocUnsafe(length)\n    await this.file.read(b, 0, length, position)\n    const calculatedCrc32 = crc32.unsigned(b)\n    if (calculatedCrc32 !== recordedCrc32) {\n      throw new CramMalformedError(\n        `crc mismatch in ${description}: recorded CRC32 = ${recordedCrc32}, but calculated CRC32 = ${calculatedCrc32}`,\n      )\n    }\n  }\n\n  /**\n   * @returns {Promise[number]} the number of containers in the file\n   */\n  async containerCount(): Promise<number | undefined> {\n    const sectionParsers = await this.getSectionParsers()\n    const { size: fileSize } = await this.file.stat()\n    const { cramContainerHeader1 } = sectionParsers\n\n    let containerCount = 0\n    let position = sectionParsers.cramFileDefinition.maxLength\n    while (position + cramContainerHeader1.maxLength + 8 < fileSize) {\n      const currentHeader = await this.getContainerAtPosition(\n        position,\n      ).getHeader()\n      if (!currentHeader) {\n        break\n      }\n      // if this is the first container, read all the blocks in the\n      // container, because we cannot trust the container\n      // header's given length due to a bug somewhere in htslib\n      if (containerCount === 0) {\n        position = currentHeader._endPosition\n        for (let j = 0; j < currentHeader.numBlocks; j += 1) {\n          const block = await this.readBlock(position)\n          if (block === undefined) {\n            return undefined\n          }\n          position = block._endPosition\n        }\n      } else {\n        // otherwise, just traverse to the next container using the container's length\n        position += currentHeader._size + currentHeader.length\n      }\n      containerCount += 1\n    }\n\n    return containerCount\n  }\n\n  getContainerAtPosition(position: number) {\n    return new CramContainer(this, position)\n  }\n\n  async readBlockHeader(position: number) {\n    const sectionParsers = await this.getSectionParsers()\n    const { cramBlockHeader } = sectionParsers\n    const { size: fileSize } = await this.file.stat()\n\n    if (position + cramBlockHeader.maxLength >= fileSize) {\n      return undefined\n    }\n\n    const buffer = Buffer.allocUnsafe(cramBlockHeader.maxLength)\n    await this.file.read(buffer, 0, cramBlockHeader.maxLength, position)\n    return parseItem(buffer, cramBlockHeader.parser, 0, position)\n  }\n\n  async _parseSection<T>(\n    section: { parser: Parser<T>; maxLength: number },\n    position: number,\n    size = section.maxLength,\n    preReadBuffer = undefined,\n  ) {\n    let buffer\n    if (preReadBuffer) {\n      buffer = preReadBuffer\n    } else {\n      const { size: fileSize } = await this.file.stat()\n      if (position + size >= fileSize) {\n        return undefined\n      }\n      buffer = Buffer.allocUnsafe(size)\n      await this.file.read(buffer, 0, size, position)\n    }\n    const data = parseItem(buffer, section.parser, 0, position)\n    if (data._size !== size) {\n      throw new CramMalformedError(\n        `section read error: requested size ${size} does not equal parsed size ${data._size}`,\n      )\n    }\n    return data\n  }\n\n  _uncompress(\n    compressionMethod: CompressionMethod,\n    inputBuffer: Buffer,\n    outputBuffer: Buffer,\n  ) {\n    if (compressionMethod === 'gzip') {\n      const result = unzip(inputBuffer)\n      result.copy(outputBuffer)\n    } else if (compressionMethod === 'bzip2') {\n      const bits = bzip2.array(inputBuffer)\n      let size = bzip2.header(bits)\n      let j = 0\n      let chunk\n      do {\n        chunk = bzip2.decompress(bits, size)\n        if (chunk != -1) {\n          Buffer.from(chunk).copy(outputBuffer, j)\n          j += chunk.length\n          size -= chunk.length\n        }\n      } while (chunk != -1)\n    } else if (compressionMethod === 'rans') {\n      ransuncompress(inputBuffer, outputBuffer)\n      //htscodecs r4x8 is slower, but compatible.\n      //htscodecs.r4x8_uncompress(inputBuffer, outputBuffer);\n    } else if (compressionMethod === 'rans4x16') {\n      htscodecs.r4x16_uncompress(inputBuffer, outputBuffer)\n    } else if (compressionMethod === 'arith') {\n      htscodecs.arith_uncompress(inputBuffer, outputBuffer)\n    } else if (compressionMethod === 'fqzcomp') {\n      htscodecs.fqzcomp_uncompress(inputBuffer, outputBuffer)\n    } else if (compressionMethod === 'tok3') {\n      htscodecs.tok3_uncompress(inputBuffer, outputBuffer)\n    } else {\n      throw new CramUnimplementedError(\n        `${compressionMethod} decompression not yet implemented`,\n      )\n    }\n  }\n\n  async readBlock(position: number): Promise<CramFileBlock | undefined> {\n    const { majorVersion } = await this.getDefinition()\n    const sectionParsers = await this.getSectionParsers()\n    const blockHeader = await this.readBlockHeader(position)\n    if (blockHeader === undefined) {\n      return undefined\n    }\n    const blockContentPosition = blockHeader._endPosition\n\n    const uncompressedData = Buffer.allocUnsafe(blockHeader.uncompressedSize)\n\n    const block: CramFileBlock = {\n      ...blockHeader,\n      _endPosition: blockContentPosition,\n      contentPosition: blockContentPosition,\n      content: uncompressedData,\n    }\n\n    if (blockHeader.compressionMethod !== 'raw') {\n      const compressedData = Buffer.allocUnsafe(blockHeader.compressedSize)\n      await this.read(\n        compressedData,\n        0,\n        blockHeader.compressedSize,\n        blockContentPosition,\n      )\n\n      this._uncompress(\n        blockHeader.compressionMethod,\n        compressedData,\n        uncompressedData,\n      )\n    } else {\n      await this.read(\n        uncompressedData,\n        0,\n        blockHeader.uncompressedSize,\n        blockContentPosition,\n      )\n    }\n\n    if (majorVersion >= 3) {\n      // parse the crc32\n      const crc = await this._parseSection(\n        sectionParsers.cramBlockCrc32,\n        blockContentPosition + blockHeader.compressedSize,\n      )\n      if (crc === undefined) {\n        return undefined\n      }\n      block.crc32 = crc.crc32\n\n      // check the block data crc32\n      if (this.validateChecksums) {\n        await this.checkCrc32(\n          position,\n          blockHeader._size + blockHeader.compressedSize,\n          crc.crc32,\n          'block data',\n        )\n      }\n\n      // make the endposition and size reflect the whole block\n      block._endPosition = crc._endPosition\n      block._size =\n        block.compressedSize + sectionParsers.cramBlockCrc32.maxLength\n    } else {\n      block._endPosition = blockContentPosition + block.compressedSize\n      block._size = block.compressedSize\n    }\n\n    return block\n  }\n}\n\n'getDefinition getSectionParsers getSamHeader'\n  .split(' ')\n  .forEach(method => tinyMemoize(CramFile, method))\n","import { CramMalformedError } from '../errors'\n\nimport { TF_SHIFT } from './constants'\nimport Decoding from './decoding'\n\nexport default function uncompress(\n  /* ByteBuffer */ input,\n  /* Decoding.AriDecoder */ D,\n  /* Decoding.Symbol[] */ syms,\n  /* ByteBuffer */ out,\n) {\n  let rans0 = input.getInt()\n  let rans1 = input.getInt()\n  let rans2 = input.getInt()\n  let rans3 = input.getInt()\n\n  const /* int */ outputSize = out.remaining()\n  const /* int */ outputEnd = outputSize & ~3\n  for (let i = 0; i < outputEnd; i += 4) {\n    const /* byte */ c0 = D.R[Decoding.get(rans0, TF_SHIFT)]\n    const /* byte */ c1 = D.R[Decoding.get(rans1, TF_SHIFT)]\n    const /* byte */ c2 = D.R[Decoding.get(rans2, TF_SHIFT)]\n    const /* byte */ c3 = D.R[Decoding.get(rans3, TF_SHIFT)]\n\n    out.putAt(i, c0)\n    out.putAt(i + 1, c1)\n    out.putAt(i + 2, c2)\n    out.putAt(i + 3, c3)\n\n    rans0 = Decoding.advanceSymbolStep(rans0, syms[0xff & c0], TF_SHIFT)\n    rans1 = Decoding.advanceSymbolStep(rans1, syms[0xff & c1], TF_SHIFT)\n    rans2 = Decoding.advanceSymbolStep(rans2, syms[0xff & c2], TF_SHIFT)\n    rans3 = Decoding.advanceSymbolStep(rans3, syms[0xff & c3], TF_SHIFT)\n\n    rans0 = Decoding.renormalize(rans0, input)\n    rans1 = Decoding.renormalize(rans1, input)\n    rans2 = Decoding.renormalize(rans2, input)\n    rans3 = Decoding.renormalize(rans3, input)\n  }\n\n  out.setPosition(outputEnd)\n  let /* byte */ c\n  switch (outputSize & 3) {\n    case 0:\n      break\n    case 1:\n      c = D.R[Decoding.get(rans0, TF_SHIFT)]\n      Decoding.advanceSymbol(rans0, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n      break\n\n    case 2:\n      c = D.R[Decoding.get(rans0, TF_SHIFT)]\n      Decoding.advanceSymbol(rans0, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n\n      c = D.R[Decoding.get(rans1, TF_SHIFT)]\n      Decoding.advanceSymbol(rans1, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n      break\n\n    case 3:\n      c = D.R[Decoding.get(rans0, TF_SHIFT)]\n      Decoding.advanceSymbol(rans0, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n\n      c = D.R[Decoding.get(rans1, TF_SHIFT)]\n      Decoding.advanceSymbol(rans1, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n\n      c = D.R[Decoding.get(rans2, TF_SHIFT)]\n      Decoding.advanceSymbol(rans2, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n      break\n\n    default:\n      throw new CramMalformedError(\n        'invalid output size encountered during rANS decoding',\n      )\n  }\n\n  out.setPosition(0)\n}\n","import { TF_SHIFT } from './constants'\nimport Decoding from './decoding'\n\nexport default function uncompress(\n  /* ByteBuffer */ input,\n  /* ByteBuffer */ output,\n  /* Decoding.AriDecoder[] */ D,\n  /* Decoding.Symbol[][] */ syms,\n) {\n  const /* int */ outputSize = output.remaining()\n  let rans0 = input.getInt()\n  let rans1 = input.getInt()\n  let rans2 = input.getInt()\n  let rans7 = input.getInt()\n\n  const /* int */ isz4 = outputSize >> 2\n  let /* int */ i0 = 0\n  let /* int */ i1 = isz4\n  let /* int */ i2 = 2 * isz4\n  let /* int */ i7 = 3 * isz4\n  let /* int */ l0 = 0\n  let /* int */ l1 = 0\n  let /* int */ l2 = 0\n  let /* int */ l7 = 0\n  for (; i0 < isz4; i0 += 1, i1 += 1, i2 += 1, i7 += 1) {\n    const /* int */ c0 = 0xff & D[l0].R[Decoding.get(rans0, TF_SHIFT)]\n    const /* int */ c1 = 0xff & D[l1].R[Decoding.get(rans1, TF_SHIFT)]\n    const /* int */ c2 = 0xff & D[l2].R[Decoding.get(rans2, TF_SHIFT)]\n    const /* int */ c7 = 0xff & D[l7].R[Decoding.get(rans7, TF_SHIFT)]\n\n    output.putAt(i0, c0)\n    output.putAt(i1, c1)\n    output.putAt(i2, c2)\n    output.putAt(i7, c7)\n\n    rans0 = Decoding.advanceSymbolStep(rans0, syms[l0][c0], TF_SHIFT)\n    rans1 = Decoding.advanceSymbolStep(rans1, syms[l1][c1], TF_SHIFT)\n    rans2 = Decoding.advanceSymbolStep(rans2, syms[l2][c2], TF_SHIFT)\n    rans7 = Decoding.advanceSymbolStep(rans7, syms[l7][c7], TF_SHIFT)\n\n    rans0 = Decoding.renormalize(rans0, input)\n    rans1 = Decoding.renormalize(rans1, input)\n    rans2 = Decoding.renormalize(rans2, input)\n    rans7 = Decoding.renormalize(rans7, input)\n\n    l0 = c0\n    l1 = c1\n    l2 = c2\n    l7 = c7\n  }\n\n  // Remainder\n  for (; i7 < outputSize; i7 += 1) {\n    const /* int */ c7 = 0xff & D[l7].R[Decoding.get(rans7, TF_SHIFT)]\n    output.putAt(i7, c7)\n    rans7 = Decoding.advanceSymbol(rans7, input, syms[l7][c7], TF_SHIFT)\n    l7 = c7\n  }\n}\n","import CramFile from './file'\nexport { default as CramRecord } from './record'\n\nexport default CramFile\n","import { CramSizeLimitError, CramUnimplementedError } from './errors'\n\nimport CramFile from './cramFile'\nimport CramRecord from './cramFile/record'\nimport { SeqFetch } from './cramFile/file'\nimport { Filehandle } from './cramFile/filehandle'\nimport { Slice } from './craiIndex'\n\nexport type CramFileSource = {\n  cramFilehandle?: Filehandle\n  cramUrl?: string\n  cramPath?: string\n}\n\nexport type CramIndexLike = {\n  getEntriesForRange: (\n    seqId: number,\n    start: number,\n    end: number,\n  ) => Promise<Slice[]>\n  hasDataForReferenceSequence: (seqId: number) => Promise<boolean>\n}\n\nexport default class IndexedCramFile {\n  public cram: CramFile\n  public index: CramIndexLike\n  private fetchSizeLimit: number\n\n  /**\n   *\n   * @param {object} args\n   * @param {CramFile} args.cram\n   * @param {Index-like} args.index object that supports getEntriesForRange(seqId,start,end) -> Promise[Array[index entries]]\n   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000\n   * @param {number} [args.fetchSizeLimit] optional maximum number of bytes to fetch in a single getRecordsForRange call.  Default 3 MiB.\n   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5\n   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.\n   */\n  constructor(\n    args: {\n      index: CramIndexLike\n      fetchSizeLimit?: number\n    } & (\n      | { cram: CramFile }\n      | ({\n          cram?: undefined\n          seqFetch: SeqFetch\n          checkSequenceMD5: boolean\n          cacheSize?: number\n        } & CramFileSource)\n    ),\n  ) {\n    // { cram, index, seqFetch /* fasta, fastaIndex */ }) {\n    if (args.cram) {\n      this.cram = args.cram\n    } else {\n      this.cram = new CramFile({\n        url: args.cramUrl,\n        path: args.cramPath,\n        filehandle: args.cramFilehandle,\n        seqFetch: args.seqFetch,\n        checkSequenceMD5: args.checkSequenceMD5,\n        cacheSize: args.cacheSize,\n      })\n    }\n\n    if (!(this.cram instanceof CramFile)) {\n      throw new Error('invalid arguments: no cramfile')\n    }\n\n    this.index = args.index\n    if (!this.index.getEntriesForRange) {\n      throw new Error('invalid arguments: not an index')\n    }\n\n    this.fetchSizeLimit = args.fetchSizeLimit || 3000000\n  }\n\n  /**\n   *\n   * @param {number} seq numeric ID of the reference sequence\n   * @param {number} start start of the range of interest. 1-based closed coordinates.\n   * @param {number} end end of the range of interest. 1-based closed coordinates.\n   * @returns {Promise[Array[CramRecord]]}\n   */\n  async getRecordsForRange(\n    seq: number,\n    start: number,\n    end: number,\n    opts: {\n      viewAsPairs?: boolean\n      pairAcrossChr?: boolean\n      maxInsertSize?: number\n    } = {},\n  ) {\n    opts.viewAsPairs = opts.viewAsPairs || false\n    opts.pairAcrossChr = opts.pairAcrossChr || false\n    opts.maxInsertSize = opts.maxInsertSize || 200000\n\n    if (typeof seq === 'string') {\n      // TODO: support string reference sequence names somehow\n      throw new CramUnimplementedError(\n        'string sequence names not yet supported',\n      )\n    }\n    const seqId = seq\n    const slices = await this.index.getEntriesForRange(seqId, start, end)\n    const totalSize = slices.map(s => s.sliceBytes).reduce((a, b) => a + b, 0)\n    if (totalSize > this.fetchSizeLimit) {\n      throw new CramSizeLimitError(\n        `data size of ${totalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n\n    // TODO: do we need to merge or de-duplicate the blocks?\n\n    // fetch all the slices and parse the feature data\n    const filter = (feature: CramRecord) =>\n      feature.sequenceId === seq &&\n      feature.alignmentStart <= end &&\n      feature.lengthOnRef !== undefined &&\n      feature.alignmentStart + feature.lengthOnRef - 1 >= start\n    const sliceResults = await Promise.all(\n      slices.map(slice => this.getRecordsInSlice(slice, filter)),\n    )\n\n    let ret: CramRecord[] = Array.prototype.concat(...sliceResults)\n    if (opts.viewAsPairs) {\n      const readNames: Record<string, number> = {}\n      const readIds: Record<string, number> = {}\n      for (let i = 0; i < ret.length; i += 1) {\n        const name = ret[i].readName\n        if (name === undefined) {\n          throw new Error()\n        }\n        const id = ret[i].uniqueId\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name] += 1\n        readIds[id] = 1\n      }\n      const unmatedPairs: Record<string, boolean> = {}\n      Object.entries(readNames).forEach(([k, v]) => {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      })\n      const matePromises = []\n      for (let i = 0; i < ret.length; i += 1) {\n        const cramRecord = ret[i]\n        const name = cramRecord.readName\n        if (name === undefined) {\n          throw new Error()\n        }\n        if (\n          unmatedPairs[name] &&\n          cramRecord.mate &&\n          (cramRecord.mate.sequenceId === seqId || opts.pairAcrossChr) &&\n          Math.abs(cramRecord.alignmentStart - cramRecord.mate.alignmentStart) <\n            opts.maxInsertSize\n        ) {\n          const mateSlices = this.index.getEntriesForRange(\n            cramRecord.mate.sequenceId,\n            cramRecord.mate.alignmentStart,\n            cramRecord.mate.alignmentStart + 1,\n          )\n          matePromises.push(mateSlices)\n        }\n      }\n      const mateBlocks = await Promise.all(matePromises)\n      let mateChunks = []\n      for (let i = 0; i < mateBlocks.length; i += 1) {\n        mateChunks.push(...mateBlocks[i])\n      }\n      // filter out duplicates\n      mateChunks = mateChunks\n        .sort((a, b) => a.toString().localeCompare(b.toString()))\n        .filter(\n          (item, pos, ary) =>\n            !pos || item.toString() !== ary[pos - 1].toString(),\n        )\n\n      const mateRecordPromises = []\n      const mateFeatPromises: Array<Promise<CramRecord[]>> = []\n\n      const mateTotalSize = mateChunks\n        .map(s => s.sliceBytes)\n        .reduce((a, b) => a + b, 0)\n      if (mateTotalSize > this.fetchSizeLimit) {\n        throw new Error(\n          `mate data size of ${mateTotalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n        )\n      }\n\n      mateChunks.forEach(c => {\n        let recordPromise = this.cram.featureCache.get(c.toString())\n        if (!recordPromise) {\n          recordPromise = this.getRecordsInSlice(c, () => true)\n          this.cram.featureCache.set(c.toString(), recordPromise)\n        }\n        mateRecordPromises.push(recordPromise)\n        const featPromise = recordPromise.then(feats => {\n          const mateRecs = []\n          for (let i = 0; i < feats.length; i += 1) {\n            const feature = feats[i]\n            if (feature.readName === undefined) {\n              throw new Error()\n            }\n            if (unmatedPairs[feature.readName] && !readIds[feature.uniqueId]) {\n              mateRecs.push(feature)\n            }\n          }\n          return mateRecs\n        })\n        mateFeatPromises.push(featPromise)\n      })\n      const newMateFeats = await Promise.all(mateFeatPromises)\n      if (newMateFeats.length) {\n        const newMates = newMateFeats.reduce((result, current) =>\n          result.concat(current),\n        )\n        ret = ret.concat(newMates)\n      }\n    }\n    return ret\n  }\n\n  getRecordsInSlice(\n    {\n      containerStart,\n      sliceStart,\n      sliceBytes,\n    }: { containerStart: number; sliceStart: number; sliceBytes: number },\n    filterFunction: (r: CramRecord) => boolean,\n  ) {\n    const container = this.cram.getContainerAtPosition(containerStart)\n    const slice = container.getSlice(sliceStart, sliceBytes)\n    return slice.getRecords(filterFunction)\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @returns {Promise} true if the CRAM file contains data for the given\n   * reference sequence numerical ID\n   */\n  hasDataForReferenceSequence(seqId: number) {\n    return this.index.hasDataForReferenceSequence(seqId)\n  }\n}\n","import AbortablePromiseCache from 'abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\nimport { unzip } from './unzip'\nimport { open } from './io'\nimport { CramMalformedError } from './errors'\nimport { CramFileSource } from './cramFile/file'\nimport { Filehandle } from './cramFile/filehandle'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nexport type Slice = {\n  start: number\n  span: number\n  containerStart: number\n  sliceStart: number\n  sliceBytes: number\n}\n\ntype ParsedIndex = Record<string, Slice[]>\n\nfunction addRecordToIndex(index: ParsedIndex, record: number[]) {\n  if (record.some(el => el === undefined)) {\n    throw new CramMalformedError('invalid .crai index file')\n  }\n\n  const [seqId, start, span, containerStart, sliceStart, sliceBytes] = record\n\n  if (!index[seqId]) {\n    index[seqId] = []\n  }\n\n  index[seqId].push({\n    start,\n    span,\n    containerStart,\n    sliceStart,\n    sliceBytes,\n  })\n}\n\nexport default class CraiIndex {\n  // A CRAM index (.crai) is a gzipped tab delimited file containing the following columns:\n  // 1. Sequence id\n  // 2. Alignment start\n  // 3. Alignment span\n  // 4. Container start byte position in the file\n  // 5. Slice start byte position in the container data (‘blocks’)\n  // 6. Slice size in bytes\n  // Each line represents a slice in the CRAM file. Please note that all slices must be listed in index file.\n  private _parseCache: AbortablePromiseCache<unknown, ParsedIndex>\n  private filehandle: Filehandle\n\n  /**\n   *\n   * @param {object} args\n   * @param {string} [args.path]\n   * @param {string} [args.url]\n   * @param {FileHandle} [args.filehandle]\n   */\n  constructor(args: CramFileSource) {\n    this.filehandle = open(args.url, args.path, args.filehandle)\n    this._parseCache = new AbortablePromiseCache<unknown, ParsedIndex>({\n      cache: new QuickLRU({ maxSize: 1 }),\n      fill: (data, signal) => this.parseIndex(),\n    })\n  }\n\n  parseIndex() {\n    const index: ParsedIndex = {}\n    return this.filehandle\n      .readFile()\n      .then(data => {\n        if (data[0] === 31 && data[1] === 139) {\n          return unzip(data)\n        }\n        return data\n      })\n      .then(uncompressedBuffer => {\n        if (\n          uncompressedBuffer.length > 4 &&\n          uncompressedBuffer.readUInt32LE(0) === BAI_MAGIC\n        ) {\n          throw new CramMalformedError(\n            'invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support',\n          )\n        }\n        // interpret the text as regular ascii, since it is\n        // supposed to be only digits and whitespace characters\n        // this is written in a deliberately low-level fashion for performance,\n        // because some .crai files can be pretty large.\n        let currentRecord: number[] = []\n        let currentString = ''\n        for (let i = 0; i < uncompressedBuffer.length; i += 1) {\n          const charCode = uncompressedBuffer[i]\n          if (\n            (charCode >= 48 && charCode <= 57) /* 0-9 */ ||\n            (!currentString && charCode === 45) /* leading - */\n          ) {\n            currentString += String.fromCharCode(charCode)\n          } else if (charCode === 9 /* \\t */) {\n            currentRecord.push(Number.parseInt(currentString, 10))\n            currentString = ''\n          } else if (charCode === 10 /* \\n */) {\n            currentRecord.push(Number.parseInt(currentString, 10))\n            currentString = ''\n            addRecordToIndex(index, currentRecord)\n            currentRecord = []\n          } else if (charCode !== 13 /* \\r */ && charCode !== 32 /* space */) {\n            // if there are other characters in the file besides\n            // space and \\r, something is wrong.\n            throw new CramMalformedError('invalid .crai index file')\n          }\n        }\n\n        // if the file ends without a \\n, we need to flush our buffers\n        if (currentString) {\n          currentRecord.push(Number.parseInt(currentString, 10))\n        }\n        if (currentRecord.length === 6) {\n          addRecordToIndex(index, currentRecord)\n        }\n\n        // sort each of them by start\n        Object.entries(index).forEach(([seqId, ent]) => {\n          index[seqId] = ent.sort(\n            (a, b) => a.start - b.start || a.span - b.span,\n          )\n        })\n        return index\n      })\n  }\n\n  getIndex(opts: { signal?: AbortSignal } = {}) {\n    return this._parseCache.get('index', null, opts.signal)\n  }\n\n  /**\n   * @param {number} seqId\n   * @returns {Promise} true if the index contains entries for\n   * the given reference sequence ID, false otherwise\n   */\n  async hasDataForReferenceSequence(seqId: number) {\n    return !!(await this.getIndex())[seqId]\n  }\n\n  /**\n   * fetch index entries for the given range\n   *\n   * @param {number} seqId\n   * @param {number} queryStart\n   * @param {number} queryEnd\n   *\n   * @returns {Promise} promise for\n   * an array of objects of the form\n   * `{start, span, containerStart, sliceStart, sliceBytes }`\n   */\n  async getEntriesForRange(\n    seqId: number,\n    queryStart: number,\n    queryEnd: number,\n  ) {\n    const seqEntries = (await this.getIndex())[seqId]\n    if (!seqEntries) {\n      return []\n    }\n\n    const compare = (entry: Slice) => {\n      const entryStart = entry.start\n      const entryEnd = entry.start + entry.span\n      if (entryStart > queryEnd) {\n        return -1\n      } // entry is ahead of query\n      if (entryEnd <= queryStart) {\n        return 1\n      } // entry is behind query\n      return 0 // entry overlaps query\n    }\n    const bins = []\n    for (let i = 0; i < seqEntries.length; i += 1) {\n      if (compare(seqEntries[i]) === 0) {\n        bins.push(seqEntries[i])\n      }\n    }\n    return bins\n  }\n}\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst RangeCoder = require(\"./arith_sh\");\nconst IOStream = require(\"./iostream\");\nconst ByteModel = require(\"./byte_model\");\nconst bzip2 = require(\"bzip2\");\n\nconst ARITH_ORDER  = 1\nconst ARITH_EXT    = 4\nconst ARITH_STRIPE = 8\nconst ARITH_NOSIZE = 16\nconst ARITH_CAT    = 32\nconst ARITH_RLE    = 64\nconst ARITH_PACK   = 128\n\nmodule.exports = class RangeCoderGen {\n    decode(src) {\n\tthis.stream = new IOStream(src);\n\treturn this.decodeStream(this.stream)\n    }\n\n    decodeStream(stream, n_out=0) {\n\tvar flags = this.stream.ReadByte();\n\tif (!(flags & ARITH_NOSIZE))\n\t    n_out = this.stream.ReadUint7();\n\tvar e_len = n_out;\n\n\tvar order = flags & ARITH_ORDER;\n\n\t// 4-way recursion\n\tif (flags & ARITH_STRIPE)\n\t    return this.decodeStripe(this.stream, n_out)\n\n\t// Meta data\n\tif (flags & ARITH_PACK) {\n\t    var P\n\t    [P, e_len] = this.decodePackMeta(this.stream)\n\t}\n\n\t// NOP, useful for tiny blocks\n\tif (flags & ARITH_CAT)\n\t    var data = this.decodeCat(this.stream, e_len)\n\n\t// Entropy decode\n\telse if (flags & ARITH_EXT) {\n\t    var data = this.decodeExt(this.stream, e_len)\n\t} else if (flags & ARITH_RLE) {\n\t    var data = order\n\t\t? this.decodeRLE1(this.stream, e_len)\n\t\t: this.decodeRLE0(this.stream, e_len)\n\t} else {\n\t    var data = order\n\t\t? this.decode1(this.stream, e_len)\n\t\t: this.decode0(this.stream, e_len)\n\t}\n\n\t// Transforms\n\tif (flags & ARITH_PACK)\n\t    data = this.decodePack(data, P, n_out)\n\n\treturn data\n    }\n\n    encode(src, flags) {\n\tthis.stream = new IOStream(\"\", 0, src.length*1.1 + 100); // guestimate worst case!\n\n\tthis.stream.WriteByte(flags);\n\tif (!(flags & ARITH_NOSIZE))\n\t    this.stream.WriteUint7(src.length);\n\n\tif (flags & ARITH_STRIPE)\n\t    return Buffer.concat([this.stream.buf.slice(0, this.stream.pos),\n\t\t\t\t  this.encodeStripe(this.stream, src, flags>>8)])\n\n\tvar order = flags & ARITH_ORDER;\n\tvar e_len = src.length;\n\n\t// step 1: Encode meta-data\n\tvar pack_meta\n\tif (flags & ARITH_PACK)\n\t    [pack_meta, src, e_len] = this.encodePack(src)\n\n\t// step 2: Write any meta data\n\tif (flags & ARITH_PACK)\n\t    this.stream.WriteStream(pack_meta)\n\n\t// step 3: arith encoding below\n\tif (flags & ARITH_RLE) {\n\t    return order\n\t\t? this.encodeRLE1(src, e_len, this.stream)\n\t\t: this.encodeRLE0(src, e_len, this.stream);\n\t} else {\n\t    return order\n\t\t? this.encode1(src, e_len, this.stream)\n\t\t: this.encode0(src, e_len, this.stream);\n\t}\n    }\n\n    //----------------------------------------------------------------------\n    // Order-0 codec\n    decode0(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar byte_model = new ByteModel(max_sym);\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tfor (var i = 0; i < n_out; i++)\n\t    output[i] = byte_model.ModelDecode(stream, rc);\n\n\treturn output;\n    }\n\n    encode0(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!?\n\n\tvar byte_model = new ByteModel(max_sym);\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tfor (var i = 0; i < n_in; i++)\n\t    byte_model.ModelEncode(out, rc, src[i])\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // Order-1 codec\n\n    decode1(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar byte_model = new Array(max_sym);\n\tfor (var i = 0; i < max_sym; i++)\n\t    byte_model[i] = new ByteModel(max_sym);\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tvar last = 0;\n\tfor (var i = 0; i < n_out; i++) {\n\t    output[i] = byte_model[last].ModelDecode(stream, rc);\n\t    last = output[i];\n\t}\n\n\treturn output;\n    }\n\n    encode1(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!\n\n\tvar byte_model = new Array(max_sym);\n\tfor (var i = 0; i < max_sym; i++)\n\t    byte_model[i] = new ByteModel(max_sym);\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tvar last = 0;\n\tfor (var i = 0; i < n_in; i++) {\n\t    byte_model[last].ModelEncode(out, rc, src[i])\n\t    last = src[i]\n\t}\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // External codec\n    decodeExt(stream, n_out) {\n\t// Bzip2 only for now\n\tvar output = new Buffer.allocUnsafe(n_out)\n\tvar bits = bzip2.array(stream.buf.slice(stream.pos))\n\tvar size = bzip2.header(bits)\n\tvar j = 0\n\tdo {\n\t    var chunk = bzip2.decompress(bits, size);\n\t    if (chunk != -1) {\n\t        Buffer.from(chunk).copy(output, j)\n\t        j += chunk.length\n\t\tsize -= chunk.length\n\t    }\n\t} while(chunk != -1);\n\n\treturn output\n    }\n\n    encodeExt(stream, n_out) {\n\t// We cannot compress using Bzip2 now as it's\n\t// absent from bzip2.js, but consider using\n\t// https://github.com/cscott/compressjs\n    }\n\n    //----------------------------------------------------------------------\n    // Order-0 RLE codec\n    decodeRLE0(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar model_lit = new ByteModel(max_sym);\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tvar i = 0;\n\twhile (i < n_out) {\n\t    output[i] = model_lit.ModelDecode(stream, rc)\n\t    var part = model_run[output[i]].ModelDecode(stream, rc)\n\t    var run = part\n\t    var rctx = 256\n\t    while (part == 3) {\n\t\tpart = model_run[rctx].ModelDecode(stream, rc)\n\t\trctx = 257\n\t\trun += part\n\t    }\n\t    for (var j = 1; j <= run; j++)\n\t\toutput[i+j] = output[i]\n\t    i += run+1\n\t}\n\n\treturn output;\n    }\n\n    encodeRLE0(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!\n\n\tvar model_lit = new ByteModel(max_sym);\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tvar i = 0\n\twhile (i < n_in) {\n\t    model_lit.ModelEncode(out, rc, src[i])\n\t    var run = 1\n\t    while (i+run < n_in && src[i+run] == src[i])\n\t\trun++\n\t    run--\n\n\t    var rctx = src[i]\n\t    var last = src[i]\n\t    i += run+1\n\n\t    var part = run >= 3 ? 3 : run\n\t    model_run[rctx].ModelEncode(out, rc, part)\n\t    run -= part\n\t    rctx = 256\n\t    while (part == 3) {\n\t\tpart = run >= 3 ? 3 : run\n\t\tmodel_run[rctx].ModelEncode(out, rc, part)\n\t\trctx = 257\n\t\trun -= part\n\t    }\n\t}\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // Order-1 RLE codec\n\n    decodeRLE1(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar model_lit = new Array(max_sym);\n\tfor (var i = 0; i < max_sym; i++)\n\t    model_lit[i] = new ByteModel(max_sym);\n\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tvar last = 0;\n\tvar i = 0;\n\twhile (i < n_out) {\n\t    output[i] = model_lit[last].ModelDecode(stream, rc)\n\t    last = output[i]\n\t    var part = model_run[output[i]].ModelDecode(stream, rc)\n\t    var run = part\n\t    var rctx = 256\n\t    while (part == 3) {\n\t\tpart = model_run[rctx].ModelDecode(stream, rc)\n\t\trctx = 257\n\t\trun += part\n\t    }\n\t    for (var j = 1; j <= run; j++)\n\t\toutput[i+j] = output[i]\n\t    i += run+1\n\t}\n\n\treturn output;\n    }\n\n    encodeRLE1(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!\n\n\tvar model_lit = new Array(max_sym)\n\tfor (var i = 0; i < max_sym; i++)\n\t    model_lit[i] = new ByteModel(max_sym);\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tvar i = 0\n\tvar last = 0\n\twhile (i < n_in) {\n\t    model_lit[last].ModelEncode(out, rc, src[i])\n\t    var run = 1\n\t    while (i+run < n_in && src[i+run] == src[i])\n\t\trun++\n\t    run--\n\n\t    var rctx = src[i]\n\t    last = src[i]\n\t    i += run+1\n\n\t    var part = run >= 3 ? 3 : run\n\t    model_run[rctx].ModelEncode(out, rc, part)\n\t    run -= part\n\t    rctx = 256\n\t    while (part == 3) {\n\t\tpart = run >= 3 ? 3 : run\n\t\tmodel_run[rctx].ModelEncode(out, rc, part)\n\t\trctx = 257\n\t\trun -= part\n\t    }\n\t}\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // Pack method\n    decodePackMeta(stream) {\n\tthis.nsym  = stream.ReadByte()\n\n\tvar M = new Array(this.nsym);\n\tfor (var i = 0; i < this.nsym; i++)\n\t    M[i] = stream.ReadByte()\n\n\tvar e_len = stream.ReadUint7(); // Could be derived data from nsym and n_out\n\n\treturn [M, e_len]\n    }\n\n    decodePack(data, M, len) {\n\tvar out = new Buffer.allocUnsafe(len);\n\n\tif (this.nsym <= 1) {\n\t    // Constant value\n\t    for (var i = 0; i < len; i++)\n\t\tout[i] = M[0]\n\n\t} else if (this.nsym <= 2) {\n\t    // 1 bit per value\n\t    for (var i = 0, j = 0; i < len; i++) {\n\t\tif (i % 8 == 0)\n\t\t    var v = data[j++]\n\t\tout[i] = M[v & 1]\n\t\tv >>= 1\n\t    }\n\n\t} else if (this.nsym <= 4) {\n\t    // 2 bits per value\n\t    for (var i = 0, j = 0; i < len; i++) {\n\t\tif (i % 4 == 0)\n\t\t    var v = data[j++]\n\t\tout[i] = M[v & 3]\n\t\tv >>= 2\n\t    }\n\n\t} else if (this.nsym <= 16) {\n\t    // 4 bits per value\n\t    for (var i = 0, j = 0; i < len; i++) {\n\t\tif (i % 2 == 0)\n\t\t    var v = data[j++]\n\t\tout[i] = M[v & 15]\n\t\tv >>= 4\n\t    }\n\n\t} else {\n\t    // 8 bits per value: NOP\n\t    return data\n\t}\n\n\treturn out\n    }\n\n    // Compute M array and return meta-data stream\n    packMeta(src) {\n\tvar stream = new IOStream(\"\", 0, 1024)\n\n\t// Count symbols\n\tvar M = new Array(256)\n\tfor (var i = 0; i < src.length; i++)\n\t    M[src[i]] = 1\n\n\t// Write Map\n\tfor (var nsym = 0, i = 0; i < 256; i++)\n\t    if (M[i])\n\t\tM[i] = ++nsym; // map to 1..N\n\tstream.WriteByte(nsym);\n\n\t// FIXME: add check for nsym > 16?\n\t// Or just accept it as an inefficient waste of time.\n\tfor (var i = 0; i < 256; i++) {\n\t    if (M[i]) {\n\t\tstream.WriteByte(i) // adjust to 0..N-1\n\t\tM[i]--;\n\t    }\n\t}\n\n\treturn [stream, M, nsym]\n    }\n\n    encodePack(data) {\n\tvar meta, M, nsym\n\t[meta, M, nsym] = this.packMeta(data)\n\n\tvar len = data.length\n\tvar i = 0;\n\tif (nsym <= 1) {\n\t    // Constant values\n\t    meta.WriteUint7(0)\n\t    return [meta, new Buffer.allocUnsafe(0), 0];\n\t}\n\n\tif (nsym <= 2) {\n\t    // 1 bit per value\n\t    var out = new Buffer.allocUnsafe(Math.floor((len+7)/8));\n\t    for (var i = 0, j = 0; i < (len & ~7); i+=8, j++)\n\t\tout[j] = (M[data[i+0]]<<0)\n\t\t       + (M[data[i+1]]<<1)\n\t\t       + (M[data[i+2]]<<2)\n\t\t       + (M[data[i+3]]<<3)\n\t\t       + (M[data[i+4]]<<4)\n\t\t       + (M[data[i+5]]<<5)\n\t\t       + (M[data[i+6]]<<6)\n\t\t       + (M[data[i+7]]<<7)\n\t    if (i < len) {\n\t\tout[j] = 0;\n\t\tvar v = 0;\n\t\twhile (i < len) {\n\t\t    out[j] |= M[data[i++]]<<v;\n\t\t    v++;\n\t\t}\n\t\tj++;\n\t    }\n\n\t    meta.WriteUint7(j)\n\t    return [meta, out, out.length]\n\t}\n\n\tif (nsym <= 4) {\n\t    // 2 bits per value\n\t    var out = new Buffer.allocUnsafe(Math.floor((len+3)/4));\n\t    for (var i = 0, j = 0; i < (len & ~3); i+=4, j++)\n\t\tout[j] = (M[data[i+0]]<<0)\n\t\t       + (M[data[i+1]]<<2)\n\t\t       + (M[data[i+2]]<<4)\n\t\t       + (M[data[i+3]]<<6)\n\n\t    if (i < len) {\n\t\tout[j] = 0;\n\t\tvar v = 0;\n\t\twhile (i < len) {\n\t\t    out[j] |= M[data[i++]]<<v;\n\t\t    v+=2;\n\t\t}\n\t\tj++;\n\t    }\n\n\t    meta.WriteUint7(j)\n\t    return [meta, out, out.length]\n\t}\n\n\tif (nsym <= 16) {\n\t    // 4 bits per value\n\t    var out = new Buffer.allocUnsafe(Math.floor((len+1)/2));\n\t    for (var i = 0, j = 0; i < (len & ~1); i+=2, j++)\n\t\tout[j] = (M[data[i+0]]<<0)\n\t\t       + (M[data[i+1]]<<4)\n\t    if (i < len)\n\t\tout[j++] = M[data[i++]];\n\n\t    meta.WriteUint7(j)\n\t    return [meta, out, out.length]\n\t}\n\n\t// Otherwise an expensive NOP\n\tmeta.WriteUint7(data.length)\n\treturn [meta, data, data.length]\n    }\n\n    //----------------------------------------------------------------------\n    // STRIPE method\n    encodeStripe(hdr, src, N) {\n    if (N == 0)\n\tN = 4; // old default\n\n\t// Split into multiple streams\n\tvar part = new Array(N)\n\tvar ulen = new Array(N)\n\tfor (var s = 0; s < N; s++) {\n\t    ulen[s] = Math.floor(src.length / N) + ((src.length % N) > s);\n\t    part[s] = new Array(ulen[s])\n\t}\n\n\tfor (var x = 0, i = 0; i < src.length; i+=N, x++) {\n\t    for (var j = 0; j < N; j++)\n\t\tif (x < part[j].length)\n\t\t    part[j][x] = src[i+j]\n\t}\n\n\t// Compress each part\n\tvar comp = new Array(N)\n\tvar total = 0\n\tfor (var s = 0; s < N; s++) {\n\t    // Example: try O0 and O1 and choose best\n\t    var comp0 = this.encode(part[s], 0)\n\t    var comp1 = this.encode(part[s], 1)\n\t    comp[s] = (comp1.length < comp0.length) ? comp1 : comp0\n\t    total += comp[s].length\n\t}\n\n\t// Serialise\n\tvar out = new IOStream(\"\", 0, total+5*N + 1)\n\tout.WriteByte(N)\n\tfor (var s = 0; s < N; s++)\n\t    out.WriteUint7(comp[s].length)\n\n\tfor (var s = 0; s < N; s++)\n\t    out.WriteData(comp[s], comp[s].length)\n\n\treturn out.buf.slice(0, out.buf.pos)\n    }\n\n    decodeStripe(stream, len) {\n\tvar N = stream.ReadByte()\n\t\n\t// Retrieve lengths\n\tvar clen = new Array(N)\n\tvar ulen = new Array(N)\n\tfor (var j = 0; j < N; j++)\n\t    clen[j] = stream.ReadUint7()\n\n\t// Decode streams\n\tvar T = new Array(N);\n\tfor (var j = 0; j < N; j++) {\n\t    ulen[j] = Math.floor(len / N) + ((len % N) > j)\n\t    T[j] = this.decodeStream(stream, ulen[j])\n\t}\n\n\t// Transpose\n\tvar out = new Buffer.allocUnsafe(len)\n\tfor (var j = 0; j < N; j++) {\n\t    for (var i = 0; i < ulen[j]; i++) {\n\t\tout[i*N + j] = T[j][i];\n\t    }\n\t}\n\n\treturn out\n    }\n\n    //----------------------------------------------------------------------\n    // Cat method\n    decodeCat(stream, len) {\n\tvar out = new Buffer.allocUnsafe(len);\n\tfor (var i = 0; i < len; i++)\n\t    out[i] = stream.ReadByte()\n\n\treturn out\n    }\n}\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// An arithmetic coder, based on Eugene Shelwien's reimplementation of\n// Michael Schindler range coder.\n//\n// Order-0 byte stream of ~/scratch/data/q40b\n// C:              3.1s decode  (approx same vs 32-bit and 64-bit)\n// Arith_sh.js     6.7s decode  (32-bit with carries)\n// Arith.js      317.0s decode  (64-bit no carries); int64 crippling it.\n\n//----------------------------------------------------------------------\n// Arithmetic (range) coder\nmodule.exports = class RangeCoder {\n    constructor(src) {\n\tthis.low   = 0;\n\tthis.range = 0xffffffff;\n\tthis.code  = 0;\n\tthis.FFnum = 0;\n\tthis.carry = 0;\n\tthis.cache = 0;\n    }\n\n    RangeStartDecode(src) {\n\tfor (var i = 0; i < 5; i++)\n\t    this.code = (this.code << 8) + src.ReadByte();\n\tthis.code &= 0xffffffff;\n\tthis.code >>>= 0; // force to be +ve int\n    }\n\n    RangeGetFrequency(tot_freq) {\n\tthis.range = Math.floor(this.range / tot_freq);\n\t//return this.code / this.range;\n\treturn Math.floor(this.code / this.range);\n\n\t// Conceptual scenario; return freq only and don't modify range yet\n\t//return Math.floor(this.code / (Math.floor(this.range / tot_freq)));\n    }\n\n    RangeDecode(src, sym_low, sym_freq, tot_freq) {\n\t// Conceptually we divide range here, but in practice we cached it earlier\n\t//this.range = Math.floor(this.range / tot_freq);\n\n\tthis.code  -= sym_low * this.range;\n\tthis.range *= sym_freq;\n\n\twhile (this.range < (1<<24)) {\n\t    this.range *= 256;\n\t    this.code = (this.code*256 + src.ReadByte());\n\t}\n    }\n\n    RangeShiftLow(dst) {\n\t// We know range is < (1<<24) as we got here.  We already have a\n\t// cached copy of 8 bits from low.  Is this correct, or does it need\n\t// fixing?  Possible scenarios.\n\t// 1. Low < 0xff000000 thus low+range < 0xffffffff and cache\n\t//    cannot possibly change.  Output cache and as many ffs as needed.\n\t// 2. We already detected an overflow in RangeEncode, setting carry.\n\t//    In this case output cached byte + 1 and any 00s needed.\n\t// 3. Neither case - range is low but we haven't yet detected if we're\n\t//    XXffffff or XY000000 scenario.  Increase counter for ff/00s.\n\n\tif (this.low < 0xff000000 | this.carry) {\n\t    // cached byte if no overflow, byte+1 otherwise\n\t    dst.WriteByte(this.cache + this.carry);\n\n\t    // Flush any tracked FFs (no carry) or 00s (carry).\n\t    while (this.FFnum) {\n\t\tdst.WriteByte(this.carry-1);\n\t\tthis.FFnum--;\n\t    }\n\n\t    // Take a copy of top byte ready for next flush\n\t    this.cache = this.low >>> 24;\n\t    this.carry = 0;\n\t} else {\n\t    this.FFnum++; // keep track of number of trailing ff/00 bytes to write\n\t}\n\tthis.low <<= 8;\n\tthis.low >>>= 0; // force to be +ve int\n    }\n\n    RangeEncode(dst, sym_low, sym_freq, tot_freq) {\n\tvar old_low = this.low\n\tthis.range  = Math.floor(this.range / tot_freq)\n\tthis.low   += sym_low * this.range;\n\tthis.low >>>= 0; // Truncate to +ve int so we can spot overflow\n\tthis.range *= sym_freq;\n\n\t// \"low + sym*range < old_low\" means we overflow; set carry.\n\t// NB: can this.low < old_low occur twice before range < (1<<24)?\n\t// We claim not, but prove it!\n\tif (this.low < old_low) {\n\t    if (this.carry != 0) console.log(\"ERROR: Multiple carry\")\n\t    this.carry = 1\n\t}\n\n\t// Renormalise if range gets too small\n\twhile (this.range < (1<<24)) {\n\t    this.range *= 256;\n\t    this.RangeShiftLow(dst);\n\t}\n    }\n\n    RangeFinishEncode(dst) {\n\tfor (var i = 0; i < 5; i++)\n\t    this.RangeShiftLow(dst)\n    }\n};\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// An adaptive probability model for encoding and decoding of symbols\n// within a given alphabet, using the range coder to get/put the\n// compressed data.\n\nconst MAX_FREQ = ((1<<16)-17)\nconst STEP     = 16\n\nmodule.exports = class ByteModel {\n    constructor(max_sym = 256) {\n\tthis.total_freq = max_sym;\n\tthis.max_sym = max_sym-1;\n\tthis.S = new Array\n\tthis.F = new Array\n\n\tfor (var i = 0; i <= this.max_sym; i++) {\n\t    this.S[i] = i;\n\t    this.F[i] = 1;\n\t}\n    }\n\n    ModelDecode(src, rc) {\n\t// Find symbol\n\tvar freq = rc.RangeGetFrequency(this.total_freq);\n\n\t// Linear scan to find cumulative frequency 'freq'\n\tvar acc = 0;\n\tvar x = 0;\n\twhile (acc + this.F[x] <= freq)\n\t    acc += this.F[x++];\n\n//\tfor (var acc = 0; (acc += this.F[x]) <= freq; x++)\n//\t    ;\n//\tacc -= this.F[x];\n\n\t// Update range coder\n\trc.RangeDecode(src, acc, this.F[x], this.total_freq);\n\n\t// Update model\n\tthis.F[x]       += STEP;\n\tthis.total_freq += STEP;\n\tif (this.total_freq > MAX_FREQ)\n\t    this.ModelRenormalise();\n\t\n\n\t// Keep symbols approximately frequency sorted\n\tvar sym = this.S[x];\n\tif (x > 0 && this.F[x] > this.F[x-1]) {\n\t    var tmp = this.F[x];\n\t    this.F[x] = this.F[x-1];\n\t    this.F[x-1] = tmp;\n\n\t    tmp = this.S[x];\n\t    this.S[x] = this.S[x-1];\n\t    this.S[x-1] = tmp;\n\t}\n\n\treturn sym;\n    }\n\n    ModelRenormalise() {\n\t// Halve all the frequencies, being careful not to hit zero\n\tthis.total_freq = 0;\n\tfor (var i = 0; i <= this.max_sym; i++) {\n\t    this.F[i] -= Math.floor(this.F[i] / 2);\n\t    this.total_freq += this.F[i];\n\t}\n    }\n\n    ModelEncode(dst, rc, sym) {\n\t// Find cumulative frequency\n\tvar acc = 0;\n\tfor (var x = 0; this.S[x] != sym; x++)\n\t    acc += this.F[x];\n\n\t// Encode\n\trc.RangeEncode(dst, acc, this.F[x], this.total_freq);\n\n\t// Update model\n\tthis.F[x]       += STEP;\n\tthis.total_freq += STEP;\n\tif (this.total_freq > MAX_FREQ) // FIXME x2\n\t    this.ModelRenormalise();\n\n\t// Keep symbols approximately frequency sorted\n\tvar sym = this.S[x];\n\tif (x > 0 && this.F[x] > this.F[x-1]) {\n\t    var tmp = this.F[x];\n\t    this.F[x] = this.F[x-1];\n\t    this.F[x-1] = tmp;\n\n\t    tmp = this.S[x];\n\t    this.S[x] = this.S[x-1];\n\t    this.S[x-1] = tmp;\n\t}\n    }\n};\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst IOStream = require(\"./iostream\");\nconst ByteModel = require(\"./byte_model\");\nconst RangeCoder = require(\"./arith_sh\");\n\n\n//----------------------------------------------------------------------\n// Main arithmetic entry function: decodes a compressed src and\n// returns the uncompressed buffer.\n\nfunction read_array(src, tab, size) {\n    var j = 0; // array value\n    var z = 0; // array index: tab[j]\n    var last = -1;\n\n    // Remove first level of run-length encoding\n    var R = new Array(1024) // runs\n    while (z < size) {\n\tvar run = src.ReadByte()\n\tR[j++] = run\n\tz += run\n\n\tif (run == last) {\n\t    var copy = src.ReadByte()\n\t    z += run * copy\n\t    while (copy--)\n\t\tR[j++] = run\n\t}\n\tlast = run\n    }\n\n    // Now expand runs in R to tab, noting 255 is max run\n    var i = 0\n    j = 0\n    z = 0\n    while (z < size) {\n\tvar run_len = 0\n\tdo {\n\t    var part = R[j++]\n\t    run_len += part\n\t} while (part == 255)\n\t\n\twhile (run_len--)\n\t    tab[z++] = i;\n\ti++\n    }\n}\n\nconst QMAX = 256\n\nconst FLAG_DEDUP  = 2\nconst FLAG_FLEN   = 4\nconst FLAG_SEL    = 8    // whether selector is used in context\nconst FLAG_QMAP   = 16\nconst FLAG_PTAB   = 32\nconst FLAG_DTAB   = 64\nconst FLAG_QTAB   = 128\n\nconst GFLAG_MULTI_PARAM = 1\nconst GFLAG_HAVE_STAB   = 2\nconst GFLAG_DO_REV      = 4\n\n// Compute a new context from our current state and qual q\nfunction fqz_update_ctx(params, state, q) {\n    var last = params.context\n    state.qctx = ((state.qctx << params.qshift) + params.qtab[q]); // >>> 0\n    last += ((state.qctx & ((1<<params.qbits)-1)) << params.qloc); // >>> 0\n\n    if (params.do_pos)\n\tlast += params.ptab[Math.min(state.p, 1023)] << params.ploc\n\n    if (params.do_delta) {\n\tlast += params.dtab[Math.min(state.delta, 255)] << params.dloc\n\t// Is it better to use q here or qtab[q]?\n\t// If qtab[q] we can map eg [a-z0-9A-Z]->0 ,->1 and have\n\t// delta being a token number count into comma separated lists?\n\tstate.delta += (state.prevq != q) ? 1 : 0\n\tstate.prevq = q\n    }\n\n    if (params.do_sel)\n\tlast += state.s << params.sloc\n\n    state.p--\n\n    return last & 0xffff\n}\n\nfunction decode_fqz_single_param(src) {\n    var p = {} // params\n    \n    // Load FQZ parameters\n    p.context = src.ReadUint16()\n    p.pflags  = src.ReadByte()\n\n    p.do_dedup  = p.pflags & FLAG_DEDUP\n    p.fixed_len = p.pflags & FLAG_FLEN\n    p.do_sel    = p.pflags & FLAG_SEL\n    p.do_qmap   = p.pflags & FLAG_QMAP\n    p.do_pos    = p.pflags & FLAG_PTAB\n    p.do_delta  = p.pflags & FLAG_DTAB\n    p.do_qtab   = p.pflags & FLAG_QTAB\n\n    p.max_sym = src.ReadByte()\n\n    var x = src.ReadByte()\n    p.qbits  = x>>4\n    p.qshift = x&15\n    x = src.ReadByte()\n    p.qloc = x>>4\n    p.sloc = x&15\n    x = src.ReadByte()\n    p.ploc = x>>4\n    p.dloc = x&15\n\n    // Qual map, eg to \"unbin\" Illumina qualities\n    p.qmap = new Array(256);\n    if (p.pflags & FLAG_QMAP) {\n\tfor (var i = 0; i < p.max_sym; i++)\n\t    p.qmap[i] = src.ReadByte()\n    } else {\n\t// Useful optimisation to speed up main loop\n\tfor (var i = 0; i < 256; i++)\n\t    p.qmap[i] = i;  // NOP\n    }\n\n    // Read tables\n    p.qtab = new Array(1024);\n    if (p.qbits > 0 && (p.pflags & FLAG_QTAB)) {\n\tread_array(src, p.qtab, 256)\n    } else {\n\t// Useful optimisation to speed up main loop\n\tfor (var i = 0; i < 256; i++)\n\t    p.qtab[i] = i;  // NOP\n    }\n\n    p.ptab = new Array(1024);\n    if (p.pflags & FLAG_PTAB)\n\tread_array(src, p.ptab, 1024);\n\n    p.dtab = new Array(256);\n    if (p.pflags & FLAG_DTAB)\n\tread_array(src, p.dtab, 256);\n\n    return p\n}\n\nfunction decode_fqz_params(src) {\n    var gparams = {\n\tmax_sym: 0\n    }\n\n    // Check fqz format version\n    var vers = src.ReadByte()\n    if (vers != 5) {\n\tconsole.error(\"Invalid FQZComp version number\");\n\treturn;\n    }\n\n    var gflags = src.ReadByte()\n    var nparam = (gflags & GFLAG_MULTI_PARAM) ? src.ReadByte() : 1\n    var max_sel = gflags.nparam > 1 ? gflags.nparam-1 : 0 // Note max_sel, not num_sel\n\n    var stab = new Array(256);\n    if (gflags & GFLAG_HAVE_STAB) {\n\tmax_sel = src.ReadByte()\n\tread_array(src, stab, 256);\n    } else {\n\tfor (var i = 0; i < nparam; i++)\n\t    stab[i] = i;\n\tfor (; i < 256; i++)\n\t    stab[i] = nparam-1;\n    }\n    gparams.do_rev = (gflags & GFLAG_DO_REV)\n    gparams.stab = stab\n    gparams.max_sel = max_sel\n\n    gparams.params = new Array(gparams.nparam)\n    for (var p = 0; p < nparam; p++) {\n\tgparams.params[p] = decode_fqz_single_param(src)\n\tif (gparams.max_sym < gparams.params[p].max_sym)\n\t    gparams.max_sym = gparams.params[p].max_sym\n    }\n\n    return gparams\n}\n\nfunction fqz_create_models(gparams) {\n    var model = {}\n\n    model.qual = new Array(1<<16)\n    for (var i = 0; i < (1<<16); i++)\n\tmodel.qual[i] = new ByteModel(gparams.max_sym+1) // +1 as max value not num. values\n\n    model.len = new Array(4)\n    for (var i = 0; i < 4; i++)\n\tmodel.len[i] = new ByteModel(256)\n\n    model.rev   = new ByteModel(2)\n    model.dup   = new ByteModel(2)\n\n    if (gparams.max_sel > 0)\n\tmodel.sel = new ByteModel(gparams.max_sel+1) // +1 as max value not num. values\n\n    return model\n}\n\n// Initialise a new record, updating state.\n// Returns 1 if dup, otherwise 0\nfunction decode_fqz_new_record(src, rc, gparams, model, state, rev) {\n    // Parameter selector\n    if (gparams.max_sel > 0) {\n\tstate.s = model.sel.ModelDecode(src, rc)\n    } else {\n\tstate.s = 0;\n    }\n    state.x = gparams.stab[state.s]\n\n    var params = gparams.params[state.x]\n\n    // Reset contexts at the start of each new record\n    if (params.fixed_len >= 0) {\n\t// Not fixed or fixed but first record\n\tvar len = model.len[0].ModelDecode(src, rc)\n\tlen |= model.len[1].ModelDecode(src, rc) << 8\n\tlen |= model.len[2].ModelDecode(src, rc) << 16\n\tlen |= model.len[3].ModelDecode(src, rc) << 24\n\tif (params.fixed_len > 0)\n\t    params.fixed_len = -len\n    } else {\n\tlen = -params.fixed_len\n    }\n    state.len = len\n\n    if (gparams.do_rev)\n\trev[state.rec] = model.rev.ModelDecode(src, rc)\n\n    state.is_dup = 0\n    if (params.pflags & FLAG_DEDUP) {\n\tif (model.dup.ModelDecode(src, rc))\n\t    state.is_dup = 1\n    }\n\n    state.p = len;  // number of remaining bytes in this record\n    state.delta = 0\n    state.qctx = 0\n    state.prevq = 0\n    state.rec++\n}\n\nfunction decode_fqz(src, q_lens) {\n    // Decode parameter block\n    var n_out = src.ReadUint7()\n    var gparams = decode_fqz_params(src)\n    if (!gparams) return\n    var params = gparams.params\n    var rev = new Array(q_lens.length)\n\n    // Create initial models\n    var model = fqz_create_models(gparams)\n\n    // Create our entropy encoder and output buffers\n    var rc = new RangeCoder(src)\n    rc.RangeStartDecode(src)\n    var output = new Buffer.allocUnsafe(n_out)\n\n    // Internal FQZ state\n    var state = {\n\tqctx:0,   // Qual-only sub-context\n\tprevq:0,  // Previous quality value\n\tdelta:0,  // Running delta (q vs prevq)\n\tp:0,      // Number of bases left in current record\n\ts:0,      // Current parameter selector value (0 if unused)\n\tx:0,      // \"stab\" tabulated copy of s\n\tlen:0,    // Length of current string\n\tis_dup:0, // This string is a duplicate of last\n\trec:0     // Record number\n    }\n\n    // The main decode loop itself\n    var i = 0     // position in output buffer\n    while (i < n_out) {\n\tif (state.p == 0) {\n\t    decode_fqz_new_record(src, rc, gparams, model, state, rev)\n\t    if (state.is_dup > 0) {\n\t\tif (model.dup.ModelDecode(src, rc)) {\n\t\t    // Duplicate of last line\n\t\t    for (var x = 0; x < len; x++)\n\t\t\toutput[i+x] = output[i+x-state.len]\n\t\t    i += state.len\n\t\t    state.p = 0\n\t\t    continue\n\t\t}\n\t    }\n\t    q_lens.push(state.len)\n\n\t    var params = gparams.params[state.x]\n\t    var last = params.context\n\t}\n\n\t// Decode the current quality (possibly mapped via qmap)\n\tvar Q = model.qual[last].ModelDecode(src, rc)\n\n\t//if (params.do_qmap)\n\t//    output[i++] = params.qmap[Q];\n\t//else\n\t//    output[i++] = Q\n\toutput[i++] = params.qmap[Q]; // optimised version of above\n\tlast = fqz_update_ctx(params, state, Q)\n    }\n\n    if (gparams.do_rev)\n\treverse_qualities(output, n_out, rev, q_lens)\n\n    return output;\n}\n\nfunction reverse_qualities(qual, qual_len, rev, len) {\n    var rec = 0\n    var i = 0\n    while (i < qual_len) {\n\tif (rev[rec]) {\n\t    var j = 0\n\t    var k = len[rec]-1\n\t    while (j < k) {\n\t\tvar tmp   = qual[i+j]\n\t\tqual[i+j] = qual[i+k]\n\t\tqual[i+k] = tmp\n\t\tj++\n\t\tk--\n\t    }\n\t}\n\n\ti += len[rec++];\n    }\n}\n\nfunction decode(src, q_lens) {\n    var stream = new IOStream(src);\n\n    //var n_out = stream.ReadUint32(); stream.ReadUint32(); // move to main\n\n    return decode_fqz(stream, q_lens);\n}\n    \n//----------------------------------------------------------------------\n// FQZComp encoder.\n\nfunction pick_fqz_params(src, q_lens, q_dirs, qhist) {\n    // Find cardinality of q_dirs\n    var qd_last = q_dirs[0];\n    for (var i = 0; i < q_dirs.length; i++)\n\tif (q_dirs[i] != qd_last)\n\t    break;\n    var qd_fixed = (i == q_dirs.length) ? 1 : 0\n\n    // Scan input to find number of symbols and max symbol\n    var nsym = 0\n    var max_sym = 0\n\n    // selector == 0: Assume one single input dataset\n    for (var i = 0; i < 256; i++)\n\tqhist[0][i] = 0;\n\n    var rec = 0;\n    var len = 0\n    for (var i = 0; i < src.length; i++) {\n\tif (len == 0) {\n\t    len = q_lens[rec < q_lens.length-1 ? rec++ : rec]\n\t}\n\tqhist[0][src[i]]++;\n\tlen--;\n    }\n    for (var i = 0; i < 256; i++) {\n\tif (!qhist[0][i])\n\t    continue;\n\tif (max_sym < i)\n\t    max_sym = i;\n\tnsym++;\n    }\n\n    var qshift = 5\n    var do_qmap = 0\n    // Reduced symbol frequencies implies lower qshift and\n    // a lookup table to go from qual to Q\n    if (nsym <= 16) {\n\tdo_qmap = 1 // based on qhist\n\tif (nsym <= 2)\n\t    qshift = 1\n\telse if (nsym <= 4)\n\t    qshift = 2\n\telse if (nsym <= 8)\n\t    qshift = 3\n\telse\n\t    qshift = 4\n    }\n\n//    // Two params and a 1-bit selector.\n//    // This is 1% overhead vs two data sets compressed independently.\n//    // It's 6.9% smaller than compressing both together with 1 param.\n//    if (0) return [{\n//\t// q4\n//\tqbits:     8,\n//\tqshift:    2,\n//\tqloc:      7,\n//\n//\tpbits:     7,\n//\tpshift:    1,\n//\tploc:      0,\n//\n//\tdbits:     0,\n//\tdshift:    0,\n//\tdloc:      0,\n//\n//      sbits:     0,\n//      sloc:      0,\n//\n//\t//sbits:     2,\n//\t//do_stab:   1,\n//\tsbits:     1,\n//\tdo_stab:   0,\n//\tcontext:   (0<<15),\n//\n//\tmax_sym:   36,\n//\tnsym:      4,\n//\n//\tdo_qmap:   1,\n//\tdo_dedup:  0,\n//\tfixed_len: 1,\n//\tdo_sel:  0,\n//\tdo_rev:    0,\n//\tdo_pos:    1,\n//\tdo_delta:  0,\n//\tdo_qtab:   0\n//    }, {\n//\t//q40\n//\tqbits:     9,\n//\tqshift:    5,\n//\tqloc:      7,\n//\n//\tpbits:     7,\n//\tpshift:    0,\n//\tploc:      0,\n//\n//\tdbits:     0,\n//\tdshift:    0,\n//\tdloc:      0,\n//\n//      sbits:     0,\n//      sloc:      0,\n//\n//\t//sbits:     2,\n//\t//do_stab:   1,\n//\tsbits:     1,\n//\tdo_stab:   0,\n//\tcontext:   (1<<15),\n//\n//\tmax_sym:   44,\n//\tnsym:      45,\n//\n//\tdo_qmap:   0,\n//\tdo_dedup:  0,\n//\tfixed_len: 1,\n//\tdo_sel:  0,\n//\tdo_rev:    0,\n//\tdo_pos:    1,\n//\tdo_delta:  0,\n//\tdo_qtab:   0\n//    }]\n\n    return [{qbits:     8+(qshift>4),\n\t     qshift:    qshift,\n\t     qloc:      7,\n\n\t     pbits:     7,\n\t     pshift:    q_lens[0] > 128 ? 1 : 0,\n\t     ploc:      0,\n\n\t     dbits:     qshift>4 ? 0 : 1,\n\t     dshift:    3,\n\t     dloc:      15,\n\n\n\t     // NB: Also useful as a way of embedding sel and doing sel\n\t     // specific contexts. Identical bar context. Eg 0<<15 or 1<<15.\n\t     sbits:     0,\n\t     sloc:      15,\n\t     do_stab:   0,\n\t     context:   (0<<15),\n\n\t     max_sym:   max_sym,\n\t     nsym:      nsym,\n\n\t     do_qmap:   do_qmap,\n\t     do_dedup:  0,\n\t     fixed_len: (q_lens.length == 1) ? 1 : 0,\n\t     do_sel:    0,\n\t     do_rev:    0,\n\t     do_pos:    1,\n\t     do_delta:  (qshift <= 4) ? 1 : 0,\n\t     do_qtab:   0,\n\n\t     // Override above with some attempt at using selectors\n\t     // when the q_dirs are specific and non-fixed.\n\t     qbits:     8+(qshift>4)-(qd_fixed==0),\n\t     sbits:     1,\n\t     sloc:      15-(qshift<=4), // read1 vs read2\n\t     do_stab:   1,\n\t     do_sel:    1,\n\t     \n//\t     // q4+dir: 7245769 with, 7353962 without. 1.5% saving\n//\t     qbits:     6,\n//\t     dbits:     2,\n//\t     dshift:    2,\n//\t     dloc:      13,\n//\t     sbits:     1,\n//\t     sloc:      15,\n//\t     do_stab:   1,\n//\t     do_sel:    1,\n\n\t     // with 20 bits of context, q40 = 31741545\n\t     // qbits 10, dbits 2, pbits 7, sbits 1\n\t    }]\n}\n\nfunction store_array(out, tab, size) {\n    var i = 0; // index into tab\n    var j = 0; // current value in tab[i]\n\n    var tmp1 = new Array(size*2);\n    var sz1 = 0;\n\n    // First level of RLE.  Replace all runs of 'j' values\n    // with run-lengths, including zeros for missing values.\n    // Eg 0 1 2 2 2 3 3 3 4 4 4 5 5 5 5   7 7\n    // to 1 1 3     3     3     4       0 2\n    while (i < size) {\n\t// Length of j^{th} element\n\tvar i_start = i\n\twhile (i < size && tab[i] == j)\n\t    i++;\n\tvar run_len = i - i_start\n\n\t// Encode run length to tmp array\n\tdo {\n\t    var r = Math.min(255, run_len)\n\t    tmp1[sz1++] = r\n\t    run_len -= r\n\t} while (r == 255)\n\tj++;\n    }\n\n    // Second round of RLE on our tmp array, using a different\n    // RLE algorithm.\n    // Eg 1 1    3 3  3 4 0 2\n    // to 1 1 +0 3 3 +1 4 0 2\n    var last = -1\n    var tmp2 = new Array(size*2)\n    var sz2 = 0\n    i = 0  // index into tmp1]\n    // k is used size of tmp1[]\n    while (i < sz1) {\n\tvar curr = tmp1[i++];\n\ttmp2[sz2++] = curr\n\tif (curr == last) {\n\t    var i_start = i;\n\t    while (i < sz1 && tmp1[i] == last && i - i_start < 255)\n\t\ti++;\n\t    tmp2[sz2++] = i - i_start;\n\t} else {\n\t    last = curr\n\t}\n    }\n\n    // Append 2nd RLE, tmp2, to out.\n    out.WriteData(tmp2, sz2)\n}\n\n\t\t\t\t     \n\n// q_lens is an array of quality lengths per record.\n// (If they're all the same, just set one value.)\nfunction encode_fqz_params(out, params, qhist, qtab, ptab, dtab, stab) {\n    var dsqr = [\n        0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,\n        4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7\n    ]\n\n    for (var i = 0; i < params.length; i++)\n\tstab[i] = i; // 1 parameter set per selector value\n    for (; i < 256; i++)\n\tstab[i] = params.length-1;\n\n    // Store global meta-data\n    out.WriteByte(5);            // FQZ format number\n    var gflags = ((params.length > 1) ? GFLAG_MULTI_PARAM : 0)\n\t       | ((params[0].do_stab) ? GFLAG_HAVE_STAB   : 0)\n    out.WriteByte(gflags)\n\n    if (gflags & GFLAG_MULTI_PARAM)\n\tout.WriteByte(params.length) // Number of parameter blocks.\n\n    if (gflags & GFLAG_HAVE_STAB) {\n\tvar max_sel = 1<<params[0].sbits;\n\tif (max_sel > 0) max_sel--;\n\tout.WriteByte(max_sel)\n\tstore_array(out, stab, 256)\n    }\n\n    // Store per-param meta-data\n    for (var p = 0; p < params.length; p++) {\n\tout.WriteUint16(params[p].context)\n\tout.WriteByte((params[p].do_qtab  ? FLAG_QTAB  : 0) |  // FLAG\n\t\t      (params[p].do_delta ? FLAG_DTAB  : 0) |\n\t\t      (params[p].do_pos   ? FLAG_PTAB  : 0) |\n\t\t      (params[p].do_qmap  ? FLAG_QMAP  : 0) |\n\t\t      (params[p].do_sel   ? FLAG_SEL   : 0) |\n\t\t      (params[p].fixed_len? FLAG_FLEN  : 0) |\n\t\t      (params[p].do_dedup ? FLAG_DEDUP : 0))\n\tif (params[p].do_qmap)\n\t    out.WriteByte(params[p].nsym)\n\telse\n\t    out.WriteByte(params[p].max_sym)\n\tout.WriteByte((params[p].qbits << 4) | (params[p].qshift))\n\tout.WriteByte((params[p].qloc  << 4) | (params[p].sloc))\n\tout.WriteByte((params[p].ploc  << 4) | (params[p].dloc))\n\n\tif (params[p].do_qmap) {\n\t    params[p].max_sym = params[p].nsym\n\t    var n = 0;\n\t    for (var i = 0; i < 256; i++) {\n\t\tif (qhist[p][i]) {\n\t\t    out.WriteByte(i)\n\t\t    qhist[p][i] = n++;\n\t\t}\n\t    }\n\t    // Ensure we have all matched input params\n\t    for (; n < params[p].nsym; n++)\n\t\tout.WriteByte(0)\n\t} else {\n\t    //params[p].nsym = 255;\n\t    for (var i = 0; i < 256; i++)\n\t\tqhist[p][i] = i; // NOP\n\t}\n\n\tif (params[p].qbits > 0) {\n\t    //\t// Eg map 0-44 to a smaller range, to improve context usage.\n\t    //\t// Makes q40 test set go from 33596471 to 33450075 (-0.4%)\n\t    //\tparams[p].do_qtab = 1;\n\t    //\tfor (var j = i = 0; i < params[p].max_sym; i++) {\n\t    //\t    qtab[i]=j;\n\t    //\t    if ((i%3)!=0 | i >= 28) j++\n\t    //\t    console.log(\"qtab[\",i,\"]=\",qtab[i]);\n\t    //\t}\n\t    //\tfor (; i < 256; i++)\n\t    //\t    qtab[i] = qtab[params[p].max_sym-1]\n\n\t    for (var i = 0; i < 256; i++)\n\t\tqtab[p][i] = i; // NOP for now\n\n\t    if (params[p].do_qtab)\n\t\tstore_array(out, qtab[p], 256)\n\t}\n\n\tif (params[p].pbits > 0) {\n\t    for (var i = 0; i < 1024; i++)\n\t\tptab[p][i] = Math.min((1<<params[p].pbits)-1, i >> params[p].pshift)\n\n\t    store_array(out, ptab[p], 1024)\n\t}\n\n\tif (params[p].dbits > 0) {\n\t    for (var i = 0; i < 256; i++)\n\t\tif (dsqr[i] > (1<<params[p].dbits) - 1)\n\t\t    dsqr[i] = (1<<params[p].dbits) - 1\n\t    for (var i = 0; i < 256; i++)\n\t\tdtab[p][i] = dsqr[Math.min(dsqr.length-1, i >> params[p].dshift)]\n\n\t    store_array(out, dtab[p], 256)\n\t}\n    }\n\n    return out\n}\n\nfunction encode_fqz(out, src, q_lens, q_dirs, params, qhist, qtab, ptab, dtab, stab) {\n    //console.error(\"0:\",params[0])\n    //console.error(\"1:\",params[1])\n\n    var max_sel = 1<<params[0].sbits\n    if (max_sel > 0) max_sel--\n    var n_in = src.length\n\n    // Create the models\n    var max_sym = 0;\n    for (var p = 0; p < params.length; p++)\n\tif (max_sym < params[p].max_sym)\n\t    max_sym = params[p].max_sym;\n\n    var model_qual = new Array(1<<16)\n    for (var i = 0; i < (1<<16); i++)\n\tmodel_qual[i] = new ByteModel(max_sym+1)\n\n    var model_len = new Array(4)\n    for (var i = 0; i < 4; i++)\n\tmodel_len[i] = new ByteModel(256)\n\n    var model_rev    = new ByteModel(2)\n    var model_dup    = new ByteModel(2)\n    var model_sel    = new ByteModel(max_sel+1)\n\n    // Note: our JavaScript encoder doesn't have a way for reversing\n    // some quality strings, so we ignore do_rev for now.\n    var rc = new RangeCoder(src)\n\n    // The main encoding loop\n    var p = 0; // remaining position along current record\n    var i = 0; // index in src data\n    var rec = 0;\n\n    while (i < n_in) {\n\tif (p == 0) {\n\t    //var s = 0 // single non-mixed sample\n\t    var s = q_dirs[rec]\n\t    if (params[0].sbits > 0) {// FIXME: check All params[].do_stab / sbits must be identical\n\t\t//console.log(\"Ssel\", s)\n\t        model_sel.ModelEncode(out, rc, s)\n\t    }\n\t    var x = stab[s]\n\n\t    // Reset contexts at the statr of each new record\n\t    var len = q_lens[Math.min(q_lens.length-1, rec++)]\n\t    if (params[x].fixed_len) {\n\t\tif (params[x].fixed_len > 0) { // First length\n\t\t    //console.log(\"Len\", len)\n\t\t    model_len[0].ModelEncode(out, rc, len       & 0xff)\n\t\t    model_len[1].ModelEncode(out, rc, (len>>8)  & 0xff)\n\t\t    model_len[2].ModelEncode(out, rc, (len>>16) & 0xff)\n\t\t    model_len[3].ModelEncode(out, rc, (len>>24) & 0xff)\n\t\t    params[x].fixed_len = -1; // indicate we've stored it once\n\t\t}\n\t    } else {\n\t\t//console.log(\"len\", len)\n\t\tmodel_len[0].ModelEncode(out, rc, len       & 0xff)\n\t\tmodel_len[1].ModelEncode(out, rc, (len>>8)  & 0xff)\n\t\tmodel_len[2].ModelEncode(out, rc, (len>>16) & 0xff)\n\t\tmodel_len[3].ModelEncode(out, rc, (len>>24) & 0xff)\n\t    }\n\n\t    if (params[x].do_dedup)\n\t\tprocess.exit(1) // FIXME\n\n\t    p = len\n\t    var delta = 0\n\t    //var last  = 0\n\t    var last  = params[x].context\n\t    var qlast = 0\n\t    var q1    = 0\n\t}\n\n\t// Encode current quality\n\tvar q = src[i++]\n\tvar Q = qhist[x][q]\n\tmodel_qual[last].ModelEncode(out, rc, Q)\n\t//console.log(\"Ctx\",last,qhist[x][q])\n\n\t// Update contexts for next quality\n\tqlast = (qlast << params[x].qshift) + qtab[x][Q]\n\tlast  = params[x].context\n\tlast += (qlast & ((1<<params[x].qbits)-1)) << params[x].qloc\n\n\t// 46.6-48.6 billion cycles with ifs + \"<< params[x].?loc\" shifts\n\t// 47.3-47.3 billion cycles with ifs\n\t// 47.1-47.9 billion cycles without ifs\n\tif (params[x].pbits > 0)\n\t    last += ptab[x][Math.min(p, 1023)] << params[x].ploc\n\n\tif (params[x].dbits > 0) {\n\t    last += dtab[x][Math.min(delta, 255)] << params[x].dloc\n\t    delta += (q1 != Q) ? 1 : 0\n\t    q1 = Q\n\t}\n\n\tif (params[x].do_sel)\n\t    last += s << params[x].sloc\n\n\tlast = (last & 0xffff)\n\tp--\n    }\n\n    rc.RangeFinishEncode(out)\n    return out.buf.slice(0, out.pos)\n}\n\nfunction encode(src, q_lens, q_dirs) {\n    var qhist = new Array(2)\n    var qtab  = new Array(2)\n    var ptab  = new Array(2)\n    var dtab  = new Array(2)\n    var stab  = new Array(256)\n\n    for (var s = 0; s < 2; s++) {\n        qhist[s] = new Array(256)\n        qtab[s]  = new Array(256)\n        ptab[s]  = new Array(1024) \n        dtab[s]  = new Array(256)\n    }\n\n    var out = new IOStream(\"\", 0, src.length*1.1 + 100); // FIXME: guestimate worst case\n\n    out.WriteUint7(src.length);\n    var params = pick_fqz_params(src, q_lens, q_dirs, qhist)\n    var out = encode_fqz_params(out, params, qhist, qtab, ptab, dtab, stab)\n    return encode_fqz(out, src, q_lens, q_dirs, params, qhist, qtab, ptab, dtab, stab)\n}\n\nmodule.exports = { decode, encode }\n","/*\n * Copyright (c) 2020 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This is an interface to the htscodecs reference implementation of\n// the CRAM 3.1 codecs.\n\n// This JavaScript file is not part of the reference implementation\n// and is simply and interface to get a consistent interface for cram-js.\n\n\"use strict\";\n\nvar r4x8    = require('./rans');\nvar r4x16   = require('./rans4x16');\nvar arith   = require('./arith_gen');\nvar fqzcomp = require('./fqzcomp');\nvar tok3    = require('./tok3');\n\nfunction r4x8_uncompress(inputBuffer, outputBuffer) {\n    r4x8.decode(inputBuffer).copy(outputBuffer, 0, 0);\n}\n\nfunction r4x16_uncompress(inputBuffer, outputBuffer) {\n    r4x16.decode(inputBuffer).copy(outputBuffer, 0, 0);\n}\n\nfunction arith_uncompress(inputBuffer, outputBuffer) {\n    arith.decode(inputBuffer).copy(outputBuffer, 0, 0);\n}\n\nfunction fqzcomp_uncompress(inputBuffer, outputBuffer) {\n    var q_lens = new Array\n    fqzcomp.decode(inputBuffer, q_lens).copy(outputBuffer, 0, 0);\n}\n\nfunction tok3_uncompress(inputBuffer, outputBuffer) {\n    // Returns in string form instead of buffer\n    var out = tok3.decode(inputBuffer, 0, '\\0');\n    Buffer.from(out, 'binary').copy(outputBuffer, 0, 0);\n}\n\nmodule.exports = {\n  r4x8_uncompress:    r4x8_uncompress,\n  r4x16_uncompress:   r4x16_uncompress,\n  arith_uncompress:   arith_uncompress,\n  fqzcomp_uncompress: fqzcomp_uncompress,\n  tok3_uncompress:    tok3_uncompress,\n};\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Turn a buffer into a fake stream with get / put commands.\n// This enables up to closely match the published pseudocode.\nmodule.exports = class IOStream {\n    constructor(buf, start_pos = 0, size = 0) {\n\tif (size != 0) {\n\t    this.buf = Buffer.allocUnsafe(size)\n\t    this.length = size\n\t} else {\n\t    this.buf = buf\n\t    this.length = buf.length\n\t}\n\tthis.pos = start_pos\n    }\n\n    // ----------\n    // Reading\n    EOF() {\n\treturn this.pos >= this.length\n    }\n\n    ReadData(len) {\n\tvar A = this.buf.slice(this.pos, this.pos+len)\n\tthis.pos += len;\n\treturn A\n    }\n\n    ReadByte() {\n\tconst b = this.buf[this.pos]\n\tthis.pos++\n\treturn b\n    }\n\n    ReadChar() {\n\tconst b = this.buf[this.pos]\n\tthis.pos++\n\treturn String.fromCharCode(b)\n    }\n\n    ReadUint16() {\n\tvar i = this.ReadByte()\n\ti |= this.ReadByte()<<8\n\treturn i\n    }\n\n    ReadUint32() {\n\tconst i = this.buf.readInt32LE(this.pos)\n\tthis.pos += 4\n\treturn i\n    }\n\n    // nul terminated string\n    ReadString() {\n\tvar s = \"\"\n\tdo {\n\t    var b = this.buf[this.pos++]\n\t    if (b)\n\t\ts += String.fromCharCode(b)\n\t} while (b)\n\treturn s\n    }\n\n//    ReadUint7() {\n//\t// Variable sized unsigned integers\n//\tvar i = 0;\n//\tvar s = 0;\n//\tdo {\n//\t    var c = this.ReadByte();\n//\t    i = i | ((c & 0x7f)<<s);\n//\t    s += 7;\n//\t} while ((c & 0x80))\n//\n//\treturn i;\n//    }\n\n    ReadUint7() {\n\t// Variable sized unsigned integers\n\tvar i = 0;\n\tdo {\n\t    var c = this.ReadByte();\n\t    i = (i<<7) | (c & 0x7f)\n\t} while ((c & 0x80))\n\n\treturn i;\n    }\n\n    ReadITF8() {\n\tvar i = this.buf[this.pos];\n\tthis.pos++;\n\n\t//process.stderr.write(\"i=\"+i+\"\\n\");\n\n\tif (i >= 0xf0) {\n\t    // 1111xxxx => +4 bytes\n\t    i = (i & 0x0f) << 28;\n\t    i += (this.buf[this.pos+0] << 20)\n\t      +  (this.buf[this.pos+1] << 12)\n\t      +  (this.buf[this.pos+2] <<  4)\n\t      +  (this.buf[this.pos+3] >>  4);\n\t    this.pos += 4;\n\t    //process.stderr.write(\"  4i=\"+i+\"\\n\");\n\t} else if (i >= 0xe0) {\n\t    // 1110xxxx => +3 bytes\n\t    i = (i & 0x0f) << 24;\n\t    i += (this.buf[this.pos+0] << 16)\n\t      +  (this.buf[this.pos+1] <<  8)\n\t      +  (this.buf[this.pos+2] <<  0);\n\t    this.pos += 3;\n\t    //process.stderr.write(\"  3i=\"+i+\"\\n\");\n\t} else if (i >= 0xc0) {\n\t    // 110xxxxx => +2 bytes\n\t    i = (i & 0x1f) << 16;\n\t    i += (this.buf[this.pos+0] << 8)\n\t      +  (this.buf[this.pos+1] << 0);\n\t    this.pos += 2;\n\t    //process.stderr.write(\"  2i=\"+i+\"\\n\");\n\t} else if (i >= 0x80) {\n\t    // 10xxxxxx => +1 bytes\n\t    i = (i & 0x3f) << 8;\n\t    i += this.buf[this.pos];\n\t    this.pos++;;\n\t    //process.stderr.write(\"  1i=\"+i+\"\\n\");\n\t} else {\n\t    // 0xxxxxxx => +0 bytes\n\t}\n\n\treturn i;\n    }\n\n    // ----------\n    // Writing\n    WriteByte(b) {\n\tthis.buf[this.pos++] = b\n    }\n\n    WriteChar(b) {\n\tthis.buf[this.pos++] = b.charCodeAt(0)\n    }\n\n    WriteString(str) {\n\tfor (var i = 0; i < str.length; i++)\n\t    this.buf[this.pos++] = str.charCodeAt(i)\n\tthis.buf[this.pos++] = 0\n    }\n\n    WriteData(buf, len) {\n\tfor (var i = 0; i < len; i++)\n\t    this.buf[this.pos++] = buf[i]\n    }\n\n    WriteStream(stream) {\n\tthis.WriteData(stream.buf, stream.pos)\n    }\n\n    WriteUint16(u) {\n\t//this.buf.writeInt16LE(u, this.pos);\n\tthis.WriteByte(u&0xff)\n\tthis.WriteByte((u>>8)&0xff)\n    }\n\n    WriteUint32(u) {\n\tthis.buf.writeInt32LE(u, this.pos);\n\tthis.pos += 4;\n    }\n\n//    WriteUint7(i) {\n//\tdo {\n//\t    this.WriteByte((i & 0x7f) | ((i > 0x80) << 7));\n//\t    i >>= 7;\n//\t} while (i > 0);\n//    }\n\n    WriteUint7(i) {\n\tvar s = 0;\n\tvar X = i;\n\tdo {\n\t    s += 7;\n\t    X >>= 7;\n\t} while (X > 0);\n\n\tdo {\n\t    s -= 7;\n\t    this.WriteByte(((i >> s) & 0x7f) + ((s > 0) << 7))\n\t} while (s > 0);\n    }\n\n    WriteITF8(i) {\n\t// Horrid, ITF8 is unsigned, but we still write signed into it\n\tif (i < 0)\n\t    i = (1<<32) + i\n\n\tif (i <= 0x0000007f) {\n\t    // 1 byte\n\t    this.buf[this.pos++] = i\n\t} else if (i <= 0x00003fff) {\n\t    // 2 bytes\n\t    this.buf[this.pos++] = 0x80 | Math.floor(i / 256)\n\t    this.buf[this.pos++] = i & 0xff;\n\t} else if (i < 0x0001ffff) {\n\t    // 3 bytes\n\t    this.buf[this.pos++] = 0xc0 | Math.floor(i / 65536)\n\t    this.buf[this.pos++] = Math.floor(i / 256) & 0xff\n\t    this.buf[this.pos++] = i & 0xff;\n\t} else if (i < 0x0fffffff) {\n\t    // 4 bytes\n\t    this.buf[this.pos++] = 0xe0 | Math.floor(i / 16777216)\n\t    this.buf[this.pos++] = Math.floor(i / 65536) & 0xff\n\t    this.buf[this.pos++] = Math.floor(i /   256) & 0xff\n\t    this.buf[this.pos++] = i & 0xff;\n\t} else {\n\t    // 5 bytes; oddly using 4.5 bytes\n\t    this.buf[this.pos++] = 0xf0 | Math.floor(i / 268435456)\n\t    this.buf[this.pos++] = Math.floor(i / 1048576) & 0xff\n\t    this.buf[this.pos++] = Math.floor(i /    4096) & 0xff\n\t    this.buf[this.pos++] = Math.floor(i /       4) & 0xff\n\t    this.buf[this.pos++] = i & 0x0f;\n\t}\n    }\n\n    // ----------\n    // Writing from end of buffer going backwards.\n    // Needed by rANS codec.\n    WriteByteNeg(b) {\n\tthis.buf[--this.pos] = b;\n    }\n};\n","/*\n * Copyright (c) 2019-2020 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst IOStream = require(\"./iostream\");\n\n//----------------------------------------------------------------------\n// rANS primitives itself\n//\n// RansGet* is decoder side\n\nfunction RansGetCumulativeFreq(R) {\n    return R & 0xfff;\n}\n\nfunction RansGetSymbolFromFreq(C, f) {\n    // NOTE: Inefficient.\n    // In practice we would implement this via a precomputed\n    // lookup table C2S[f]; see RansBuildC2S below.\n    var s = 0;\n    while (f >= C[s+1])\n\ts++;\n\n    return s;\n}\n\nfunction RansBuildC2S(C) {\n    var C2S = new Array(0x1000);\n    var s = 0;\n    for (var f = 0; f < 0x1000; f++) {\n\twhile (f >= C[s+1])\n\t    s++;\n\tC2S[f] = s;\n    }\n    return C2S;\n}\n\nfunction RansAdvanceStep(R, c, f) {\n    return f * (R >> 12) + (R & 0xfff) - c;\n}\n\nfunction RansRenorm(src, R) {\n    while (R < (1<<23))\n\tR = (R << 8) + src.ReadByte();\n\n    return R;\n}\n\n\n// RanEnc* is for encoder\nfunction RansEncInit() {\n    return 1<<23;\n}\n\nfunction RansEncFlush(R, dst) {\n    dst.WriteByteNeg((R >> 24) & 0xff);\n    dst.WriteByteNeg((R >> 16) & 0xff);\n    dst.WriteByteNeg((R >>  8) & 0xff);\n    dst.WriteByteNeg((R >>  0) & 0xff);\n}\n\nfunction RansEncRenorm(R, dst, freq, scale_bits) {\n    var R_max = (((1 << 23) >> scale_bits) << 8) * freq;\n\n    while (R >= R_max) {\n\tdst.WriteByteNeg(R & 0xff);\n\tR >>= 8;\n    }\n    return R;\n}\n\n// Puts a symbol with frequency freq, cumulative freq start\n// and total freq 1<<scale_bits.\n//\n// Note with static probabilities, /freq and %freq could be\n// precomputed via multiplies and shifts.\nfunction RansEncPut(R, dst, start, freq, scale_bits) {\n    var scale = 1<<scale_bits;\n    R = RansEncRenorm(R, dst, freq, scale_bits);\n    R = (Math.floor(R / freq) << scale_bits) + (R % freq) + start;\n    return R;\n}\n\n//----------------------------------------------------------------------\n// Main rANS entry function: decodes a compressed src and\n// returns the uncompressed buffer.\nfunction decode(src) {\n    var stream = new IOStream(src);\n    var order = stream.ReadByte();\n    var n_in  = stream.ReadUint32();\n    var n_out = stream.ReadUint32();\n\n    if (order == 0) {\n\treturn RansDecode0(stream, n_out)\n    } else {\n\treturn RansDecode1(stream, n_out)\n    }\n}\n\nfunction encode(src, order) {\n    //var stream = new IOStream(src);\n    //var n_in  = stream.ReadUint32();\n    //var n_out = stream.ReadUint32();\n\n    if (order == 0) {\n\treturn RansEncode0(src)\n    } else {\n\treturn RansEncode1(src)\n    }\n}\n\n//----------------------------------------------------------------------\n// Order-0 decoder\n\n// Decode a single table of order-0 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies0(src, F, C) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    var sym = src.ReadByte();\n    var last_sym = sym;\n    var rle = 0;\n\n    // Read F[]\n    do {\n\tvar f = src.ReadITF8();\n\tF[sym] = f;\n\tif (rle > 0) {\n\t    rle--;\n\t    sym++;\n\t} else {\n\t    sym = src.ReadByte();\n\t    if (sym == last_sym+1)\n\t\trle = src.ReadByte();\n\t}\n\tlast_sym = sym;\n    } while (sym != 0);\n\n    // Compute C[] from F[]\n    C[0] = 0;\n    for (var i = 0; i <= 255; i++)\n\tC[i+1] = C[i] + F[i];\n}\n\nfunction RansDecode0(src, nbytes) {\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies0(src, F, C);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = RansBuildC2S(C);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = src.ReadUint32();\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    for (var i = 0; i < nbytes; i++) {\n\tvar i4 = i%4;\n\tvar f = RansGetCumulativeFreq(R[i4]);\n\tvar s = C2S[f]; // Equiv to RansGetSymbolFromFreq(C, f);\n\n\toutput[i] = s;\n\tR[i4] = RansAdvanceStep(R[i4], C[s], F[s]);\n\tR[i4] = RansRenorm(src, R[i4]);\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-0 encoder\n\nfunction BuildFrequencies0(src, F) {\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    for (var i = 0; i < src.length; i++)\n\tF[src[i]]++;\n}\n\nfunction NormaliseFrequencies0(F) {\n    // Compute total\n    var tot = 0;\n    for (var i = 0; i < 256; i++)\n\ttot += F[i];\n\n    // Scale total of frequencies to max\n    const max = (1<<12);\n    var scale = max / tot;\n    do {\n\tvar max_val = 0;\n\tvar max_idx = 0;\n\tvar renorm = 0;\n\ttot = 0;\n\tfor (var i = 0; i < 256; i++) {\n\t    if (F[i] == 0)\n\t\tcontinue\n\n\t    if (max_val < F[i]) {\n\t\tmax_val = F[i]\n\t\tmax_idx = i\n\t    }\n\n\t    F[i] = Math.floor(F[i] * scale);\n\t    if (F[i] == 0)\n\t\tF[i] = 1;\n\n\t    tot += F[i];\n\t}\n\n\t// Adjust new tot to ensure it matches.\n\tif (tot < max) {\n\t    // Too low, boost the most common symbol\n\t    F[max_idx] += max-tot;\n\t} else if (tot-max < F[max_idx]/2 && F[max_idx] > 2) {\n\t    // Too high, reduce the common symbol\n\t    F[max_idx] -= tot-max;\n\t} else if (tot != max) {\n\t    // Much too high, fudge scale and try again.\n\t    scale = scale * 0.99\n\t    renorm = 1;\n\t}\n    } while (renorm)\n}\n\nfunction WriteFrequencies0(out, F) {\n    var rle = 0;\n    for (var i = 0; i < 256; i++) {\n\tif (!F[i])\n\t    continue\n\n\t// Output Symbol if needed and Frequency\n\tif (rle > 0)\n\t    rle--\n\telse {\n\t    out.WriteByte(i)\n\n\t    if (i > 0 && F[i-1] > 0) {\n\t\t// We've encoded two symbol frequencies in a row.\n\t\t// How many more are there?  Store that count so\n\t\t// we can avoid writing consecutive symbols.\n\t\tfor (rle = i+1; rle<256 && F[rle]; rle++)\n\t\t    ;\n\t\trle -= i+1;\n\n\t\tout.WriteByte(rle);\n\t    }\n\t}\n\n\tout.WriteITF8(F[i])\n    }\n    out.WriteByte(0);\n}\n\nfunction RansEncode0(src) {\n    const nbytes = src.length\n    var output = new IOStream(\"\", 0, 257*3+9);\n\n    output.WriteByte(0);   // Order 0\n    output.WriteUint32(0); // compressed size: correct later\n    output.WriteUint32(0); // uncompressed size: correct later\n\n    // Compute frequencies\n    var F = new Array(256)\n    BuildFrequencies0(src, F)\n    NormaliseFrequencies0(F);\n    WriteFrequencies0(output, F);\n\n    // Compute cumulative frequencies\n    var C = new Array(256)\n    C[0] = 0;\n    for (var i = 1; i < 256; i++)\n\tC[i] = C[i-1] + F[i-1];\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = RansEncInit();\n\n    var alloc = Math.floor(nbytes*1.05+100)\n    var rans_out = new IOStream(\"\", alloc, alloc)\n\n    // Main encode loop\n    for (var i = nbytes-1; i >= 0; i--)\n\tR[i%4] = RansEncPut(R[i%4], rans_out, C[src[i]], F[src[i]], 12);\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    var freq_tab = output.pos\n    output.buf.writeInt32LE(freq_tab-9 + (rans_out.length - rans_out.pos), 1);\n    output.buf.writeInt32LE(nbytes, 5);\n\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\n//----------------------------------------------------------------------\n// Order-1 decoder\n\n// Decode a table of order-1 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies1(src, F, C) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    var sym = src.ReadByte();\n    var last_sym = sym;\n    var rle = 0;\n\n    // Read F[]\n    do {\n\tReadFrequencies0(src, F[sym], C[sym]);\n\n\tif (rle > 0) {\n\t    rle--;\n\t    sym++;\n\t} else {\n\t    sym = src.ReadByte();\n\t    if (sym == last_sym+1)\n\t\trle = src.ReadByte();\n\t}\n\tlast_sym = sym;\n    } while (sym != 0);\n}\n\nfunction RansDecode1(src, nbytes) {\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies1(src, F, C);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = new Array(256);\n    for (var i = 0; i < 256; i++)\n\tC2S[i] = RansBuildC2S(C[i]);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = src.ReadUint32();\n\tL[j] = 0;\n    }\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    var nbytes4 = Math.floor(nbytes/4);\n    for (var i = 0; i < nbytes4; i++) {\n\tfor (var j = 0; j < 4; j++) {\n\t    var f = RansGetCumulativeFreq(R[j]);\n\n\t    //var s = RansGetSymbolFromFreq(C[L[j]], f);\n\t    var s = C2S[L[j]][f]; // Precomputed version of above\n\n\t    output[i+j*nbytes4] = s;\n\t    R[j] = RansAdvanceStep(R[j], C[L[j]][s], F[L[j]][s]);\n\t    R[j] = RansRenorm(src, R[j]);\n\t    L[j] = s;\n\t}\n    }\n\n    // Now deal with the remainder if buffer size is not a multiple of 4,\n    // using rANS state 3 exclusively.  (It'd have been nice to have\n    // designed this to just act as if we kept going with a bail out.)\n    i = 4*i;\n    while (i < nbytes) {\n\tvar f = RansGetCumulativeFreq(R[3]);\n\tvar s = RansGetSymbolFromFreq(C[L[3]], f);\n\toutput[i++] = s;\n\tR[3] = RansAdvanceStep(R[3], C[L[3]][s], F[L[3]][s]);\n\tR[3] = RansRenorm(src, R[3]);\n\tL[3] = s;\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-1 encoder\n\nfunction BuildFrequencies1(src, F, F0) {\n    for (var i = 0; i < 256; i++) {\n\tF0[i] = 0;\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    var last = 0;\n    for (var i = 0; i < src.length; i++) {\n\tF0[src[i]]++;\n\tF[last][src[i]]++;\n\t//F[last][src[i]]++;\n\tlast = src[i];\n    }\n\n    // Also accept we'll be starting at 4 points, not just byte 0\n    F[0][src[1*(src.length >> 2)]]++;\n    F[0][src[2*(src.length >> 2)]]++;\n    F[0][src[3*(src.length >> 2)]]++;\n    F0[0] += 3;\n}\n\nfunction NormaliseFrequencies1(F, F0) {\n    for (var i = 0; i < 256; i++)\n\tif (F0[i])\n\t    NormaliseFrequencies0(F[i])\n}\n\nfunction WriteFrequencies1(out, F, F0) {\n    var rle = 0;\n    var last_sym = 0;\n\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue\n\n\t// Output Symbol if needed and Frequency\n\tif (rle > 0)\n\t    rle--\n\telse {\n\t    out.WriteByte(i)\n\n\t    if (i > 0 && F0[i-1] > 0) {\n\t\tfor (rle = i+1; rle<256 && F0[rle]; rle++)\n\t\t    ;\n\t\trle -= i+1;\n\t\tout.WriteByte(rle);\n\t    }\n\t}\n\n\tWriteFrequencies0(out, F[i]);\n    }\n    out.WriteByte(0);\n}\n\nfunction RansEncode1(src) {\n    const nbytes = src.length;\n    var output = new IOStream(\"\", 0, 257*257*3+9);\n\n    output.WriteByte(1);   // Order 0\n    output.WriteUint32(0); // compressed size: correct later\n    output.WriteUint32(0); // uncompressed size: correct later\n\n    // Compute frequencies\n    var F0 = new Array(256)\n    var F = new Array(256)\n    var C = new Array(256)\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n    }\n\n    BuildFrequencies1(src, F, F0)\n    NormaliseFrequencies1(F, F0);\n    WriteFrequencies1(output, F, F0);\n\n    // Compute cumulative frequencies\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue;\n\n\tC[i][0] = 0;\n\tfor (var j = 1; j < 256; j++)\n\t    C[i][j] = C[i][j-1] + F[i][j-1];\n    }\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = RansEncInit();\n\tL[j] = 0;\n    }\n    var rans_out = new IOStream(\"\", nbytes, nbytes);\n\n    // We have 4 rans codecs running in parallel on its own 1/4tr of buffer\n    var nbytes4 = Math.floor(nbytes/4);\n    var idx = new Array(4);\n    var last = new Array(4)\n    for (var j = 0; j < 4; j++) {\n\tidx[j] = (j+1)*nbytes4 - 2;\n\tlast[j] = src[idx[j]+1]\n    }\n\n    // Deal with the remainder if not a multiple of 4\n    last[3] = src[nbytes-1];\n    for (var i = nbytes-2; i > 4*nbytes4-2; i--) {\n\tR[3] = RansEncPut(R[3], rans_out, C[src[i]][last[3]], F[src[i]][last[3]], 12);\n\tlast[3] = src[i];\n    }\n\n    // Main encode loop\n    while (idx[0] >= 0) {\n\tfor (var j = 3; j >= 0; j--) {\n\t    var s = src[idx[j]]\n\t    R[j] = RansEncPut(R[j], rans_out, C[s][last[j]], F[s][last[j]], 12);\n\t    last[j] = s;\n\t    idx[j]--;\n\t}\n    }\n\n    for (var j = 3; j >= 0; j--) {\n        R[j] = RansEncPut(R[j], rans_out, C[0][last[j]], F[0][last[j]], 12)\n    }\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    var freq_tab = output.pos;\n    output.buf.writeInt32LE(freq_tab-9 + (rans_out.length - rans_out.pos), 1);\n    output.buf.writeInt32LE(nbytes, 5);\n\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\nmodule.exports = { decode, encode }\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst IOStream = require(\"./iostream\");\n\n//----------------------------------------------------------------------\n// rANS primitives itself\n//\n// RansGet* is decoder side\n\nfunction RansGetCumulativeFreq(R, bits) {\n    return R & ((1<<bits)-1)\n}\n\nfunction RansGetSymbolFromFreq(C, f) {\n    // NOTE: Inefficient.\n    // In practice we would implement this via a precomputed\n    // lookup table C2S[f]; see RansBuildC2S below.\n    var s = 0;\n    while (f >= C[s+1])\n\ts++;\n\n    //console.error(f, C, s)\n\n    return s;\n}\n\nfunction RansBuildC2S(C, bits) {\n    var max = 1<<bits\n    var C2S = new Array(max);\n    var s = 0;\n    for (var f = 0; f < max; f++) {\n\twhile (f >= C[s+1])\n\t    s++;\n\tC2S[f] = s;\n    }\n    return C2S;\n}\n\nfunction RansAdvanceStep(R, c, f, bits) {\n    return f * (R >> bits) + (R & ((1<<bits)-1)) - c;\n}\n\nfunction RansRenorm(src, R) {\n    if (R < (1<<15))\n\tR = (R << 16) + src.ReadUint16();\n\n    return R;\n}\n\n\n// RanEnc* is for encoder\nfunction RansEncInit() {\n    return 1<<15;\n}\n\nfunction RansEncFlush(R, dst) {\n    dst.WriteByteNeg((R >> 24) & 0xff);\n    dst.WriteByteNeg((R >> 16) & 0xff);\n    dst.WriteByteNeg((R >>  8) & 0xff);\n    dst.WriteByteNeg((R >>  0) & 0xff);\n}\n\nfunction RansEncRenorm(R, dst, freq, scale_bits) {\n    //var R_max = (((1 << 15) >> scale_bits) << 16) * freq;\n    var R_max = (1 << (31-scale_bits)) * freq\n\n    while (R >= R_max) {\n\tdst.WriteByteNeg((R>>8) & 0xff);\n\tdst.WriteByteNeg(R & 0xff);\n\tR >>= 16;\n    }\n    return R;\n}\n\n// Puts a symbol with frequency freq, cumulative freq start\n// and total freq 1<<scale_bits.\n//\n// Note with static probabilities, /freq and %freq could be\n// precomputed via multiplies and shifts.\nfunction RansEncPut(R, dst, start, freq, scale_bits) {\n    var scale = 1<<scale_bits;\n    R = RansEncRenorm(R, dst, freq, scale_bits);\n    R = (Math.floor(R / freq) << scale_bits) + (R % freq) + start;\n    return R;\n}\n\n\n//----------------------------------------------------------------------\n// Run length encoding\nfunction EncodeRLE(src) {\n    // Step 1: find which symbols benefit from RLE\n    var L = new Array(256)\n    for (var i = 0; i < 256; i++)\n\tL[i] = 0\n\n    var last = -1\n    for (var i = 0; i < src.length; i++) {\n\tL[src[i]] += src[i] == last ? 1 : -1\n\tlast = src[i]\n    }\n\n    var nrle = 0;\n    for (var i = 0; i < 256; i++)\n\tif (L[i] > 0)\n\t    nrle++\n\n    if (!nrle) {\n\t// Format cannot cope with zero RLE symbols, so pick one!\n\tnrle = 1;\n\tL[0] = 1;\n    }\n\n    // Start meta-data as list of symbols to RLE\n    var meta = new IOStream(\"\", 0, nrle+1 + src.length)\n    meta.WriteByte(nrle)\n    for (var i = 0; i < 256; i++)\n\tif (L[i] > 0)\n\t    meta.WriteByte(i)\n\n    // Step 2: Now apply RLE itself\n    var data = new Buffer.allocUnsafe(src.length)\n    var dpos = 0\n    for (var i = 0; i < src.length; i++) {\n\tdata[dpos++] = src[i]\n\tif (L[src[i]] > 0) {\n\t    last = src[i];\n\t    var run = 0;\n\t    while (i+run+1 < src.length && src[i+run+1] == last)\n\t\trun++;\n\t    meta.WriteUint7(run)\n\t    i += run\n\t}\n    }\n\n    // Compress the meta-data\n    var cmeta = RansEncode0(meta.buf.slice(0, meta.pos))\n    var hdr = new IOStream(\"\", 0, 16)\n    hdr.WriteUint7(meta.pos*2)   // Uncompressed meta-data length + compressed-bit-flag(0)\n    hdr.WriteUint7(dpos)         // Length of RLE encoded data\n    hdr.WriteUint7(cmeta.length) // Compressed meta-data length\n    var meta = Buffer.concat([hdr.buf.slice(0,hdr.pos), cmeta])\n\n    return [meta, data.slice(0, dpos)]\n}\n\nfunction DecodeRLEMeta(src) {\n    var u_meta_len = src.ReadUint7()\n    var rle_len = src.ReadUint7()\n\n    // Decode RLE lengths\n    if (u_meta_len & 1) {\n\tvar rle_meta = src.ReadData((u_meta_len-1)/2)\n    } else {\n\tvar comp_meta_len = src.ReadUint7()\n\tvar rle_meta = src.ReadData(comp_meta_len)\n\trle_meta = RansDecode0(new IOStream(rle_meta), u_meta_len/2)\n    }\n\n    // Decode list of symbols for which RLE lengths are applied\n    var rle_meta = new IOStream(rle_meta)\n    var L = new Array(256)\n    var n = rle_meta.ReadByte()\n    if (n == 0)\n\tn = 256;\n    for (var i = 0; i < n; i++)\n\tL[rle_meta.ReadByte()] = 1\n\n    return [L, rle_meta, rle_len]\n}\n\nfunction DecodeRLE(buf, L, rle_meta, len) {\n    var src = new IOStream(buf);\n\n    var out = new Buffer.allocUnsafe(len)\n\n    // Expand up buf+meta to out; i = buf index, j = out index\n    var j = 0;\n    for (var i = 0; j < len; i++) {\n\tvar sym = buf[i];\n\tif (L[sym]) {\n\t    var run = rle_meta.ReadUint7()\n\t    for (var r = 0; r <= run; r++)\n\t\tout[j++] = sym\n\t} else {\n\t    out[j++] = sym\n\t}\n    }\n\n    return out\n}\n\n//----------------------------------------------------------------------\n// Bit packing\n\nfunction EncodePack(src) {\n    // Step 1: identify number of distinct symbols\n    var F = new Array(256)\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0\n\n    for (var i = 0; i < src.length; i++)\n\tF[src[i]]++\n\n    var P = new Array(256)\n    var nsym = 0;\n    for (var i = 0; i < 256; i++)\n\tif (F[i] > 0)\n\t    P[i] = nsym++\n\n    if (nsym > 16) {\n\t//console.error(\"Too many symbols to pack:\",nsym)\n\treturn\n    }\n\n\n    // Pack data\n    if (nsym <= 1) {\n\t// Constant\n\tvar data = new Buffer.allocUnsafe(0)\n    }\n\n    else if (nsym <= 2) {\n\t// 1 bit per value\n\tvar data = new Buffer.allocUnsafe(Math.ceil(src.length/8))\n\tvar j = -1\n\tfor (i = 0; i < src.length; i++) {\n\t    if (i % 8 == 0)\n\t\tdata[++j] = 0\n\t    data[j] += P[src[i]] << (i % 8)\n\t}\n    }\n\n    else if (nsym <= 4) {\n\t// 2 bits per value\n\tvar data = new Buffer.allocUnsafe(Math.ceil(src.length/4))\n\tvar j = -1\n\tfor (i = 0; i < src.length; i++) {\n\t    if (i % 4 == 0)\n\t\tdata[++j] = 0\n\t    data[j] += P[src[i]] << ((i % 4) * 2)\n\t}\n    }\n\n    else {\n\t// 4 bits per value\n\tvar data = new Buffer.allocUnsafe(Math.ceil(src.length/2))\n\tvar j = -1\n\tfor (i = 0; i < src.length; i++) {\n\t    if (i % 2 == 0)\n\t\tdata[++j] = 0\n\t    data[j] += P[src[i]] << ((i % 2) * 4)\n\t}\n    }\n\n\n    // Produce pack meta-data\n    var meta = new IOStream(\"\", 0, nsym+5)\n    meta.WriteByte(nsym)\n    var j = 0\n    for (var i = 0; i < 256; i++) {\n\tif (F[i] > 0) {\n\t    F[i] = j++;\n\t    meta.WriteByte(i)\n\t}\n    }\n    meta.WriteUint7(data.length)\n\n    return [meta.buf.slice(0, meta.pos), data]\n}\n\n\n// Pack meta data is the number and value of distinct symbols plus\n// the length of the packed byte stream.\nfunction DecodePackMeta(src) {\n    var nsym = src.ReadByte()\n    var P = new Array(nsym)\n\n    for (var i = 0; i < nsym; i++)\n\tP[i] = src.ReadByte()\n\n    var len = src.ReadUint7()\n\n    return [P, nsym, len]\n}\n\n// Extract bits from src producing output of length len.\n// Nsym is number of distinct symbols used.\nfunction DecodePack(data, P, nsym, len) {\n    var out = new Buffer.allocUnsafe(len)\n    var j = 0;\n\n    // Constant value\n    if (nsym <= 1) {\n\tfor (var i = 0; i < len; i++)\n\t    out[i] = P[0]\n    }\n\n    // 1 bit per value\n    else if (nsym <= 2) {\n\tfor (i = 0; i < len; i++) {\n\t    if (i % 8 == 0)\n\t\tvar v = data[j++];\n\n\t    out[i] = P[v & 1]\n\t    v >>= 1\n\t}\n    }\n\n    // 2 bits per value\n    else if (nsym <= 4) {\n\tfor (i = 0; i < len; i++) {\n\t    if (i % 4 == 0)\n\t\tvar v = data[j++];\n\n\t    out[i] = P[v & 3]\n\t    v >>= 2\n\t}\n    }\n\n    // 4 bits per value\n    else if (nsym <= 16) {\n\tfor (i = 0; i < len; i++) {\n\t    if (i % 2 == 0)\n\t\tvar v = data[j++];\n\n\t    out[i] = P[v & 15]\n\t    v >>= 4\n\t}\n    }\n\n    return out\n}\n\n\n//----------------------------------------------------------------------\n// 4 way interleaving.\n// This is simply 4 rANS streams interleaved to form bytes 0,4,8...,\n// 1,5,9..., 2,6,10... and 3,7,11...\n//\n// It works well when the distributions differ for each of the 4 bytes,\n// for example when compressing a series of 32-bit integers.\n//\n// Maybe make this more general purpose of X* where we specify the stripe\n// size instead of fixing it at 4?\nfunction RansEncodeStripe(hdr, src, N) {\n    if (N == 0)\n\tN = 4; // old default\n\n    // Split into multiple streams\n    var part = new Array(N)\n    var ulen = new Array(N)\n    for (var s = 0; s < N; s++) {\n\tulen[s] = Math.floor(src.length / N) + ((src.length % N) > s);\n\tpart[s] = new Array(ulen[s])\n    }\n\n    for (var x = 0, i = 0; i < src.length; i+=N, x++) {\n\tfor (var j = 0; j < N; j++)\n\t    if (x < part[j].length)\n\t\tpart[j][x] = src[i+j]\n    }\n\n    // Compress each part\n    var comp = new Array(N)\n    var total = 0\n    for (var s = 0; s < N; s++) {\n\t// Example: try O0 and O1 and choose best\n\tvar comp0 = encode(part[s], 0)\n\tvar comp1 = encode(part[s], 1)\n\tcomp[s] = (comp1.length < comp0.length) ? comp1 : comp0\n\ttotal += comp[s].length\n    }\n\n    // Serialise\n    var out = new IOStream(\"\", 0, total+5*N+1)\n    out.WriteByte(N)\n    for (var s = 0; s < N; s++)\n\tout.WriteUint7(comp[s].length)\n\n    for (var s = 0; s < N; s++)\n\tout.WriteData(comp[s], comp[s].length)\n\n    return out.buf.slice(0, out.buf.pos)\n}\n\nfunction RansDecodeStripe(src, len) {\n    var N = src.ReadByte()\n\n    // Retrieve lengths\n    var clen = new Array(N)\n    var ulen = new Array(N)\n    for (var j = 0; j < N; j++)\n\tclen[j] = src.ReadUint7()\n\n    // Decode streams\n    var T = new Array(N);\n    for (var j = 0; j < N; j++) {\n\tulen[j] = Math.floor(len / N) + ((len % N) > j)\n\tT[j] = RansDecodeStream(src, ulen[j])\n    }\n\n    // Transpose\n    var out = new Buffer.allocUnsafe(len)\n    for (var j = 0; j < N; j++) {\n\tfor (var i = 0; i < ulen[j]; i++) {\n\t    out[i*N + j] = T[j][i];\n\t}\n    }\n\n    return out;\n}\n\n\n//----------------------------------------------------------------------\n// Main rANS entry function: decodes a compressed src and\n// returns the uncompressed buffer.\nfunction decode(src) {\n    var stream = new IOStream(src)\n    return RansDecodeStream(stream, 0)\n}\n\nfunction RansDecodeStream(stream, n_out) {\n    var format = stream.ReadByte();\n    var order  = format & 1\n    var stripe = format & 8\n    var nosz   = format & 16\n    var cat    = format & 32\n    var rle    = format & 64\n    var pack   = format & 128\n\n    if (!nosz)\n\tn_out = stream.ReadUint7();\n\n    // N-way interleaving\n    if (stripe)\n\treturn RansDecodeStripe(stream, n_out)\n\n    // Bit packing\n    if (pack) {\n\tvar pack_len = n_out\n\tvar [P, nsym, n_out] = DecodePackMeta(stream)\n    }\n\n    // Run length encoding\n    if (rle) {\n\tvar rle_len = n_out\n\tvar [L, rle_meta, n_out] = DecodeRLEMeta(stream)\n    }\n\n    // Uncompress data (all, packed or run literals)\n    if (cat)\n\tvar buf = stream.ReadData(n_out)\n    else if (order == 0)\n\tvar buf = RansDecode0(stream, n_out)\n    else\n\tvar buf = RansDecode1(stream, n_out)\n\n    // Apply expansion transforms\n    if (rle)\n\tbuf = DecodeRLE(buf, L, rle_meta, rle_len)\n\n    if (pack)\n\tbuf = DecodePack(buf, P, nsym, pack_len)\n\n    return buf\n}\n\nfunction encode(src, format) {\n    var hdr = new IOStream(\"\", 0, 10);\n    hdr.WriteByte(format);\n\n    var order = format & 1\n    var stripe= format & 8\n    var nosz  = format & 16\n    var cat   = format & 32\n    var rle   = format & 64\n    var pack  = format & 128\n\n    var N     = format>>8\n\n    if (!nosz)\n\thdr.WriteUint7(src.length);\n\n    if (stripe)\n\treturn Buffer.concat([hdr.buf.slice(0, hdr.pos), RansEncodeStripe(hdr, src, N)])\n\n    var pack_meta = new Buffer.alloc(0)\n    if (pack)\n\t[pack_meta, src] = EncodePack(src)\n\n    var rle_meta = new Buffer.alloc(0)\n    if (rle)\n\t[rle_meta, src] = EncodeRLE(src)\n\n    if (src.length < 4 && order == 1) {\n\t// Protect against short order-1 data due to RLE/Pack\n\torder = 0\n\thdr.buf[0] &= ~1\n    }\n\n    if (cat)\n\tvar comp = src\n    else if (order == 0)\n\tvar comp = RansEncode0(src)\n    else\n\tvar comp = RansEncode1(src)\n\n    return Buffer.concat([hdr.buf.slice(0,hdr.pos), pack_meta, rle_meta, comp])\n}\n\n//----------------------------------------------------------------------\n// Order-0 decoder\n\nfunction ReadAlphabet(src) {\n    var A = new Array(256)\n    for (var i = 0; i < 256; i++)\n\tA[i] = 0;\n\n    var rle = 0\n    var sym = src.ReadByte()\n    var last_sym = sym\n\n    do {\n\tA[sym] = 1;\n\tif (rle > 0) {\n\t    rle--\n\t    sym++\n\t} else {\n\t    sym = src.ReadByte()\n\t    if (sym == last_sym+1)\n\t\trle = src.ReadByte()\n\t}\n\tlast_sym = sym\n    } while (sym != 0)\n\n    return A\n}\n\n// Decode a single table of order-0 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies0(src, F, C) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    // Fetch alphabet\n    var A = ReadAlphabet(src);\n\n    // Fetch frequencies for the symbols listed in our alphabet\n    for (var i = 0; i < 256; i++) {\n\tif (A[i] > 0)\n\t    F[i] = src.ReadUint7()\n    }\n\n    NormaliseFrequencies0_Shift(F, 12)\n\n    // Compute C[] from F[]\n    C[0] = 0;\n    for (var i = 0; i <= 255; i++)\n\tC[i+1] = C[i] + F[i];\n}\n\nfunction RansDecode0(src, nbytes) {\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies0(src, F, C);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = RansBuildC2S(C, 12);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = src.ReadUint32();\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    for (var i = 0; i < nbytes; i++) {\n\tvar i4 = i%4;\n\tvar f = RansGetCumulativeFreq(R[i4], 12);\n\tvar s = C2S[f]; // Equiv to RansGetSymbolFromFreq(C, f);\n\n\toutput[i] = s;\n\tR[i4] = RansAdvanceStep(R[i4], C[s], F[s], 12);\n\tR[i4] = RansRenorm(src, R[i4]);\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-0 encoder\n\nfunction BuildFrequencies0(src, F) {\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    for (var i = 0; i < src.length; i++)\n\tF[src[i]]++;\n}\n\nfunction NormaliseFrequencies0(F, bits) {\n    // Compute total\n    var tot = 0;\n    for (var i = 0; i < 256; i++)\n\ttot += F[i];\n\n    // Scale total of frequencies to max\n    const max = (1<<bits);\n    var scale = max / tot;\n    do {\n\tvar max_val = 0;\n\tvar max_idx = 0;\n\tvar renorm = 0;\n\ttot = 0;\n\tfor (var i = 0; i < 256; i++) {\n\t    if (F[i] == 0)\n\t\tcontinue\n\n\t    if (max_val < F[i]) {\n\t\tmax_val = F[i]\n\t\tmax_idx = i\n\t    }\n\n\t    F[i] = Math.floor(F[i] * scale);\n\t    if (F[i] == 0)\n\t\tF[i] = 1;\n\n\t    tot += F[i];\n\t}\n\n\t// Adjust new tot to ensure it matches.\n\tif (tot < max) {\n\t    // Too low, boost the most common symbol\n\t    F[max_idx] += max-tot;\n\t} else if (tot-max < F[max_idx]/2 && F[max_idx] > 2) {\n\t    // Too high, reduce the common symbol\n\t    F[max_idx] -= tot-max;\n\t} else if (tot != max) {\n\t    // Much too high, fudge scale and try again.\n\t    scale = max / tot;\n\t    renorm = 1;\n\t}\n    } while (renorm)\n}\n\nfunction NormaliseFrequencies0_Shift(F, bits) {\n    // Compute total and number of bits to shift by\n    var tot = 0;\n    for (var i = 0; i < 256; i++)\n\ttot += F[i];\n\n    if (tot == 0 || tot == (1<<bits))\n\treturn\n\n    var shift = 0;\n    while (tot < (1<<bits)) {\n\ttot *= 2;\n\tshift++;\n    }\n\n    // Scale total of frequencies to (1<<bits)\n    for (var i = 0; i < 256; i++)\n\tF[i] <<= shift;\n}\n\nfunction WriteAlphabet(out, F) {\n    var rle = 0;\n    for (var i = 0; i < 256; i++) {\n\tif (!F[i])\n\t    continue\n\n\tif (rle > 0)\n\t    rle--\n\telse {\n\t    out.WriteByte(i)\n\n\t    if (i > 0 && F[i-1] > 0) {\n\t\t// We've encoded two symbol frequencies in a row.\n\t\t// How many more are there?  Store that count so\n\t\t// we can avoid writing consecutive symbols.\n\t\tfor (rle = i+1; rle<256 && F[rle]; rle++)\n\t\t    ;\n\t\trle -= i+1;\n\n\t\tout.WriteByte(rle);\n\t    }\n\t}\n    }\n    out.WriteByte(0)\n}\n\nfunction WriteFrequencies0(out, F) {\n    WriteAlphabet(out, F)\n\n    for (var i = 0; i < 256; i++) {\n\tif (F[i])\n\t    out.WriteUint7(F[i])\n    }\n}\n\nfunction RansEncode0(src) {\n    const nbytes = src.length;\n    var output = new IOStream(\"\", 0, 257*3+9);\n\n    // Compute frequencies\n    var F = new Array(256)\n    BuildFrequencies0(src, F)\n    var bit_size = Math.ceil(Math.log2(nbytes));\n    if (bit_size > 12)\n\tbit_size = 12;\n    NormaliseFrequencies0(F, bit_size);\n    WriteFrequencies0(output, F);\n    NormaliseFrequencies0(F, 12);\n\n    // Compute cumulative frequencies\n    var C = new Array(256)\n    C[0] = 0;\n    for (var i = 1; i < 256; i++)\n\tC[i] = C[i-1] + F[i-1];\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = RansEncInit();\n\n    // Allow expansion room if trying to compress random data.\n    var rans_out = new IOStream(\"\", (nbytes*1.05+100)>>0, (nbytes*1.05+100)>>0);\n\n    // Main encode loop\n    for (var i = nbytes-1; i >= 0; i--)\n\tR[i%4] = RansEncPut(R[i%4], rans_out, C[src[i]], F[src[i]], 12);\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    //console.error(\"pos=\",rans_out.pos, \" len=\",rans_out.length)\n    //console.error(rans_out.buf.slice(rans_out.pos, rans_out.length))\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\n//----------------------------------------------------------------------\n// Order-1 decoder\n\n// Decode a table of order-1 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies1(src, F, C, shift) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    // Fetch alphabet\n    var A = ReadAlphabet(src);\n\n    // Read F[]\n    for (var i = 0; i < 256; i++) {\n\tif (!A[i])\n\t    continue\n\n\tvar run = 0;\n\tfor (var j = 0; j < 256; j++) {\n\t    if (!A[j])\n\t\tcontinue\n\n\t    if (run > 0) {\n\t\trun--\n\t    } else {\n\t\tF[i][j] = src.ReadUint7();\n\t\tif (F[i][j] == 0)\n\t\t    run = src.ReadByte();\n\t    }\n\t}\n\n\tNormaliseFrequencies0_Shift(F[i], shift)\n\n\t// Compute C[] from F[]\n\tC[i][0] = 0;\n\tfor (var j = 0; j < 256; j++)\n\t    C[i][j+1] = C[i][j] + F[i][j];\n    }\n}\n\nfunction RansDecode1(src, nbytes) {\n    // FIXME: this bit is missing from the RansDecode0 pseudocode.\n\n    var comp = src.ReadByte();\n    var shift = comp >> 4;\n\n    var freq_src = src\n    if (comp & 1) {\n\tvar ulen = src.ReadUint7()\n\tvar clen = src.ReadUint7()\n\tvar comp = new IOStream(src.ReadData(clen))\n\tvar freq_src = new IOStream(RansDecode0(comp, ulen));\n    }\n\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies1(freq_src, F, C, shift);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = new Array(256);\n    for (var i = 0; i < 256; i++)\n\t// Could do only for symbols in alphabet?\n\tC2S[i] = RansBuildC2S(C[i], shift);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = src.ReadUint32();\n\tL[j] = 0;\n    }\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    var nbytes4 = Math.floor(nbytes/4);\n    for (var i = 0; i < nbytes4; i++) {\n\tfor (var j = 0; j < 4; j++) {\n\t    var f = RansGetCumulativeFreq(R[j], shift);\n\n\t    //var s = RansGetSymbolFromFreq(C[L[j]], f);\n\t    var s = C2S[L[j]][f]; // Precomputed version of above\n\n\t    output[i+j*nbytes4] = s;\n\t    R[j] = RansAdvanceStep(R[j], C[L[j]][s], F[L[j]][s], shift);\n\t    R[j] = RansRenorm(src, R[j]);\n\t    L[j] = s;\n\t}\n    }\n\n    // Now deal with the remainder if buffer size is not a multiple of 4,\n    // using rANS state 3 exclusively.  (It'd have been nice to have\n    // designed this to just act as if we kept going with a bail out.)\n    i = 4*i;\n    while (i < nbytes) {\n\tvar f = RansGetCumulativeFreq(R[3], shift);\n\tvar s = RansGetSymbolFromFreq(C[L[3]], f);\n\toutput[i++] = s;\n\tR[3] = RansAdvanceStep(R[3], C[L[3]][s], F[L[3]][s], shift);\n\tR[3] = RansRenorm(src, R[3]);\n\tL[3] = s;\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-1 encoder\n\nfunction BuildFrequencies1(src, F, F0) {\n    for (var i = 0; i < 256; i++) {\n\tF0[i] = 0;\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    var last = 0;\n    for (var i = 0; i < src.length; i++) {\n\tF0[last]++;\n\tF[last][src[i]]++;\n\tlast = src[i];\n    }\n    F0[last]++;\n\n    // Also accept we'll be starting at 4 points, not just byte 0\n    F[0][src[1*(src.length >> 2)]]++;\n    F[0][src[2*(src.length >> 2)]]++;\n    F[0][src[3*(src.length >> 2)]]++;\n    F0[0] += 3;\n}\n\nfunction NormaliseFrequencies1(F, F0, shift) {\n\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue;\n\n\tvar bit_size = Math.ceil(Math.log2(F0[i]));\n\tif (bit_size > shift)\n\t    bit_size = shift;\n\n\tNormaliseFrequencies0(F[i], bit_size)\n    }\n}\n\nfunction NormaliseFrequencies1_Shift(F, F0, shift) {\n    for (var i = 0; i < 256; i++)\n\tif (F0[i])\n\t    NormaliseFrequencies0_Shift(F[i], shift)\n}\n\nfunction WriteFrequencies1(out, F, F0) {\n    WriteAlphabet(out, F0)\n\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue\n\n\tvar run = 0\n\tfor (var j = 0; j < 256; j++) {\n\t    if (!F0[j])\n\t\tcontinue\n\n\t    if (run) {\n\t\trun--\n\t    } else {\n\t\tout.WriteUint7(F[i][j])\n\n\t\tif (!F[i][j]) {\n\t\t    // Count how many more zero-freqs we have\n\t\t    for (var k = j+1; k < 256; k++) {\n\t\t\tif (!F0[k])\n\t\t\t    continue\n\n\t\t\tif (F[i][k] == 0)\n\t\t\t    run++\n\t\t\telse\n\t\t\t    break\n\t\t    }\n\t\t    out.WriteByte(run)\n\t\t}\n\t    }\n\t}\n    }\n}\n\nfunction RansEncode1(src) {\n    const nbytes = src.length;\n    var output = new IOStream(\"\", 0, 257*257*3+9);\n\n    // Compute frequencies\n    var F0 = new Array(256)\n    var F = new Array(256)\n    var C = new Array(256)\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n    }\n\n    // Frequency precision\n    var shift = 12;\n\n    BuildFrequencies1(src, F, F0)\n    NormaliseFrequencies1(F, F0, shift);\n\n    // Store frequencies, possibly compressed\n    var freq = new IOStream(\"\", 0, 257*257*3+9);\n\n    WriteFrequencies1(freq, F, F0);\n\n    var cfreq = RansEncode0(freq.buf.slice(0, freq.pos))\n    if (cfreq.length < freq.pos) {\n\toutput.WriteByte(1 | (shift<<4));\n\toutput.WriteUint7(freq.pos)\n\toutput.WriteUint7(cfreq.length)\n\toutput.WriteData(cfreq, cfreq.length);\n    } else {\n\toutput.WriteByte(0 | (shift<<4));\n\toutput.WriteData(freq.buf, freq.pos);\n    }\n\n    // Normalise and compute cumulative frequencies\n    NormaliseFrequencies1_Shift(F, F0, shift);\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue;\n\n\tC[i][0] = 0;\n\tfor (var j = 1; j < 256; j++)\n\t    C[i][j] = C[i][j-1] + F[i][j-1];\n    }\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = RansEncInit();\n\tL[j] = 0;\n    }\n    var rans_out = new IOStream(\"\", (nbytes*1.05+100)>>0, (nbytes*1.05+100)>>0);\n\n    // We have 4 rans codecs running in parallel on its own 1/4tr of buffer\n    var nbytes4 = Math.floor(nbytes/4);\n    var idx = new Array(4);\n    var last = new Array(4)\n    for (var j = 0; j < 4; j++) {\n\tidx[j] = (j+1)*nbytes4 - 2;\n\tlast[j] = src[idx[j]+1]\n    }\n\n    // Deal with the remainder if not a multiple of 4\n    last[3] = src[nbytes-1];\n    for (var i = nbytes-2; i > 4*nbytes4-2; i--) {\n\tR[3] = RansEncPut(R[3], rans_out, C[src[i]][last[3]], F[src[i]][last[3]], shift);\n\tlast[3] = src[i];\n    }\n\n    // Main encode loop\n    while (idx[0] >= 0) {\n\tfor (var j = 3; j >= 0; j--) {\n\t    var s = src[idx[j]]\n\t    R[j] = RansEncPut(R[j], rans_out, C[s][last[j]], F[s][last[j]], shift);\n\t    last[j] = s;\n\t    idx[j]--;\n\t}\n    }\n\n    for (var j = 3; j >= 0; j--) {\n        R[j] = RansEncPut(R[j], rans_out, C[0][last[j]], F[0][last[j]], shift)\n    }\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\nmodule.exports = { decode, encode }\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Name tokeniser\n//\n// This is a reference implementation designed to match the\n// written specification as closely as possible.  It is *NOT*\n// an efficient implementation, but see comments below.\n\nconst IOStream  = require(\"./iostream\");\nconst rans      = require(\"./rans4x16\");\nconst arith_gen = require(\"./arith_gen\");\n\nvar arith = new arith_gen()\n\nconst TOK_TYPE    = 0\nconst TOK_STRING  = 1\nconst TOK_CHAR    = 2\nconst TOK_DIGITS0 = 3\nconst TOK_DZLEN   = 4\nconst TOK_DUP     = 5\nconst TOK_DIFF    = 6\nconst TOK_DIGITS  = 7\nconst TOK_DELTA   = 8\nconst TOK_DELTA0  = 9\nconst TOK_MATCH   = 10\nconst TOK_NOP     = 11\nconst TOK_END     = 12\n\n//----------------------------------------------------------------------\n// Token byte streams\nfunction DecodeTokenByteStreams(src, in_size, use_arith, nnames) {\n    var t = -1\n\n    var B = new Array(256)\n\n    while (!src.EOF()) {\n\tvar ttype = src.ReadByte()\n\tvar tok_new = ttype & 128\n\tvar tok_dup = ttype & 64\n\tvar type    = ttype & 63\n\n\tif (tok_new) {\n\t    t++\n\t    B[t] = new Array(13)\n\t}\n\n\tif (type != TOK_TYPE && tok_new) {\n\t    var M = new Array(nnames-1).fill(TOK_MATCH)\n\t    B[t][TOK_TYPE] = new IOStream(Buffer.from([type].concat(M)))\n        }\n\n\tif (tok_dup) {\n\t    var dup_pos  = src.ReadByte()\n\t    var dup_type = src.ReadByte()\n\t    B[t][type] = new IOStream(B[dup_pos][dup_type].buf)\n\t} else {\n\t    var clen = src.ReadUint7()\n\t    var data = src.ReadData(clen)\n\n\t    if (use_arith)\n\t\tB[t][type] = arith.decode(data)\n\t    else\n\t\tB[t][type] = rans.decode(data)\n\t    B[t][type] = new IOStream(B[t][type])\n\t}\n    }\n\n    return B\n}\n\n//----------------------------------------------------------------------\n// Token decode\nfunction LeftPadNumber(val, len) {\n    var str = val+\"\"\n    while (str.length < len)\n\tstr = \"0\" + str\n\n    return str\n}\n\nfunction DecodeSingleName(B, N, T, n) {\n    var type = B[0][TOK_TYPE].ReadByte()\n    var dist = B[0][type].ReadUint32()\n    var m = n - dist\n\n    if (type == TOK_DUP) {\n\tN[n] = N[m]\n\tT[n] = T[m]\n\treturn N[n]\n    }\n    \n    var t = 1\n    N[n] = \"\"\n    T[n] = new Array(256)\n    do {\n\ttype = B[t][TOK_TYPE].ReadByte()\n\n\tswitch(type) {\n\tcase TOK_CHAR:\n\t    T[n][t] = B[t][TOK_CHAR].ReadChar()\n\t    break\n\n\tcase TOK_STRING:\n\t    T[n][t] = B[t][TOK_STRING].ReadString()\n\t    break\n\t\n\tcase TOK_DIGITS:\n\t    T[n][t] = B[t][TOK_DIGITS].ReadUint32()\n\t    break\n\n\tcase TOK_DIGITS0:\n\t    var d = B[t][TOK_DIGITS0].ReadUint32()\n\t    var l = B[t][TOK_DZLEN].ReadByte()\n\t    T[n][t] = LeftPadNumber(d, l)\n\t    break\n\n\tcase TOK_DELTA:\n\t    T[n][t] = (T[m][t]>>0) + B[t][TOK_DELTA].ReadByte()\n\t    break\n\n\tcase TOK_DELTA0:\n\t    var d = (T[m][t]>>0) + B[t][TOK_DELTA0].ReadByte()\n\t    var l = T[m][t].length\n\t    T[n][t] = LeftPadNumber(d, l)\n\t    break\n\n\tcase TOK_MATCH:\n\t    T[n][t] = T[m][t]\n\t    break\n\n\tdefault:\n\t    T[n][t] = \"\"\n\t    break\n\t}\n\n\tN[n] += T[n][t++]\n    } while (type != TOK_END)\n\n    return N[n]\n}\n\n//----------------------------------------------------------------------\n// Main tokeniser decode entry function: decodes a compressed src and\n// returns the uncompressed buffer.\nfunction decode(src, len, separator) {\n    var src = new IOStream(src)\n    var ulen = src.ReadUint32()\n    var nnames = src.ReadUint32()\n    var use_arith = src.ReadByte()\n\n    var B = DecodeTokenByteStreams(src, len, use_arith, nnames)\n    var N = new Array(nnames)\n    var T = new Array(nnames)\n\n    var str = \"\"\n    if (typeof separator === 'undefined')\n\tseparator = '\\n'\n    for (var i = 0; i < nnames; i++)\n\tstr += DecodeSingleName(B, N, T, i) + separator\n\n    return str\n}\n\n//----------------------------------------------------------------------\n// Main tokeniser encode function\n\n// Encoder is trickier than decode as we have a lot of decisions to make.\n// However here we just make a simple guess without anything complex,\n// to demonstrate the basic idea.  See the C implementation for further\n// expansion on this.\nfunction encode(src, use_arith) {\n    // Convert buffer to array of names\n    var str = src.toString()\n    if (str[str.length-1] == '\\n')\n\tstr = str.substring(0,str.length-1)\n    var names = str.split(\"\\n\")\n\n    var out = new IOStream(\"\", 0, str.length*2 + 10000) // guess max size\n    out.WriteUint32(str.length)\n    out.WriteUint32(names.length)\n    out.WriteByte(use_arith)\n\n    // Tokenise names\n    var T = new Array(names.length)\n    var H = {}\n    var F = new Array(256).fill(0) // DELTA vs DIGIT frequency\n    var max_tok = 0\n    var max_len = 0\n    for (var i = 0; i < names.length; i++) {\n\tvar [ntok,len] = TokeniseName(T, H, F, names[i], i)\n\tif (max_tok < ntok)\n\t    max_tok = ntok\n\tif (max_len < len)\n\t    max_len = len\n    }\n\n    // Convert tokens to byte streams and serialise\n    for (var tnum = 0; tnum < max_tok; tnum++) {\n\tvar B = new Array(TOK_END+1)\n\tfor (var type = 0; type <= TOK_END; type++)\n\t    B[type] = new IOStream(\"\", 0, names.length * max_len)\n\n\tFillByteStreams(B, T, tnum, names, max_tok, max_len)\n\tSerialiseByteStreams(B, tnum, use_arith, out)\n    }\n\n    return out.buf.slice(0, out.pos)\n}\n\nfunction FillByteStreams(B, T, tnum, names, max_tok, max_len) {\n    // Create byte streams B[]\n    for (var n = 0; n < names.length; n++) {\n\tif (tnum > 0 && T[n][0].type == TOK_DUP)\n\t    continue\n\n\tif (!T[n][tnum])\n\t    continue\n\n\tB[TOK_TYPE].WriteByte(T[n][tnum].type)\n\n\tswitch (T[n][tnum].type) {\n\tcase TOK_DIFF:\n\t    B[TOK_DIFF].WriteUint32(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DUP:\n\t    B[TOK_DUP].WriteUint32(T[n][tnum].val)\n\t    break\n\n\tcase TOK_STRING:\n\t    B[TOK_STRING].WriteString(T[n][tnum].val)\n\t    break\n\n\tcase TOK_CHAR:\n\t    B[TOK_CHAR].WriteChar(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DIGITS:\n\t    B[TOK_DIGITS].WriteUint32(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DIGITS0:\n\t    B[TOK_DIGITS0].WriteUint32(T[n][tnum].val)\n\t    B[TOK_DZLEN].WriteByte(T[n][tnum].val.length)\n\t    break\n\n\tcase TOK_DELTA:\n\t    B[T[n][tnum].type].WriteByte(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DELTA0:\n\t    B[T[n][tnum].type].WriteByte(T[n][tnum].val)\n\t    break\n\t}\n    }\n}\n\nfunction SerialiseByteStreams(B, tnum, use_arith, out) {\n    // Compress and serialise byte streams B[]\n    for (var type = 0; type <= TOK_END; type++) {\n\tif (B[type].pos <= 0)\n\t    continue\n\n\tout.WriteByte(type + ((type == 0) ? 128 : 0))\n\n\t// IOStream to sized buffer\n\tB[type] = B[type].buf.slice(0, B[type].pos)\n\tvar comp = try_compress(B[type], use_arith)\n\n\tout.WriteUint7(comp.length)\n\tout.WriteData(comp, comp.length)\n    }\n}\n\nfunction try_compress(src, use_arith) {\n    var best = 1<<30\n    var comp\n\n    var methods = [0, 1, 64, 65, 128, 129, 193+8]\n    for (var i in methods) {\n\tvar lvl = methods[i]\n\tif ((lvl & 1) && src.length < 100)\n\t    continue\n\n\tif ((lvl & 8) && (src.length % 4) != 0)\n\t    continue\n\n\ttry {\n\t    var tmp = use_arith\n\t\t? arith.encode(src, lvl)\n\t\t: rans.encode(src, lvl)\n\t} catch (e) {\n\t    var tmp = 0\n\t}\n\tif (tmp && best > tmp.length) {\n\t    best = tmp.length\n\t    comp = tmp\n\t}\n    }\n\n    return comp\n}\n\nfunction TokeniseName(T, H, F, name, n) {\n    var max_len = 0\n\n    // Always compare against last name only\n    var p = n-1\n    T[n] = new Array(256)\n\n    if (H[name]) {\n\t//console.error(name,H[name],n)\n\tT[n][0] = {\n\t    type: TOK_DUP,\n\t    val:  n - H[name]\n\t}\n    } else {\n\tT[n][0] = {\n\t    type: TOK_DIFF,\n\t    val:  n == 0 ? 0 : 1\n\t}\n    }\n\n    H[name] = n\n\n    // Splits on alphanumerics, punctuation\n    var tok = name.match(/([a-zA-Z0-9]{1,9})|([^a-zA-Z0-9]+)/g)\n    for (var i = 0; i < tok.length; i++) {\n\tvar t = i+1 // token 0 = DIFF vs DUP\n\tvar type = TOK_STRING\n\tvar val = tok[i]\n\tif (tok[i].match(/^0+[0-9]*$/g))\n\t    type = TOK_DIGITS0\n\telse if (tok[i].match(/^[0-9]+$/g))\n\t    type = TOK_DIGITS\n\telse if (tok[i].length == 1)\n\t    type = TOK_CHAR\n\n\tif (p >= 0 && T[p][t]) {\n\t    if (T[p][t].str == tok[i]) {\n\t\ttype = TOK_MATCH\n\t\tval = \"\"\n\t    } else if (T[p][t].type == TOK_DIGITS || T[p][t].type == TOK_DELTA) {\n\t\tvar d = val - T[p][t].str;\n\t\tF[t]++\n\t\tif (d >= 0 && d < 256 && F[t] > n/2) {\n\t\t    type = TOK_DELTA\n\t\t    val = d\n\t\t}\n\t    } else if ((T[p][t].type == TOK_DIGITS0 || T[p][t].type == TOK_DELTA0)\n\t\t       && T[p][t].str.length == val.length) {\n\t\tvar d = val - T[p][t].str;\n\t\tF[t]++\n\t\tif (d >= 0 && d < 256 && F[t] > n/2) {\n\t\t    type = TOK_DELTA0\n\t\t    val = d\n\t\t}\n\t    }\n\t}\n\n\tT[n][t] = {\n\t    str:  tok[i],\n\t    val:  val,\n\t    type: type\n\t}\n\n\tif (max_len < T[n][t].val.length+3)  // +3 for integers; 5 -> (Uint32)5\n\t    max_len = T[n][t].val.length+3\n\n\t//console.error(t,T[n][t])\n    }\n    T[n][++t] = {\n\ttype: TOK_END\n    }\n\n    return [t+1, max_len]\n}\n\nmodule.exports = { encode, decode }\n","/*\nbzip2.js - a small bzip2 decompression implementation\n\nCopyright 2011 by antimatter15 (antimatter15@gmail.com)\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n\nI hereby release this code under the GNU Library General Public License\n(LGPL) version 2, available at http://www.gnu.org/copyleft/lgpl.html\n*/\n\nvar bzip2 = {};\n\nbzip2.array = function (bytes) {\n    var bit = 0,\n        byte = 0;\n    var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n    return function (n) {\n        var result = 0;\n        while (n > 0) {\n            var left = 8 - bit;\n            if (n >= left) {\n                result <<= left;\n                result |= (BITMASK[left] & bytes[byte++]);\n                bit = 0;\n                n -= left;\n            } else {\n                result <<= n;\n                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));\n                bit += n;\n                n = 0;\n            }\n        }\n        return result\n    }\n}\n\nbzip2.simple = function (bits) {\n    var size = bzip2.header(bits);\n    var all, chunk, chunks = [];\n    var index = 0;\n    do {\n        //all += chunk;\n        chunk = bzip2.decompress(bits, size);\n        //all.set(chunk, index);\n        if (chunk != -1) {\n            chunks.push(chunk);\n            index += chunk.byteLength;\n        }\n    } while (chunk != -1);\n    all = new Uint8Array(index);\n    index = 0;\n    for (var i = 0; i < chunks.length; ++i) {\n        chunk = chunks[i];\n        all.set(chunk, index);\n        index += chunk.byteLength;\n    }\n    return all;\n}\n\nbzip2.header = function (bits) {\n    if (bits(8 * 3) != 4348520)\n        throw \"No magic number found\";\n    var i = bits(8) - 48;\n    if (i < 1 || i > 9)\n        throw \"Not a BZIP archive\";\n    return i;\n};\n\n//takes a function for reading the block data (starting with 0x314159265359)\n//a block size (0-9) (optional, defaults to 9)\n//a length at which to stop decompressing and return the output\nbzip2.decompress = function (bits, size, len) {\n    var MAX_HUFCODE_BITS = 20;\n    var MAX_SYMBOLS = 258;\n    var SYMBOL_RUNA = 0;\n    var SYMBOL_RUNB = 1;\n    var GROUP_SIZE = 50;\n\n    var bufsize = 100000 * 9;\n    for (var h = '', i = 0; i < 6; i++)\n        h += bits(8).toString(16);\n    if (h == \"177245385090\")\n        return -1; //last block\n    if (h != \"314159265359\")\n        throw \"eek not valid bzip data\";\n    bits(32); //ignore CRC codes\n    if (bits(1))\n        throw \"unsupported obsolete version\";\n    var origPtr = bits(24);\n    if (origPtr > bufsize)\n        throw \"Initial position larger than buffer size\";\n    var t = bits(16);\n    var symToByte = new Uint8Array(256),\n        symTotal = 0;\n    for (i = 0; i < 16; i++) {\n        if (t & (1 << (15 - i))) {\n            var k = bits(16);\n            for (j = 0; j < 16; j++) {\n                if (k & (1 << (15 - j))) {\n                    symToByte[symTotal++] = (16 * i) + j;\n                }\n            }\n        }\n    }\n\n    var groupCount = bits(3);\n    if (groupCount < 2 || groupCount > 6)\n        throw \"another error\";\n    var nSelectors = bits(15);\n    if (nSelectors == 0)\n        throw \"meh\";\n    var mtfSymbol = []; //TODO: possibly replace JS array with typed arrays\n    for (var i = 0; i < groupCount; i++)\n        mtfSymbol[i] = i;\n    var selectors = new Uint8Array(32768);\n\n    for (var i = 0; i < nSelectors; i++) {\n        for (var j = 0; bits(1); j++)\n            if (j >= groupCount)\n                throw \"whoops another error\";\n        var uc = mtfSymbol[j];\n        mtfSymbol.splice(j, 1); //this is a probably inefficient MTF transform\n        mtfSymbol.splice(0, 0, uc);\n        selectors[i] = uc;\n    }\n\n    var symCount = symTotal + 2;\n    var groups = [];\n    for (var j = 0; j < groupCount; j++) {\n        var length = new Uint8Array(MAX_SYMBOLS),\n            temp = new Uint8Array(MAX_HUFCODE_BITS + 1);\n        t = bits(5); //lengths\n        for (var i = 0; i < symCount; i++) {\n            while (true) {\n                if (t < 1 || t > MAX_HUFCODE_BITS)\n                    throw \"I gave up a while ago on writing error messages\";\n                if (!bits(1))\n                    break;\n                if (!bits(1))\n                    t++;\n                else\n                    t--;\n            }\n            length[i] = t;\n        }\n        var minLen, maxLen;\n        minLen = maxLen = length[0];\n        for (var i = 1; i < symCount; i++) {\n            if (length[i] > maxLen)\n                maxLen = length[i];\n            else if (length[i] < minLen)\n                minLen = length[i];\n        }\n        var hufGroup;\n        hufGroup = groups[j] = {};\n        hufGroup.permute = new Uint32Array(MAX_SYMBOLS);\n        hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 1);\n        hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);\n        hufGroup.minLen = minLen;\n        hufGroup.maxLen = maxLen;\n        var base = hufGroup.base.subarray(1);\n        var limit = hufGroup.limit.subarray(1);\n        var pp = 0;\n        for (var i = minLen; i <= maxLen; i++)\n            for (var t = 0; t < symCount; t++)\n                if (length[t] == i)\n                    hufGroup.permute[pp++] = t;\n        for (i = minLen; i <= maxLen; i++)\n            temp[i] = limit[i] = 0;\n        for (i = 0; i < symCount; i++)\n            temp[length[i]]++;\n        pp = t = 0;\n        for (i = minLen; i < maxLen; i++) {\n            pp += temp[i];\n            limit[i] = pp - 1;\n            pp <<= 1;\n            base[i + 1] = pp - (t += temp[i]);\n        }\n        limit[maxLen] = pp + temp[maxLen] - 1;\n        base[minLen] = 0;\n    }\n    var byteCount = new Uint32Array(256);\n    for (var i = 0; i < 256; i++)\n        mtfSymbol[i] = i;\n    var runPos, count, symCount, selector;\n    runPos = count = symCount = selector = 0;\n    var buf = new Uint32Array(bufsize);\n    while (true) {\n        if (!(symCount--)) {\n            symCount = GROUP_SIZE - 1;\n            if (selector >= nSelectors)\n                throw \"meow i'm a kitty, that's an error\";\n            hufGroup = groups[selectors[selector++]];\n            base = hufGroup.base.subarray(1);\n            limit = hufGroup.limit.subarray(1);\n        }\n        i = hufGroup.minLen;\n        j = bits(i);\n        while (true) {\n            if (i > hufGroup.maxLen)\n                throw \"rawr i'm a dinosaur\";\n            if (j <= limit[i])\n                break;\n            i++;\n            j = (j << 1) | bits(1);\n        }\n        j -= base[i];\n        if (j < 0 || j >= MAX_SYMBOLS)\n            throw \"moo i'm a cow\";\n        var nextSym = hufGroup.permute[j];\n        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {\n            if (!runPos) {\n                runPos = 1;\n                t = 0;\n            }\n            if (nextSym == SYMBOL_RUNA)\n                t += runPos;\n            else\n                t += 2 * runPos;\n            runPos <<= 1;\n            continue;\n        }\n        if (runPos) {\n            runPos = 0;\n            if (count + t >= bufsize)\n                throw \"Boom.\";\n            uc = symToByte[mtfSymbol[0]];\n            byteCount[uc] += t;\n            while (t--)\n                buf[count++] = uc;\n        }\n        if (nextSym > symTotal)\n            break;\n        if (count >= bufsize)\n            throw \"I can't think of anything. Error\";\n        i = nextSym - 1;\n        uc = mtfSymbol[i];\n        mtfSymbol.splice(i, 1);\n        mtfSymbol.splice(0, 0, uc);\n        uc = symToByte[uc];\n        byteCount[uc]++;\n        buf[count++] = uc;\n    }\n    if (origPtr < 0 || origPtr >= count)\n        throw \"I'm a monkey and I'm throwing something at someone, namely you\";\n    var j = 0;\n    for (var i = 0; i < 256; i++) {\n        k = j + byteCount[i];\n        byteCount[i] = j;\n        j = k;\n    }\n    for (var i = 0; i < count; i++) {\n        uc = buf[i] & 0xff;\n        buf[byteCount[uc]] |= (i << 8);\n        byteCount[uc]++;\n    }\n    var pos = 0,\n        current = 0,\n        run = 0;\n    if (count) {\n        pos = buf[origPtr];\n        current = (pos & 0xff);\n        pos >>= 8;\n        run = -1;\n    }\n    count = count;\n    var output = new Uint8Array(bufsize);\n    var copies, previous, outbyte;\n    var index = 0;\n    if (!len)\n        len = Infinity;\n    while (count) {\n        count--;\n        previous = current;\n        pos = buf[pos];\n        current = pos & 0xff;\n        pos >>= 8;\n        if (run++ == 3) {\n            copies = current;\n            outbyte = previous;\n            current = -1;\n        } else {\n            copies = 1;\n            outbyte = current;\n        }\n        while (copies--) {\n            //output += (String.fromCharCode(outbyte));\n            output[index++] = outbyte;\n            //index++;\n            if (!--len)\n                return output;\n        }\n        if (current != previous)\n            run = 0;\n    }\n    //return output;\n    //return output.subarray(0,index-1);\n    return output.subarray(0, index);\n}\n\nmodule.exports = bzip2;\n","var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n","(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      isBuffer = require('is-buffer'),\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message) && message.constructor !== Uint8Array)\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n"],"names":["unzip","input","Buffer","from","inflate","CramError","Error","CramUnimplementedError","CramMalformedError","CramSizeLimitError","CramArgumentError","TF_SHIFT","TOTFREQ","RANS_BYTE_L","FC","constructor","this","F","undefined","C","advanceStep","r","start","freq","scaleBits","AriDecoder","fc","Array","i","length","R","Symbol","symbolInit","sym","advanceSymbolStep","get","advanceSymbol","pptr","advance","renormalize","assert","result","ByteBuffer","nodeBuffer","initialInputPosition","_buffer","_position","b","getByte","getByteAt","position","put","val","putAt","setPosition","pos","getInt","readInt32LE","remaining","singleItf8","itf8","cramFileDefinition","parser","string","uint8","stripNull","maxLength","cramBlockHeader","formatter","method","type","cramBlockCrc32","uint32","cramTagDictionary","buffer","makeTagSet","stringStart","stringEnd","str","toString","tags","push","substr","tagSets","parseByteAsBool","cramPreservationMap","array","choice","tag","choices","MI","UI","PI","RN","AP","RR","SM","TD","nest","data","ents","formatMap","map","key","value","console","warn","unversionedParsers","isMappedSliceHeader","header","refSeqId","versionedParsers","cramUnmappedSliceHeader","majorVersion","ltf8","numContentIds","cramMappedSliceHeader","cramEncoding","namely","cramDataSeriesEncodingMap","cramTagEncodingMap","integerRepresentation","String","fromCharCode","cramCompressionHeader","cramContainerHeader1","int32","cramContainerHeader2","crcLength","numLandmarks","CramBufferOverrunError","getBits","cursor","numBits","bytePosition","bitPosition","dlen","parseItem","startBufferPosition","startFilePosition","offset","parse","_endPosition","_size","tinyMemoize","_class","methodName","prototype","memoAttrName","res","call","Promise","resolve","catch","baseNumbers","a","A","c","g","G","t","T","n","N","makeFlagsHelper","x","code","name","flags","BamFlagsDecoder","CramFlagsDecoder","MateFlagsDecoder","CramRecord","cramFlags","readLength","mappingQuality","lengthOnRef","qualityScores","mateRecordNumber","readBases","readFeatures","mateToUse","readGroupId","readName","sequenceId","uniqueId","templateSize","alignmentStart","mate","mateFlags","mateReadName","mateSequenceId","mateAlignmentStart","isPaired","isProperlyPaired","isSegmentUnmapped","isMateUnmapped","isReverseComplemented","isMateReverseComplemented","isRead1","isRead2","isSecondary","isFailedQc","isDuplicate","isSupplementary","isDetached","hasMateDownStream","isPreservingQualityScores","isUnknownBases","getReadBases","_refRegion","decoded","cramRecord","refRegion","regionSeqOffset","seq","toUpperCase","bases","regionPos","currentReadFeature","feature","added","sub","chunk","decodeReadSequence","getPairOrientation","s1","s2","o1","o2","tmp","isize","templateLength","join","addReferenceSequence","compressionScheme","forEach","readFeature","refCoord","refPos","refBase","charAt","ref","baseNumber","base","substitutionMatrix","decodeBaseSubstitution","end","toJSON","Object","keys","k","readNullTerminatedString","parseTagData","tagType","toNumber","Int32Array","Int16Array","Uint16Array","Int8Array","Float32Array","Number","parseInt","replace","arrayType","slice","arr","Uint8Array","Uint32Array","parseTagValueArray","decodeRecord","decodeDataSeries","sliceHeader","coreDataBlock","blocksByContentId","cursors","recordNumber","parsedContent","APdelta","lastAlignmentStart","readNamesIncluded","isUnmapped","setMateUnmapped","isOnNegativeStrand","setMateReverseComplemented","isWithMateDownstream","TLindex","TN","getTagNames","ntags","tagId","tagName","tagCodec","getCodecForTag","tagData","decode","isDecodeSequenceAsStar","readFeatureCount","currentReadPos","currentRefPos","decodeRFData","dataSeriesName","byteLength","toArray","readPosDelta","data1Schema","B","S","X","D","I","q","Q","H","P","data2Schema","decodeReadFeatures","isNaN","associateIntraSliceMate","allRecords","currentRecordNumber","thisRecord","mateRecord","complicatedMultiSegment","matedRecords","getAllMatedRecords","startRecord","records","starts","ends","estimatedTemplateLength","Math","max","min","calculateMultiSegmentMatedTemplateLength","lengthEstimate","calculateIntraSliceMatePairTemplateLength","CramSlice","container","containerPosition","_unused","file","getHeader","sectionParsers","getSectionParsers","containerHeader","readBlock","contentType","content","getBlocks","blockPosition","blocks","numBlocks","block","getCoreDataBlock","_getBlocksContentIdIndex","contentId","getBlockByContentId","id","getReferenceRegion","getCompressionScheme","refBaseBlockId","refBlock","refSeqStart","refSeqSpan","span","referenceRequired","fetchReferenceSequenceCallback","getAllRecords","getRecords","_fetchRecords","getDefinition","options","checkSequenceMD5","md5","seqMd5","sequenceMD5","storedMd5","byte","coreBlock","externalBlocks","Map","getCursor","set","codec","getCodecForDataSeries","numRecords","init","contentPosition","recordCounter","e","filter","filterFunction","cacheKey","filePosition","recordsPromise","featureCache","singleRefId","refRegions","seqId","all","values","async","split","CramCodec","parameters","dataType","instantiateCodec","super","TypeError","arrayLength","_getLengthCodec","dataCodec","_getDataCodec","encodingParams","lengthsEncoding","valuesEncoding","codecClasses","_decodeData","_decodeInt","_decodeByte","blockContentId","contentBlock","bytesRead","initialOffset","countFlags","parseItf8","codes","codeBook","sortedByValue","sortedCodes","sortedValuesByBitCode","sortedBitCodes","sortedBitLengthsByBitCode","bitCodeToValue","includes","buildCodeBook","buildCodes","buildCaches","bitLength","_decode","_decodeZeroLengthCode","numCodes","symbol","symbols","bitLengths","sort","codeLength","codeValue","entries","bitLengthInt","bitCode","delta","ii","numberOfSetBits","maxBitCode","fill","coreCursor","prevLen","bits","index","j","_decodeByteArray","dataBuffer","stopByte","startPosition","stopPosition","subarray","numLeadingOnes","K","encodingData","CodecClass","codecId","dataSeriesTypes","BF","CF","RI","RL","RG","MF","NS","NP","TS","NF","TC","FN","FP","BS","IN","SC","DL","BA","BB","RS","PD","HC","MQ","QS","QQ","TL","CramContainerCompressionScheme","dataSeriesCodecCache","tagCodecCache","tagEncoding","preservation","tagIdsDictionary","byteArray","matrix","parseSubstitutionMatrix","dataSeriesEncoding","tagListId","test","CramContainer","_readContainerHeader","getCompressionHeaderBlock","getFirstBlock","getSlice","slicePosition","sliceSize","size","fileSize","stat","bytes1","allocUnsafe","read","header1","numLandmarksSize","v","bytes2","header2","validateChecksums","crc32","checkCrc32","assign","maybeUrl","maybePath","maybeFilehandle","source","protocol","pathname","url","unescape","ensureNotNullish","fromUrl","parseHeaderText","text","lines","line","fields","parsedFields","f","fieldTag","CramFile","args","path","filehandle","seqFetch","cacheSize","maxSize","uInt32","uInt8","getEndianness","headbytes","definition","getSamHeader","firstContainer","getContainerById","firstBlock","headerLength","getHeaderText","parsers","parserName","containerNumber","currentContainer","getContainerAtPosition","currentHeader","recordedCrc32","description","calculatedCrc32","containerCount","readBlockHeader","_parseSection","section","preReadBuffer","_uncompress","compressionMethod","inputBuffer","outputBuffer","copy","order","outputSize","output","out","syms","cp","decoder","rle","readStatsO0","rans0","rans1","rans2","rans3","outputEnd","c0","c1","c2","c3","uncompressOrder0Way4","rlei","rlej","RansDecSymbol","readStatsO1","rans7","isz4","i0","i1","i2","i7","l0","l1","l2","l7","c7","uncompressOrder1Way4","blockHeader","blockContentPosition","uncompressedData","uncompressedSize","compressedData","compressedSize","crc","IndexedCramFile","cram","cramUrl","cramPath","cramFilehandle","getEntriesForRange","fetchSizeLimit","getRecordsForRange","opts","viewAsPairs","pairAcrossChr","maxInsertSize","slices","totalSize","s","sliceBytes","reduce","toLocaleString","sliceResults","getRecordsInSlice","ret","concat","readNames","readIds","unmatedPairs","matePromises","abs","mateSlices","mateBlocks","mateChunks","localeCompare","item","ary","mateRecordPromises","mateFeatPromises","mateTotalSize","recordPromise","featPromise","then","feats","mateRecs","newMateFeats","newMates","current","containerStart","sliceStart","hasDataForReferenceSequence","addRecordToIndex","record","some","el","CraiIndex","_parseCache","cache","signal","parseIndex","readFile","uncompressedBuffer","readUInt32LE","currentRecord","currentString","charCode","ent","getIndex","queryStart","queryEnd","seqEntries","compare","entry","entryStart","entryEnd","bins","RangeCoder","IOStream","ByteModel","bzip2","ARITH_PACK","module","exports","src","stream","decodeStream","n_out","ReadByte","ReadUint7","e_len","decodeStripe","decodePackMeta","decodeCat","decodeExt","decodeRLE1","decodeRLE0","decode1","decode0","decodePack","encode","WriteByte","WriteUint7","buf","encodeStripe","pack_meta","encodePack","WriteStream","encodeRLE1","encodeRLE0","encode1","encode0","max_sym","byte_model","rc","RangeStartDecode","ModelDecode","n_in","ModelEncode","RangeFinishEncode","last","decompress","encodeExt","model_lit","model_run","part","run","rctx","nsym","M","len","packMeta","meta","floor","hdr","ulen","comp","total","comp0","comp1","WriteData","clen","low","range","FFnum","carry","RangeGetFrequency","tot_freq","RangeDecode","sym_low","sym_freq","RangeShiftLow","dst","RangeEncode","old_low","log","total_freq","acc","ModelRenormalise","read_array","tab","z","run_len","FLAG_DEDUP","FLAG_FLEN","FLAG_SEL","FLAG_QMAP","FLAG_PTAB","FLAG_DTAB","FLAG_QTAB","fqz_update_ctx","params","state","context","qctx","qshift","qtab","qbits","qloc","do_pos","ptab","p","ploc","do_delta","dtab","dloc","prevq","do_sel","sloc","decode_fqz_single_param","ReadUint16","pflags","do_dedup","fixed_len","do_qmap","do_qtab","qmap","decode_fqz_new_record","gparams","model","rev","max_sel","sel","stab","do_rev","rec","is_dup","dup","store_array","tmp1","sz1","i_start","tmp2","sz2","curr","q_lens","gflags","nparam","error","decode_fqz_params","qual","fqz_create_models","qual_len","reverse_qualities","decode_fqz","q_dirs","qhist","qd_last","qd_fixed","pbits","pshift","dbits","dshift","sbits","do_stab","pick_fqz_params","dsqr","WriteUint16","encode_fqz_params","model_qual","model_len","model_sel","process","exit","qlast","q1","encode_fqz","r4x8","r4x16","arith","fqzcomp","tok3","r4x8_uncompress","r4x16_uncompress","arith_uncompress","fqzcomp_uncompress","tok3_uncompress","start_pos","EOF","ReadData","ReadChar","ReadUint32","ReadString","ReadITF8","WriteChar","charCodeAt","WriteString","u","WriteUint32","writeInt32LE","WriteITF8","WriteByteNeg","RansGetCumulativeFreq","RansGetSymbolFromFreq","RansBuildC2S","C2S","RansAdvanceStep","RansRenorm","RansEncFlush","RansEncPut","scale_bits","R_max","RansEncRenorm","ReadFrequencies0","last_sym","NormaliseFrequencies0","tot","scale","max_val","max_idx","renorm","WriteFrequencies0","nbytes","i4","RansDecode0","ReadFrequencies1","L","nbytes4","RansDecode1","BuildFrequencies0","alloc","rans_out","freq_tab","RansEncode0","F0","BuildFrequencies1","NormaliseFrequencies1","WriteFrequencies1","idx","RansEncode1","RansEncodeStripe","RansDecodeStream","format","stripe","cat","pack","RansDecodeStripe","pack_len","DecodePackMeta","rle_len","rle_meta","u_meta_len","comp_meta_len","DecodeRLEMeta","shift","freq_src","ReadAlphabet","NormaliseFrequencies0_Shift","DecodeRLE","DecodePack","ceil","EncodePack","nrle","dpos","cmeta","EncodeRLE","bit_size","log2","WriteAlphabet","cfreq","NormaliseFrequencies1_Shift","rans","LeftPadNumber","DecodeSingleName","m","d","l","FillByteStreams","tnum","names","max_tok","max_len","SerialiseByteStreams","use_arith","try_compress","best","methods","lvl","TokeniseName","tok","match","substring","ntok","TOK_END","separator","nnames","in_size","ttype","tok_new","tok_dup","dup_pos","dup_type","DecodeTokenByteStreams","bytes","bit","BITMASK","left","chunks","bufsize","h","origPtr","symToByte","symTotal","groupCount","nSelectors","mtfSymbol","selectors","uc","splice","symCount","groups","minLen","maxLen","hufGroup","temp","MAX_HUFCODE_BITS","permute","limit","pp","runPos","count","selector","byteCount","GROUP_SIZE","nextSym","copies","previous","outbyte","Infinity","charenc","utf8","stringToBytes","bin","encodeURIComponent","bytesToString","decodeURIComponent","escape","base64map","crypt","rotl","rotr","endian","randomBytes","random","bytesToWords","words","wordsToBytes","bytesToHex","hex","hexToBytes","bytesToBase64","base64","triplet","base64ToBytes","imod4","indexOf","pow","isBuffer","obj","readFloatLE","isSlowBuffer","_isBuffer","message","encoding","isArray","FF","_ff","GG","_gg","HH","_hh","II","_ii","aa","bb","cc","dd","_blocksize","_digestsize","digestbytes","asBytes","asString"],"sourceRoot":""}