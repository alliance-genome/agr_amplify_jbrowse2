{"version":3,"file":"static/js/7431.eecbf15e.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/bam/src/virtualOffset.ts","../../../node_modules/@gmod/bam/src/chunk.ts","../../../node_modules/@gmod/bam/src/indexFile.ts","../../../node_modules/@gmod/bam/src/util.ts","../../../node_modules/@gmod/bam/src/bai.ts","../../../node_modules/@gmod/bam/src/csi.ts","../../../node_modules/@gmod/bam/src/constants.ts","../../../node_modules/@gmod/bam/src/record.ts","../../../node_modules/@gmod/bam/src/sam.ts","../../../node_modules/@gmod/bam/src/bamFile.ts","../../../node_modules/@gmod/bam/src/htsget.ts","../../../node_modules/@gmod/bam/node_modules/quick-lru/index.js","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js","../../../node_modules/cross-fetch/dist/browser-polyfill.js","../../../node_modules/@babel/runtime/helpers/esm/AwaitValue.js","../../../node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js","../../../node_modules/@babel/runtime/helpers/esm/asyncIterator.js","../../../node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js"],"sourcesContent":["export default class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n\n  static min(...args: VirtualOffset[]) {\n    let min\n    let i = 0\n    for (; !min; i += 1) {\n      min = args[i]\n    }\n    for (; i < args.length; i += 1) {\n      if (min.compareTo(args[i]) > 0) {\n        min = args[i]\n      }\n    }\n    return min\n  }\n}\nexport function fromBytes(bytes: Buffer, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7] * 0x10000000000 +\n      bytes[offset + 6] * 0x100000000 +\n      bytes[offset + 5] * 0x1000000 +\n      bytes[offset + 4] * 0x10000 +\n      bytes[offset + 3] * 0x100 +\n      bytes[offset + 2],\n    (bytes[offset + 1] << 8) | bytes[offset],\n  )\n}\n","import VirtualOffset from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public minv: VirtualOffset\n  public maxv: VirtualOffset\n  public bin: number\n  public _fetchedSize?: number\n\n  /**\n   * @param {VirtualOffset} minv\n   * @param {VirtualOffset} maxv\n   * @param {number} bin\n   * @param {number} [fetchedSize]\n   */\n  constructor(\n    minv: VirtualOffset,\n    maxv: VirtualOffset,\n    bin: number,\n    fetchedSize = undefined,\n  ) {\n    this.minv = minv\n    this.maxv = maxv\n    this.bin = bin\n    this._fetchedSize = fetchedSize\n  }\n\n  toUniqueString() {\n    return `${this.minv}..${this.maxv} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import { GenericFilehandle } from 'generic-filehandle'\nimport VirtualOffset from './virtualOffset'\nimport Chunk from './chunk'\nimport { BaseOpts } from './util'\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (s: string) => string\n  public setupP?: Promise<any>\n\n  /**\n   * @param {filehandle} filehandle\n   * @param {function} [renameRefSeqs]\n   */\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract lineCount(refId: number): Promise<number>\n  protected abstract _parse(opts?: BaseOpts): Promise<any>\n  public abstract indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n\n  public abstract blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ): Promise<Chunk[]>\n\n  _findFirstData(data: any, virtualOffset: VirtualOffset) {\n    const currentFdl = data.firstDataLine\n    if (currentFdl) {\n      data.firstDataLine =\n        currentFdl.compareTo(virtualOffset) > 0 ? virtualOffset : currentFdl\n    } else {\n      data.firstDataLine = virtualOffset\n    }\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    return !!((await this.parse(opts)).indices[seqId] || {}).binIndex\n  }\n}\n","import Chunk from './chunk'\nimport VirtualOffset from './virtualOffset'\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function longToNumber(long: Long) {\n  if (\n    long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n    long.lessThan(Number.MIN_SAFE_INTEGER)\n  ) {\n    throw new Error('integer overflow')\n  }\n  return long.toNumber()\n}\n\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    // console.log('bam aborted!')\n    if (typeof DOMException !== 'undefined') {\n      throw new DOMException('aborted', 'AbortError')\n    } else {\n      const e = new Error('aborted')\n      //@ts-ignore\n      e.code = 'ERR_ABORTED'\n      throw e\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : (obj as BaseOpts)\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest: VirtualOffset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | null = null\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort((c0, c1) => {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    if (dif !== 0) {\n      return dif\n    } else {\n      return c0.minv.dataPosition - c1.minv.dataPosition\n    }\n  })\n\n  chunks.forEach(chunk => {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === null) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  })\n\n  return mergedChunks\n}\n","import Long from 'long'\nimport { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\n\nimport IndexFile from './indexFile'\nimport { longToNumber, optimizeChunks, BaseOpts } from './util'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nexport default class BAI extends IndexFile {\n  baiP?: Promise<Buffer>\n\n  parsePseudoBin(bytes: Buffer, offset: number) {\n    const lineCount = longToNumber(\n      Long.fromBytesLE(\n        Array.prototype.slice.call(bytes, offset + 16, offset + 24),\n        true,\n      ),\n    )\n    return { lineCount }\n  }\n\n  async lineCount(refId: number, opts: BaseOpts = {}) {\n    const prom = await this.parse(opts)\n    const index = prom.indices[refId]\n    if (!index) {\n      return -1\n    }\n    const ret = index.stats || {}\n    return ret.lineCount === undefined ? -1 : ret.lineCount\n  }\n\n  fetchBai(opts: BaseOpts = {}) {\n    if (!this.baiP) {\n      this.baiP = this.filehandle.readFile(opts).catch(e => {\n        this.baiP = undefined\n        throw e\n      }) as Promise<Buffer>\n    }\n    return this.baiP\n  }\n\n  // fetch and parse the index\n  async _parse() {\n    const data: { [key: string]: any } = { bai: true, maxBlockSize: 1 << 16 }\n    const bytes = await this.fetchBai()\n\n    // check BAI magic numbers\n    if (bytes.readUInt32LE(0) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    data.refCount = bytes.readInt32LE(4)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    data.indices = new Array(data.refCount)\n    let currOffset = 8\n    for (let i = 0; i < data.refCount; i += 1) {\n      // the binning index\n      const binCount = bytes.readInt32LE(currOffset)\n      let stats\n\n      currOffset += 4\n      const binIndex: { [key: number]: Chunk[] } = {}\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(currOffset)\n        currOffset += 4\n        if (bin === binLimit + 1) {\n          currOffset += 4\n          stats = this.parsePseudoBin(bytes, currOffset)\n          currOffset += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = bytes.readInt32LE(currOffset)\n          currOffset += 4\n          const chunks = new Array(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, currOffset)\n            const v = fromBytes(bytes, currOffset + 8)\n            currOffset += 16\n            this._findFirstData(data, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      // as we're going through the linear index, figure out\n      // the smallest virtual offset in the indexes, which\n      // tells us where the BAM header ends\n      const linearIndex = new Array(linearCount)\n      for (let k = 0; k < linearCount; k += 1) {\n        linearIndex[k] = fromBytes(bytes, currOffset)\n        currOffset += 8\n        this._findFirstData(data, linearIndex[k])\n      }\n\n      data.indices[i] = { binIndex, linearIndex, stats }\n    }\n\n    return data\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts: BaseOpts = {},\n  ): Promise<{ start: number; end: number; score: number }[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices[seqId]\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex = [], stats } = seqIdx\n    if (!linearIndex.length) {\n      return []\n    }\n    const e = end !== undefined ? roundUp(end, v) : (linearIndex.length - 1) * v\n    const s = start !== undefined ? roundDown(start, v) : 0\n    let depths\n    if (range) {\n      depths = new Array((e - s) / v)\n    } else {\n      depths = new Array(linearIndex.length - 1)\n    }\n    const totalSize = linearIndex[linearIndex.length - 1].blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v].blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1].blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1].blockPosition\n    }\n    return depths.map(d => {\n      return { ...d, score: (d.score * stats.lineCount) / totalSize }\n    })\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n   * @returns {Array[number]}\n   */\n  reg2bins(beg: number, end: number) {\n    end -= 1\n    return [\n      [0, 0],\n      [1 + (beg >> 26), 1 + (end >> 26)],\n      [9 + (beg >> 23), 9 + (end >> 23)],\n      [73 + (beg >> 20), 73 + (end >> 20)],\n      [585 + (beg >> 17), 585 + (end >> 17)],\n      [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ]\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    // List of bin #s that overlap min, max\n    const overlappingBins = this.reg2bins(min, max)\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (let c = 0; c < binChunks.length; ++c) {\n            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin))\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest = null\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n      if (vp) {\n        if (!lowest || vp.compareTo(lowest) < 0) {\n          lowest = vp\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n}\n","import Long from 'long'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport { longToNumber, abortBreakPoint, optimizeChunks, BaseOpts } from './util'\n\nimport IndexFile from './indexFile'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber: number\n  private depth: number\n  private minShift: number\n  constructor(args: any) {\n    super(args)\n    this.maxBinNumber = 0\n    this.depth = 0\n    this.minShift = 0\n  }\n  async lineCount(refId: number): Promise<number> {\n    const indexData = await this.parse()\n    if (!indexData) {\n      return -1\n    }\n    const idx = indexData.indices[refId]\n    if (!idx) {\n      return -1\n    }\n    const { stats } = indexData.indices[refId]\n    if (stats) {\n      return stats.lineCount\n    }\n    return -1\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Buffer, offset: number, auxLength: number) {\n    if (auxLength < 30) {\n      return {}\n    }\n\n    const data: { [key: string]: any } = {}\n    data.formatFlags = bytes.readInt32LE(offset)\n    data.coordinateType =\n      data.formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    data.format = (\n      { 0: 'generic', 1: 'SAM', 2: 'VCF' } as {\n        [key: number]: string\n      }\n    )[data.formatFlags & 0xf]\n    if (!data.format) {\n      throw new Error(`invalid Tabix preset format flags ${data.formatFlags}`)\n    }\n    data.columnNumbers = {\n      ref: bytes.readInt32LE(offset + 4),\n      start: bytes.readInt32LE(offset + 8),\n      end: bytes.readInt32LE(offset + 12),\n    }\n    data.metaValue = bytes.readInt32LE(offset + 16)\n    data.metaChar = data.metaValue ? String.fromCharCode(data.metaValue) : ''\n    data.skipLines = bytes.readInt32LE(offset + 20)\n    const nameSectionLength = bytes.readInt32LE(offset + 24)\n\n    Object.assign(\n      data,\n      this._parseNameBytes(\n        bytes.subarray(offset + 28, offset + 28 + nameSectionLength),\n      ),\n    )\n    return data\n  }\n\n  _parseNameBytes(namesBytes: Buffer) {\n    let currRefId = 0\n    let currNameStart = 0\n    const refIdToName = []\n    const refNameToId: { [key: string]: number } = {}\n    for (let i = 0; i < namesBytes.length; i += 1) {\n      if (!namesBytes[i]) {\n        if (currNameStart < i) {\n          let refName = namesBytes.toString('utf8', currNameStart, i)\n          refName = this.renameRefSeq(refName)\n          refIdToName[currRefId] = refName\n          refNameToId[refName] = currRefId\n        }\n        currNameStart = i + 1\n        currRefId += 1\n      }\n    }\n    return { refNameToId, refIdToName }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const data: { [key: string]: any } = { csi: true, maxBlockSize: 1 << 16 }\n    const buffer = (await this.filehandle.readFile(opts)) as Buffer\n    const bytes = await unzip(buffer)\n\n    // check TBI magic numbers\n    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n      data.csiVersion = 1\n    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n      data.csiVersion = 2\n    } else {\n      throw new Error('Not a CSI file')\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = bytes.readInt32LE(4)\n    this.depth = bytes.readInt32LE(8)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const auxLength = bytes.readInt32LE(12)\n    if (auxLength) {\n      Object.assign(data, this.parseAuxData(bytes, 16, auxLength))\n    }\n    data.refCount = bytes.readInt32LE(16 + auxLength)\n\n    // read the indexes for each reference sequence\n    data.indices = new Array(data.refCount)\n    let currOffset = 16 + auxLength + 4\n    for (let i = 0; i < data.refCount; i += 1) {\n      await abortBreakPoint(opts.signal)\n      // the binning index\n      const binCount = bytes.readInt32LE(currOffset)\n      currOffset += 4\n      const binIndex: { [key: string]: Chunk[] } = {}\n      let stats // < provided by parsing a pseudo-bin, if present\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(currOffset)\n        if (bin > this.maxBinNumber) {\n          // this is a fake bin that actually has stats information\n          // about the reference sequence in it\n          stats = this.parsePseudoBin(bytes, currOffset + 4)\n          currOffset += 4 + 8 + 4 + 16 + 16\n        } else {\n          const loffset = fromBytes(bytes, currOffset + 4)\n          this._findFirstData(data, loffset)\n          const chunkCount = bytes.readInt32LE(currOffset + 12)\n          currOffset += 16\n          const chunks = new Array(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, currOffset)\n            const v = fromBytes(bytes, currOffset + 8)\n            currOffset += 16\n            // this._findFirstData(data, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      data.indices[i] = { binIndex, stats }\n    }\n\n    return data\n  }\n\n  parsePseudoBin(bytes: Buffer, offset: number) {\n    const lineCount = longToNumber(\n      Long.fromBytesLE(\n        Array.prototype.slice.call(bytes, offset + 28, offset + 36),\n        true,\n      ),\n    )\n    return { lineCount }\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    const overlappingBins = this.reg2bins(min, max) // List of bin #s that overlap min, max\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (let c = 0; c < binChunks.length; ++c) {\n            chunks.push(new Chunk(binChunks[c].minv, binChunks[c].maxv, bin))\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n   * @returns {Array[number]}\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e])\n    }\n    return bins\n  }\n}\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport Constants from './constants'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('')\n\n/**\n * Class of each BAM record returned by this API.\n */\nexport default class BamRecord {\n  private data = {} as { [key: string]: any }\n  private bytes: { start: number; end: number; byteArray: Buffer }\n  private _id: number\n  private _tagOffset: number | undefined\n  private _tagList: string[] = []\n  private _allTagsParsed = false\n\n  public flags: any\n  public _refID: number\n  constructor(args: any) {\n    const { bytes, fileOffset } = args\n    const { byteArray, start } = bytes\n    this.data = {}\n    this.bytes = bytes\n    this._id = fileOffset\n    this._refID = byteArray.readInt32LE(start + 4)\n    this.data.start = byteArray.readInt32LE(start + 8)\n    this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16\n  }\n\n  get(field: string) {\n    //@ts-ignore\n    if (this[field]) {\n      //@ts-ignore\n      if (this.data[field]) {\n        return this.data[field]\n      }\n      //@ts-ignore\n      this.data[field] = this[field]()\n      return this.data[field]\n    }\n    return this._get(field.toLowerCase())\n  }\n\n  end() {\n    return this.get('start') + this.get('length_on_ref')\n  }\n\n  seq_id() {\n    return this._refID\n  }\n\n  // same as get(), except requires lower-case arguments.  used\n  // internally to save lots of calls to field.toLowerCase()\n  _get(field: string) {\n    if (field in this.data) {\n      return this.data[field]\n    }\n    this.data[field] = this._parseTag(field)\n    return this.data[field]\n  }\n\n  _tags() {\n    this._parseAllTags()\n\n    let tags = ['seq']\n\n    if (!this.isSegmentUnmapped()) {\n      tags.push(\n        'start',\n        'end',\n        'strand',\n        'score',\n        'qual',\n        'MQ',\n        'CIGAR',\n        'length_on_ref',\n        'template_length',\n      )\n    }\n    if (this.isPaired()) {\n      tags.push('next_segment_position', 'pair_orientation')\n    }\n    tags = tags.concat(this._tagList || [])\n\n    Object.keys(this.data).forEach(k => {\n      if (k[0] !== '_' && k !== 'next_seq_id') {\n        tags.push(k)\n      }\n    })\n\n    const seen: { [key: string]: boolean } = {}\n    return tags.filter(t => {\n      if (\n        (t in this.data && this.data[t] === undefined) ||\n        t === 'CG' ||\n        t === 'cg'\n      ) {\n        return false\n      }\n\n      const lt = t.toLowerCase()\n      const s = seen[lt]\n      seen[lt] = true\n      return !s\n    })\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return this.get('subfeatures')\n  }\n\n  id() {\n    return this._id\n  }\n\n  // special parsers\n  /**\n   * Mapping quality score.\n   */\n  mq() {\n    const mq = (this.get('_bin_mq_nl') & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  score() {\n    return this.get('mq')\n  }\n\n  qual() {\n    return this.qualRaw()?.join(' ')\n  }\n\n  qualRaw() {\n    if (this.isSegmentUnmapped()) {\n      return undefined\n    }\n\n    const { start, byteArray } = this.bytes\n    const p =\n      start +\n      36 +\n      this.get('_l_read_name') +\n      this.get('_n_cigar_op') * 4 +\n      this.get('_seq_bytes')\n    const lseq = this.get('seq_length')\n    return byteArray.subarray(p, p + lseq)\n  }\n\n  strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  multi_segment_next_segment_strand() {\n    if (this.isMateUnmapped()) {\n      return undefined\n    }\n    return this.isMateReverseComplemented() ? -1 : 1\n  }\n\n  name() {\n    return this.get('_read_name')\n  }\n\n  _read_name() {\n    const nl = this.get('_l_read_name')\n    const { byteArray, start } = this.bytes\n    return byteArray.toString('ascii', start + 36, start + 36 + nl - 1)\n  }\n\n  /**\n   * Get the value of a tag, parsing the tags as far as necessary.\n   * Only called if we have not already parsed that field.\n   */\n  _parseTag(tagName?: string) {\n    // if all of the tags have been parsed and we're still being\n    // called, we already know that we have no such tag, because\n    // it would already have been cached.\n    if (this._allTagsParsed) {\n      return undefined\n    }\n\n    const { byteArray, start } = this.bytes\n    let p =\n      this._tagOffset ||\n      start +\n        36 +\n        this.get('_l_read_name') +\n        this.get('_n_cigar_op') * 4 +\n        this.get('_seq_bytes') +\n        this.get('seq_length')\n\n    const blockEnd = this.bytes.end\n    let lcTag\n    while (p < blockEnd && lcTag !== tagName) {\n      const tag = String.fromCharCode(byteArray[p], byteArray[p + 1])\n      lcTag = tag.toLowerCase()\n      const type = String.fromCharCode(byteArray[p + 2])\n      p += 3\n\n      let value\n      switch (type) {\n        case 'A':\n          value = String.fromCharCode(byteArray[p])\n          p += 1\n          break\n        case 'i':\n          value = byteArray.readInt32LE(p)\n          p += 4\n          break\n        case 'I':\n          value = byteArray.readUInt32LE(p)\n          p += 4\n          break\n        case 'c':\n          value = byteArray.readInt8(p)\n          p += 1\n          break\n        case 'C':\n          value = byteArray.readUInt8(p)\n          p += 1\n          break\n        case 's':\n          value = byteArray.readInt16LE(p)\n          p += 2\n          break\n        case 'S':\n          value = byteArray.readUInt16LE(p)\n          p += 2\n          break\n        case 'f':\n          value = byteArray.readFloatLE(p)\n          p += 4\n          break\n        case 'Z':\n        case 'H':\n          value = ''\n          while (p <= blockEnd) {\n            const cc = byteArray[p++]\n            if (cc === 0) {\n              break\n            } else {\n              value += String.fromCharCode(cc)\n            }\n          }\n          break\n        case 'B': {\n          value = ''\n          const cc = byteArray[p++]\n          const Btype = String.fromCharCode(cc)\n          const limit = byteArray.readInt32LE(p)\n          p += 4\n          if (Btype === 'i') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 'I') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readUInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readUInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 's') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'S') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'c') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'C') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'f') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readFloatLE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 4\n            }\n          }\n          break\n        }\n        default:\n          console.warn(`Unknown BAM tag type '${type}', tags may be incomplete`)\n          value = undefined\n          p = blockEnd // stop parsing tags\n      }\n\n      this._tagOffset = p\n\n      this._tagList.push(tag)\n      if (lcTag === tagName) {\n        return value\n      }\n\n      this.data[lcTag] = value\n    }\n    this._allTagsParsed = true\n    return undefined\n  }\n\n  _parseAllTags() {\n    this._parseTag('')\n  }\n\n  _parseCigar(cigar: string) {\n    return (\n      //@ts-ignore\n      cigar\n        .match(/\\d+\\D/g)\n        //@ts-ignore\n        .map(op => [op.match(/\\D/)[0].toUpperCase(), parseInt(op, 10)])\n    )\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  cigar() {\n    if (this.isSegmentUnmapped()) {\n      return undefined\n    }\n\n    const { byteArray, start } = this.bytes\n    const numCigarOps = this.get('_n_cigar_op')\n    let p = start + 36 + this.get('_l_read_name')\n    const seqLen = this.get('seq_length')\n    let cigar = ''\n    let lref = 0\n\n    // check for CG tag by inspecting whether the CIGAR field\n    // contains a clip that consumes entire seqLen\n    let cigop = byteArray.readInt32LE(p)\n    let lop = cigop >> 4\n    let op = CIGAR_DECODER[cigop & 0xf]\n    if (op === 'S' && lop === seqLen) {\n      // if there is a CG the second CIGAR field will\n      // be a N tag the represents the length on ref\n      p += 4\n      cigop = byteArray.readInt32LE(p)\n      lop = cigop >> 4\n      op = CIGAR_DECODER[cigop & 0xf]\n      if (op !== 'N') {\n        console.warn('CG tag with no N tag')\n      }\n      this.data.length_on_ref = lop\n      return this.get('CG')\n    } else {\n      for (let c = 0; c < numCigarOps; ++c) {\n        cigop = byteArray.readInt32LE(p)\n        lop = cigop >> 4\n        op = CIGAR_DECODER[cigop & 0xf]\n        cigar += lop + op\n\n        // soft clip, hard clip, and insertion don't count toward\n        // the length on the reference\n        if (op !== 'H' && op !== 'S' && op !== 'I') {\n          lref += lop\n        }\n\n        p += 4\n      }\n\n      this.data.length_on_ref = lref\n      return cigar\n    }\n  }\n\n  _flags() {}\n\n  length_on_ref() {\n    if (this.data.length_on_ref) {\n      return this.data.length_on_ref\n    } else {\n      this.get('cigar') // the length_on_ref is set as a side effect\n      return this.data.length_on_ref\n    }\n  }\n\n  _n_cigar_op() {\n    return this.get('_flag_nc') & 0xffff\n  }\n\n  _l_read_name() {\n    return this.get('_bin_mq_nl') & 0xff\n  }\n\n  /**\n   * number of bytes in the sequence field\n   */\n  _seq_bytes() {\n    return (this.get('seq_length') + 1) >> 1\n  }\n\n  getReadBases() {\n    return this.seq()\n  }\n\n  seq() {\n    const { byteArray, start } = this.bytes\n    const p =\n      start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4\n    const seqBytes = this.get('_seq_bytes')\n    const len = this.get('seq_length')\n    let buf = ''\n    let i = 0\n    for (let j = 0; j < seqBytes; ++j) {\n      const sb = byteArray[p + j]\n      buf += SEQRET_DECODER[(sb & 0xf0) >> 4]\n      i++\n      if (i < len) {\n        buf += SEQRET_DECODER[sb & 0x0f]\n        i++\n      }\n    }\n    return buf\n  }\n\n  // adapted from igv.js\n  getPairOrientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      !this.isMateUnmapped() &&\n      this._refID === this._next_refid()\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      const isize = this.template_length()\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return null\n  }\n\n  _bin_mq_nl() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 12)\n  }\n\n  _flag_nc() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 16)\n  }\n\n  seq_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 20)\n  }\n\n  _next_refid() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 24)\n  }\n\n  _next_pos() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 28)\n  }\n\n  template_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 32)\n  }\n\n  toJSON() {\n    const data: { [key: string]: any } = {}\n    Object.keys(this).forEach(k => {\n      if (k.charAt(0) === '_' || k === 'bytes') {\n        return\n      }\n      //@ts-ignore\n      data[k] = this[k]\n    })\n\n    return data\n  }\n}\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  lines.forEach(line => {\n    const [tag, ...fields] = line.split(/\\t/)\n    const parsedFields = fields.map(f => {\n      const [fieldTag, value] = f.split(':', 2)\n      return { tag: fieldTag, value }\n    })\n    if (tag) {\n      data.push({ tag: tag.substr(1), data: parsedFields })\n    }\n  })\n  return data\n}\n","import crc32 from 'buffer-crc32'\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport entries from 'object.entries-ponyfill'\nimport { LocalFile, RemoteFile, GenericFilehandle } from 'generic-filehandle'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\n//locals\nimport BAI from './bai'\nimport CSI from './csi'\nimport Chunk from './chunk'\nimport BAMFeature from './record'\nimport IndexFile from './indexFile'\nimport { parseHeaderText } from './sam'\nimport {\n  abortBreakPoint,\n  checkAbortSignal,\n  timeout,\n  makeOpts,\n  BamOpts,\n  BaseOpts,\n} from './util'\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\n\nfunction flat<T>(arr: T[][]) {\n  return ([] as T[]).concat(...arr)\n}\n\nasync function gen2array<T>(gen: AsyncIterable<T>): Promise<T[]> {\n  const out: T[] = []\n  for await (const x of gen) {\n    out.push(x)\n  }\n  return out\n}\n\nexport default class BamFile {\n  private renameRefSeq: (a: string) => string\n  private bam: GenericFilehandle\n  private index: IndexFile\n  private chunkSizeLimit: number\n  private fetchSizeLimit: number\n  private header: any\n  protected chrToIndex: any\n  protected indexToChr: any\n  private yieldThreadTime: number\n\n  private featureCache = new AbortablePromiseCache({\n    //@ts-ignore\n    cache: new QuickLRU({\n      maxSize: 50,\n    }),\n    //@ts-ignore\n    fill: async ({ chunk, opts }, signal) => {\n      const { data, cpositions, dpositions } = await this._readChunk({\n        chunk,\n        opts: { ...opts, signal },\n      })\n      const feats = await this.readBamFeatures(\n        data,\n        cpositions,\n        dpositions,\n        chunk,\n      )\n      return feats\n    },\n  })\n\n  /**\n   * @param {object} args\n   * @param {string} [args.bamPath]\n   * @param {FileHandle} [args.bamFilehandle]\n   * @param {string} [args.baiPath]\n   * @param {FileHandle} [args.baiFilehandle]\n   */\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    fetchSizeLimit,\n    chunkSizeLimit,\n    yieldThreadTime = 100,\n    renameRefSeqs = n => n,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    fetchSizeLimit?: number\n    chunkSizeLimit?: number\n    renameRefSeqs?: (a: string) => string\n    yieldThreadTime?: number\n  }) {\n    this.renameRefSeq = renameRefSeqs\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else {\n      throw new Error('unable to infer index format')\n    }\n    this.fetchSizeLimit = fetchSizeLimit || 500000000 // 500MB\n    this.chunkSizeLimit = chunkSizeLimit || 300000000 // 300MB\n    this.yieldThreadTime = yieldThreadTime\n  }\n\n  async getHeader(origOpts: AbortSignal | BaseOpts = {}) {\n    const opts = makeOpts(origOpts)\n    const indexData = await this.index.parse(opts)\n    const ret = indexData.firstDataLine\n      ? indexData.firstDataLine.blockPosition + 65535\n      : undefined\n    let buffer\n    if (ret) {\n      const res = await this.bam.read(\n        Buffer.alloc(ret + blockLen),\n        0,\n        ret + blockLen,\n        0,\n        opts,\n      )\n\n      const { bytesRead } = res\n      ;({ buffer } = res)\n      if (!bytesRead) {\n        throw new Error('Error reading header')\n      }\n      if (bytesRead < ret) {\n        buffer = buffer.subarray(0, bytesRead)\n      } else {\n        buffer = buffer.subarray(0, ret)\n      }\n    } else {\n      buffer = (await this.bam.readFile(opts)) as Buffer\n    }\n\n    const uncba = await unzip(buffer)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    this.header = uncba.toString('utf8', 8, 8 + headLen)\n    const { chrToIndex, indexToChr } = await this._readRefSeqs(\n      headLen + 8,\n      65535,\n      opts,\n    )\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n\n    return parseHeaderText(this.header)\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  // the full length of the refseq block is not given in advance so this grabs\n  // a chunk and doubles it if all refseqs haven't been processed\n  async _readRefSeqs(\n    start: number,\n    refSeqBytes: number,\n    opts: BaseOpts = {},\n  ): Promise<{\n    chrToIndex: { [key: string]: number }\n    indexToChr: { refName: string; length: number }[]\n  }> {\n    if (start > refSeqBytes) {\n      return this._readRefSeqs(start, refSeqBytes * 2, opts)\n    }\n    const size = refSeqBytes + blockLen\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      refSeqBytes,\n      0,\n      opts,\n    )\n    if (!bytesRead) {\n      throw new Error('Error reading refseqs from header')\n    }\n    const uncba = await unzip(\n      buffer.subarray(0, Math.min(bytesRead, refSeqBytes)),\n    )\n    const nRef = uncba.readInt32LE(start)\n    let p = start + 4\n    const chrToIndex: { [key: string]: number } = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    for (let i = 0; i < nRef; i += 1) {\n      const lName = uncba.readInt32LE(p)\n      const refName = this.renameRefSeq(\n        uncba.toString('utf8', p + 4, p + 4 + lName - 1),\n      )\n      const lRef = uncba.readInt32LE(p + lName + 4)\n\n      chrToIndex[refName] = i\n      indexToChr.push({ refName, length: lRef })\n\n      p = p + 8 + lName\n      if (p > uncba.length) {\n        console.warn(\n          `BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`,\n        )\n        return this._readRefSeqs(start, refSeqBytes * 2, opts)\n      }\n    }\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts: BamOpts = {\n      viewAsPairs: false,\n      pairAcrossChr: false,\n      maxInsertSize: 200000,\n    },\n  ) {\n    return flat(\n      await gen2array(this.streamRecordsForRange(chr, min, max, opts)),\n    )\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts: BamOpts = {},\n  ) {\n    const { signal } = opts\n    const chrId = this.chrToIndex && this.chrToIndex[chr]\n    let chunks: Chunk[]\n    if (!(chrId >= 0)) {\n      chunks = []\n    } else {\n      chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n\n      if (!chunks) {\n        throw new Error('Error in index fetch')\n      }\n    }\n\n    for (let i = 0; i < chunks.length; i += 1) {\n      await abortBreakPoint(signal)\n      const size = chunks[i].fetchedSize()\n      if (size > this.chunkSizeLimit) {\n        throw new Error(\n          `Too many BAM features. BAM chunk size ${size} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit}`,\n        )\n      }\n    }\n\n    const totalSize = chunks\n      .map(s => s.fetchedSize())\n      .reduce((a, b) => a + b, 0)\n    if (totalSize > this.fetchSizeLimit) {\n      throw new Error(\n        `data size of ${totalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n    yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts)\n  }\n\n  async *_fetchChunkFeatures(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts,\n  ) {\n    const { viewAsPairs = false } = opts\n    const feats = []\n    let done = false\n\n    for (let i = 0; i < chunks.length; i++) {\n      const c = chunks[i]\n      const records = (await this.featureCache.get(\n        c.toString(),\n        {\n          chunk: c,\n          opts,\n        },\n        opts.signal,\n      )) as BAMFeature[]\n\n      const recs = []\n      for (let i = 0; i < records.length; i += 1) {\n        const feature = records[i]\n        if (feature.seq_id() === chrId) {\n          if (feature.get('start') >= max) {\n            // past end of range, can stop iterating\n            done = true\n            break\n          } else if (feature.get('end') >= min) {\n            // must be in range\n            recs.push(feature)\n          }\n        }\n      }\n      feats.push(recs)\n      yield recs\n      if (done) {\n        break\n      }\n    }\n\n    checkAbortSignal(opts.signal)\n    if (viewAsPairs) {\n      yield this.fetchPairs(chrId, feats, opts)\n    }\n  }\n\n  async fetchPairs(chrId: number, feats: BAMFeature[][], opts: BamOpts) {\n    const { pairAcrossChr = false, maxInsertSize = 200000 } = opts\n    const unmatedPairs: { [key: string]: boolean } = {}\n    const readIds: { [key: string]: number } = {}\n    feats.map(ret => {\n      const readNames: { [key: string]: number } = {}\n      for (let i = 0; i < ret.length; i++) {\n        const name = ret[i].name()\n        const id = ret[i].id()\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name]++\n        readIds[id] = 1\n      }\n      entries(readNames).forEach(([k, v]: [string, number]) => {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      })\n    })\n\n    const matePromises: Promise<Chunk[]>[] = []\n    feats.map(ret => {\n      for (let i = 0; i < ret.length; i++) {\n        const f = ret[i]\n        const name = f.name()\n        const start = f.get('start')\n        const pnext = f._next_pos()\n        const rnext = f._next_refid()\n        if (\n          unmatedPairs[name] &&\n          (pairAcrossChr ||\n            (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))\n        ) {\n          matePromises.push(\n            this.index.blocksForRange(rnext, pnext, pnext + 1, opts),\n          )\n        }\n      }\n    })\n\n    // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n    // concatenated, then filter dup chunks)\n    const mateChunks = flat(await Promise.all(matePromises))\n      .sort()\n      .filter(\n        (item, pos, ary) => !pos || item.toString() !== ary[pos - 1].toString(),\n      )\n\n    const mateTotalSize = mateChunks\n      .map(s => s.fetchedSize())\n      .reduce((a, b) => a + b, 0)\n    if (mateTotalSize > this.fetchSizeLimit) {\n      throw new Error(\n        `data size of ${mateTotalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n    const mateFeatPromises = mateChunks.map(async c => {\n      const { data, cpositions, dpositions, chunk } = await this._readChunk({\n        chunk: c,\n        opts,\n      })\n      const feats = await this.readBamFeatures(\n        data,\n        cpositions,\n        dpositions,\n        chunk,\n      )\n      const mateRecs = []\n      for (let i = 0; i < feats.length; i += 1) {\n        const feature = feats[i]\n        if (unmatedPairs[feature.get('name')] && !readIds[feature.id()]) {\n          mateRecs.push(feature)\n        }\n      }\n      return mateRecs\n    })\n    return flat(await Promise.all(mateFeatPromises))\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: Chunk; opts: BaseOpts }) {\n    const size = chunk.fetchedSize()\n    const { buffer, bytesRead } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      size,\n      chunk.minv.blockPosition,\n      opts,\n    )\n\n    const {\n      buffer: data,\n      cpositions,\n      dpositions,\n    } = await unzipChunkSlice(\n      buffer.subarray(0, Math.min(bytesRead, size)),\n      chunk,\n    )\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(\n    ba: Buffer,\n    cpositions: number[],\n    dpositions: number[],\n    chunk: Chunk,\n  ) {\n    let blockStart = 0\n    const sink = []\n    let pos = 0\n    let last = +Date.now()\n\n    while (blockStart + 4 < ba.length) {\n      const blockSize = ba.readInt32LE(blockStart)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      // increment position to the current decompressed status\n      if (dpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) {}\n        pos--\n      }\n\n      // only try to read the feature if we have all the bytes for it\n      if (blockEnd < ba.length) {\n        const feature = new BAMFeature({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          // the below results in an automatically calculated file-offset based ID\n          // if the info for that is available, otherwise crc32 of the features\n          //\n          // cpositions[pos] refers to actual file offset of a bgzip block boundaries\n          //\n          // we multiply by (1 <<8) in order to make sure each block has a \"unique\"\n          // address space so that data in that block could never overlap\n          //\n          // then the blockStart-dpositions is an uncompressed file offset from\n          // that bgzip block boundary, and since the cpositions are multiplied by\n          // (1 << 8) these uncompressed offsets get a unique space\n          //\n          // this has an extra chunk.minv.dataPosition added on because it blockStart\n          // starts at 0 instead of chunk.minv.dataPosition\n          //\n          // the +1 is just to avoid any possible uniqueId 0 but this does not realistically happen\n          fileOffset: cpositions\n            ? cpositions[pos] * (1 << 8) +\n              (blockStart - dpositions[pos]) +\n              chunk.minv.dataPosition +\n              1\n            : // must be slice, not subarray for buffer polyfill on web\n              crc32.signed(ba.slice(blockStart, blockEnd)),\n        })\n\n        sink.push(feature)\n        if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n          await timeout(1)\n          last = +Date.now()\n        }\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const refId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.hasRefSeq(refId)\n  }\n\n  async lineCount(seqName: string) {\n    const refId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.lineCount(refId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    await this.index.parse()\n    const seqId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.indexCov(seqId, start, end)\n  }\n\n  async blocksForRange(\n    seqName: string,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ) {\n    await this.index.parse()\n    const seqId = this.chrToIndex && this.chrToIndex[seqName]\n    return this.index.blocksForRange(seqId, start, end, opts)\n  }\n}\n","import { BaseOpts, BamOpts } from './util'\nimport BamFile, { BAM_MAGIC } from './bamFile'\nimport 'cross-fetch/polyfill'\nimport Chunk from './chunk'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport { parseHeaderText } from './sam'\n\ninterface HeaderLine {\n  tag: string\n  value: string\n}\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\nasync function concat(arr: { url: string }[], opts: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async (chunk: HtsgetChunk) => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        return Buffer.from(url.split(',')[1], 'base64')\n      } else {\n        //remove referer header, it is not even allowed to be specified\n        //@ts-ignore\n        //eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { referer, ...rest } = headers\n        const res = await fetch(url, {\n          ...opts,\n          headers: { ...opts.headers, ...rest },\n        })\n        if (!res.ok) {\n          throw new Error(`Failed to fetch ${res.statusText}`)\n        }\n        return Buffer.from(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return Buffer.concat(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile extends BamFile {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: { trackId: string; baseUrl: string }) {\n    // @ts-ignore override bam defaults\n    super({ bamFilehandle: '?', baiFilehandle: '?' })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts: BamOpts = {\n      viewAsPairs: false,\n      pairAcrossChr: false,\n      maxInsertSize: 200000,\n    },\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex && this.chrToIndex[chr]\n    const result = await fetch(url, { ...opts })\n    if (!result.ok) {\n      throw new Error(result.statusText)\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls.slice(1), opts)\n    const chunk = {\n      buffer: uncba,\n      chunk: { minv: { dataPosition: 0 } },\n      toString() {\n        return `${chr}_${min}_${max}`\n      },\n    }\n\n    yield* this._fetchChunkFeatures(\n      // @ts-ignore\n      [chunk],\n      chrId,\n      min,\n      max,\n      opts,\n    )\n  }\n\n  //@ts-ignore\n  async _readChunk(params: {\n    chunk: { buffer: Buffer; chunk: Chunk }\n    opts: BaseOpts\n  }) {\n    const { chunk } = params\n    const { buffer, chunk: c2 } = chunk\n    return { data: buffer, cpositions: null, dpositions: null, chunk: c2 }\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(`Failed to fetch ${result.statusText}`)\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    const headerText = uncba.toString('utf8', 8, 8 + headLen)\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter((l: { tag: string }) => l.tag === 'SQ')\n    sqLines.forEach((sqLine: { data: HeaderLine[] }, refId: number) => {\n      sqLine.data.forEach((item: HeaderLine) => {\n        if (item.tag === 'SN') {\n          // this is the ref name\n          const refName = item.value\n          nameToId[refName] = refId\n          idToName[refId] = refName\n        }\n      })\n    })\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","'use strict';\n\nclass QuickLRU {\n\tconstructor(options = {}) {\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst value = this.oldCache.get(key);\n\t\t\tthis._set(key, value);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tset(key, value) {\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, value);\n\t\t} else {\n\t\t\tthis._set(key, value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\treturn this.cache.has(key) || this.oldCache.has(key);\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this.oldCache.get(key);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tyield item;\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget size() {\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn this._size + oldCacheSize;\n\t}\n}\n\nmodule.exports = QuickLRU;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n","(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(typeof self !== 'undefined' ? self : this);\n","export default function _AwaitValue(value) {\n  this.wrapped = value;\n}","export default function _asyncGeneratorDelegate(inner, awaitWrap) {\n  var iter = {},\n      waiting = false;\n\n  function pump(key, value) {\n    waiting = true;\n    value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    });\n    return {\n      done: false,\n      value: awaitWrap(value)\n    };\n  }\n\n  ;\n\n  iter[typeof Symbol !== \"undefined\" && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  };\n\n  iter.next = function (value) {\n    if (waiting) {\n      waiting = false;\n      return value;\n    }\n\n    return pump(\"next\", value);\n  };\n\n  if (typeof inner[\"throw\"] === \"function\") {\n    iter[\"throw\"] = function (value) {\n      if (waiting) {\n        waiting = false;\n        throw value;\n      }\n\n      return pump(\"throw\", value);\n    };\n  }\n\n  if (typeof inner[\"return\"] === \"function\") {\n    iter[\"return\"] = function (value) {\n      if (waiting) {\n        waiting = false;\n        return value;\n      }\n\n      return pump(\"return\", value);\n    };\n  }\n\n  return iter;\n}","export default function _asyncIterator(iterable) {\n  var method,\n      async,\n      sync,\n      retry = 2;\n\n  for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {\n    if (async && null != (method = iterable[async])) return method.call(iterable);\n    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));\n    async = \"@@asyncIterator\", sync = \"@@iterator\";\n  }\n\n  throw new TypeError(\"Object is not async iterable\");\n}\n\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return {\n        value: value,\n        done: done\n      };\n    });\n  }\n\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) {\n    this.s = s, this.n = s.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(value) {\n      var ret = this.s[\"return\"];\n      return void 0 === ret ? Promise.resolve({\n        value: value,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(value) {\n      var thr = this.s[\"return\"];\n      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(s);\n}","import AwaitValue from \"./AwaitValue.js\";\nexport default function _awaitAsyncGenerator(value) {\n  return new AwaitValue(value);\n}","import AwaitValue from \"./AwaitValue.js\";\nexport default function AsyncGenerator(gen) {\n  var front, back;\n\n  function send(key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n\n      if (back) {\n        back = back.next = request;\n      } else {\n        front = back = request;\n        resume(key, arg);\n      }\n    });\n  }\n\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg);\n      var value = result.value;\n      var wrappedAwait = value instanceof AwaitValue;\n      Promise.resolve(wrappedAwait ? value.wrapped : value).then(function (arg) {\n        if (wrappedAwait) {\n          resume(key === \"return\" ? \"return\" : \"next\", arg);\n          return;\n        }\n\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: true\n        });\n        break;\n\n      case \"throw\":\n        front.reject(value);\n        break;\n\n      default:\n        front.resolve({\n          value: value,\n          done: false\n        });\n        break;\n    }\n\n    front = front.next;\n\n    if (front) {\n      resume(front.key, front.arg);\n    } else {\n      back = null;\n    }\n  }\n\n  this._invoke = send;\n\n  if (typeof gen[\"return\"] !== \"function\") {\n    this[\"return\"] = undefined;\n  }\n}\n\nAsyncGenerator.prototype[typeof Symbol === \"function\" && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n};\n\nAsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n};\n\nAsyncGenerator.prototype[\"throw\"] = function (arg) {\n  return this._invoke(\"throw\", arg);\n};\n\nAsyncGenerator.prototype[\"return\"] = function (arg) {\n  return this._invoke(\"return\", arg);\n};","import AsyncGenerator from \"./AsyncGenerator.js\";\nexport default function _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}"],"names":["VirtualOffset","blockPosition","dataPosition","this","b","min","i","args","length","compareTo","fromBytes","bytes","offset","bigendian","Error","Chunk","minv","maxv","bin","fetchedSize","undefined","_fetchedSize","toUniqueString","IndexFile","filehandle","renameRefSeq","n","data","virtualOffset","currentFdl","firstDataLine","opts","setupP","_parse","catch","e","seqId","parse","indices","binIndex","timeout","ms","Promise","resolve","setTimeout","longToNumber","long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","checkAbortSignal","signal","aborted","DOMException","code","abortBreakPoint","makeOpts","obj","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","sort","c0","c1","dif","forEach","chunk","chunk1","chunk2","push","roundDown","multiple","roundUp","BAI","lineCount","Long","Array","prototype","slice","call","refId","prom","index","ret","stats","baiP","readFile","bai","maxBlockSize","fetchBai","readUInt32LE","refCount","readInt32LE","binLimit","currOffset","binCount","j","parsePseudoBin","chunkCount","k","u","v","_findFirstData","linearCount","linearIndex","start","end","range","indexData","seqIdx","s","depths","totalSize","currentPos","score","map","d","beg","max","ba","overlappingBins","reg2bins","binChunks","c","nintv","minLin","Math","maxLin","vp","rshift","num","bits","floor","CSI","maxBinNumber","depth","minShift","auxLength","formatFlags","coordinateType","format","columnNumbers","ref","metaValue","metaChar","String","fromCharCode","skipLines","nameSectionLength","Object","assign","_parseNameBytes","subarray","namesBytes","currRefId","currNameStart","refIdToName","refNameToId","refName","toString","csi","buffer","unzip","csiVersion","parseAuxData","loffset","l","t","bins","SEQRET_DECODER","split","CIGAR_DECODER","BamRecord","_tagList","_allTagsParsed","fileOffset","byteArray","_id","_refID","flags","field","_get","toLowerCase","get","_parseTag","_parseAllTags","tags","isSegmentUnmapped","isPaired","concat","keys","seen","filter","lt","mq","qualRaw","_a","join","p","lseq","isReverseComplemented","isMateUnmapped","isMateReverseComplemented","nl","tagName","lcTag","_tagOffset","blockEnd","tag","type","value","readInt8","readUInt8","readInt16LE","readUInt16LE","readFloatLE","cc","Btype","limit","cigop","console","warn","cigar","match","op","toUpperCase","parseInt","Constants","numCigarOps","seqLen","lref","lop","length_on_ref","seq","seqBytes","len","buf","sb","_next_refid","s1","s2","o1","o2","isRead1","isRead2","tmp","template_length","charAt","parseHeaderText","text","lines","line","parsedFields","f","substr","BAM_MAGIC","blockLen","flat","arr","gen2array","gen","out","x","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","fetchSizeLimit","chunkSizeLimit","yieldThreadTime","renameRefSeqs","featureCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","_readChunk","cpositions","dpositions","readBamFeatures","feats","bam","LocalFile","RemoteFile","origOpts","read","Buffer","alloc","res","bytesRead","uncba","headLen","header","_readRefSeqs","chrToIndex","indexToChr","getHeader","refSeqBytes","size","nRef","lName","lRef","chr","viewAsPairs","pairAcrossChr","maxInsertSize","streamRecordsForRange","chrId","blocksForRange","reduce","a","toLocaleString","_fetchChunkFeatures","done","records","recs","feature","seq_id","fetchPairs","unmatedPairs","readIds","readNames","name","id","entries","matePromises","pnext","_next_pos","rnext","abs","all","mateChunks","item","pos","ary","mateTotalSize","mateFeatPromises","mateRecs","unzipChunkSlice","blockStart","sink","last","Date","now","blockSize","BAMFeature","crc32","seqName","hasRefSeq","indexCov","url","headers","startsWith","from","referer","rest","fetch","ok","statusText","arrayBuffer","elt","HtsgetFile","baseUrl","trackId","base","result","json","htsget","urls","params","c2","headerText","samHeader","idToName","nameToId","sqLine","options","TypeError","Map","oldCache","_size","key","set","has","_set","deleted","delete","clear","oldCacheSize","Symbol","iterator","module","exports","__importDefault","mod","__esModule","defineProperty","abortcontroller_ponyfill_1","require","AggregateAbortController_1","AggregateStatusReporter_1","fillCallback","entry","statusCallback","aborter","default","statusReporter","addCallback","newEntry","promise","message","callback","settled","addSignal","addEventListener","evict","then","error","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","next","exception","checkForSingleAbort","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","AggregateStatusReporter","callbacks","currentMessage","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1","support","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","indexOf","normalizeName","test","normalizeValue","iteratorFor","items","shift","Headers","append","isArray","getOwnPropertyNames","consumed","body","bodyUsed","reject","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","bufferClone","view","Uint8Array","byteLength","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","readAsText","readBlobAsText","chars","readArrayBufferAsText","formData","decode","JSON","oldValue","hasOwnProperty","thisArg","values","methods","Request","input","credentials","method","mode","upcased","normalizeMethod","referrer","form","trim","replace","decodeURIComponent","parseHeaders","rawHeaders","parts","Response","bodyInit","status","clone","response","redirectStatuses","redirect","RangeError","location","err","stack","create","constructor","init","request","xhr","XMLHttpRequest","abortXhr","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","onreadystatechange","readyState","removeEventListener","send","polyfill","_AwaitValue","wrapped","_asyncGeneratorDelegate","inner","awaitWrap","iter","waiting","pump","_asyncIterator","iterable","async","sync","retry","asyncIterator","AsyncFromSyncIterator","AsyncFromSyncIteratorContinuation","r","apply","arguments","thr","_awaitAsyncGenerator","AsyncGenerator","front","back","resume","arg","wrappedAwait","AwaitValue","settle","_invoke","_wrapAsyncGenerator","fn"],"sourceRoot":""}