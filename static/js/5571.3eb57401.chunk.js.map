{"version":3,"file":"static/js/5571.3eb57401.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/twobit/src/twoBitFile.ts","../../../plugins/sequence/src/TwoBitAdapter/TwoBitAdapter.ts"],"sourcesContent":["import Long from 'long'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\nimport { Parser } from '@gmod/binary-parser'\n\nconst TWOBIT_MAGIC = 0x1a412743\n\nfunction tinyMemoize(_class: any, methodName: string) {\n  const method = _class.prototype[methodName]\n  const memoAttrName = `_memo_${methodName}`\n  _class.prototype[methodName] = function _tinyMemoized() {\n    if (!(memoAttrName in this)) {\n      this[memoAttrName] = method.call(this)\n    }\n    return this[memoAttrName]\n  }\n}\n\nconst twoBit = ['T', 'C', 'A', 'G']\n// byteTo4Bases is an array of byteValue -> 'ACTG'\n// the weird `...keys()` incantation generates an array of numbers 0 to 255\nconst byteTo4Bases = [] as string[]\nfor (let i = 0; i < 256; i++) {\n  byteTo4Bases.push(\n    twoBit[(i >> 6) & 3] +\n      twoBit[(i >> 4) & 3] +\n      twoBit[(i >> 2) & 3] +\n      twoBit[i & 3],\n  )\n}\n\ntype ParserName = 'header' | 'index' | 'record1' | 'record2' | 'record3'\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase())\n\nexport default class TwoBitFile {\n  private filehandle: GenericFilehandle\n  private isBigEndian?: boolean\n  private version?: number\n\n  /**\n   * @param {object} args\n   * @param {string} [args.path] filesystem path for the .2bit file to open\n   * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n   *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n   */\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new Error('must supply path or filehandle')\n    }\n    this.isBigEndian = undefined\n  }\n\n  async _getParser(name: ParserName) {\n    const parser = (await this._getParsers())[name]\n    if (!parser) {\n      throw new Error(`parser ${name} not found`)\n    }\n    return parser\n  }\n\n  async _detectEndianness() {\n    const ret = await this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0)\n    const { buffer } = ret\n    if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {\n      this.isBigEndian = false\n      this.version = buffer.readInt32LE(4)\n    } else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {\n      this.isBigEndian = true\n      this.version = buffer.readInt32BE(4)\n    } else {\n      throw new Error('not a 2bit file')\n    }\n  }\n\n  // memoize\n  /**\n   * @private\n   * detects the file's endianness and instantiates our binary parsers accordingly\n   */\n  async _getParsers() {\n    await this._detectEndianness()\n\n    const endianess = this.isBigEndian ? 'big' : 'little'\n    const lebe = this.isBigEndian ? 'be' : 'le'\n\n    let indexEntryParser = new Parser()\n      .endianess(endianess)\n      .uint8('nameLength')\n      .string('name', { length: 'nameLength' })\n    if (this.version === 1) {\n      indexEntryParser = indexEntryParser.buffer('offsetBytes', {\n        length: 8,\n      })\n    } else {\n      indexEntryParser = indexEntryParser.uint32('offset')\n    }\n    /* istanbul ignore next */\n    const header = new Parser()\n      .endianess(endianess)\n      .int32('magic', {\n        assert: (m: number) => m === 0x1a412743,\n      })\n      .int32('version', {\n        /* istanbul ignore next */\n        assert: (v: number) => v === 0 || v === 1,\n      })\n      .uint32('sequenceCount', {\n        /* istanbul ignore next */\n        assert: (v: number) => v >= 0,\n      })\n      .uint32('reserved')\n\n    return {\n      header,\n      index: new Parser()\n        .endianess(endianess)\n        .uint32('sequenceCount')\n        .uint32('reserved')\n        .array('index', {\n          length: 'sequenceCount',\n          type: indexEntryParser,\n        }),\n      record1: new Parser()\n        .endianess(endianess)\n        .uint32('dnaSize')\n        .uint32('nBlockCount'),\n      record2: new Parser()\n        .endianess(endianess)\n        .uint32('nBlockCount')\n        .array('nBlockStarts', {\n          length: 'nBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .array('nBlockSizes', {\n          length: 'nBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .uint32('maskBlockCount'),\n      record3: new Parser()\n        .endianess(endianess)\n        .uint32('maskBlockCount')\n        .array('maskBlockStarts', {\n          length: 'maskBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .array('maskBlockSizes', {\n          length: 'maskBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .int32('reserved'),\n      // .buffer('packedDna', { length: 'dnaSize' }),\n    }\n  }\n\n  // memoize\n  /**\n   * @returns {Promise} for object with the file's header information, like\n   *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`\n   */\n  async getHeader() {\n    await this._detectEndianness()\n\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(16),\n      0,\n      16,\n      0,\n    )\n    const headerParser = await this._getParser('header')\n    return headerParser.parse(buffer).result\n  }\n\n  // memoize\n  /**\n   * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`\n   */\n  async getIndex() {\n    const header = await this.getHeader()\n    const maxIndexLength =\n      8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4))\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(maxIndexLength),\n      0,\n      maxIndexLength,\n      8,\n    )\n    const indexParser = await this._getParser('index')\n    const indexData = indexParser.parse(buffer).result.index\n    const index = {} as { [key: string]: number }\n    if (this.version === 1) {\n      indexData.forEach(\n        ({ name, offsetBytes }: { name: string; offsetBytes: number }) => {\n          const long = Long.fromBytes(offsetBytes, true, !this.isBigEndian)\n          if (long.greaterThan(Number.MAX_SAFE_INTEGER)) {\n            throw new Error(\n              'integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.',\n            )\n          }\n          index[name] = long.toNumber()\n        },\n      )\n    } else {\n      indexData.forEach(\n        ({ name, offset }: { name: string; offset: number }) => {\n          index[name] = offset\n        },\n      )\n    }\n    return index\n  }\n\n  /**\n   * @returns {Promise} for an array of string sequence names that are found in the file\n   */\n  async getSequenceNames() {\n    const index = await this.getIndex()\n    return Object.keys(index)\n  }\n\n  /**\n   * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`\n   */\n  async getSequenceSizes() {\n    const index = await this.getIndex()\n    const seqNames = Object.keys(index)\n    const sizePromises = Object.values(index).map(offset =>\n      this._getSequenceSize(offset as number),\n    )\n    const sizes = await Promise.all(sizePromises)\n    const returnObject = {} as { [key: string]: number }\n    for (let i = 0; i < seqNames.length; i += 1) {\n      returnObject[seqNames[i]] = sizes[i]\n    }\n    return returnObject\n  }\n\n  /**\n   * @param {string} seqName name of the sequence\n   * @returns {Promise} for the sequence's length, or undefined if it is not in the file\n   */\n  async getSequenceSize(seqName: string) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    return this._getSequenceSize(offset)\n  }\n\n  async _getSequenceSize(offset: number) {\n    // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads\n    if (offset === undefined || offset < 0) {\n      throw new Error('invalid offset')\n    }\n    const rec1 = await this._parseItem(offset, 8, 'record1')\n    return rec1.dnaSize\n  }\n\n  async _getSequenceRecord(offset: number) {\n    // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads\n    if (offset === undefined || offset < 0) {\n      throw new Error('invalid offset')\n    }\n    const rec1 = await this._parseItem(offset, 8, 'record1')\n    const rec2DataLength = rec1.nBlockCount * 8 + 8\n    const rec2 = await this._parseItem(offset + 4, rec2DataLength, 'record2')\n    const rec3DataLength = rec2.maskBlockCount * 8 + 8\n    const rec3 = await this._parseItem(\n      offset + 4 + rec2DataLength - 4,\n      rec3DataLength,\n      'record3',\n    )\n\n    const rec = {\n      dnaSize: rec1.dnaSize,\n      nBlocks: { starts: rec2.nBlockStarts, sizes: rec2.nBlockSizes },\n      maskBlocks: { starts: rec3.maskBlockStarts, sizes: rec3.maskBlockSizes },\n      dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength,\n    }\n    return rec\n  }\n\n  async _parseItem(offset: number, length: number, parserName: ParserName) {\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(length),\n      0,\n      length,\n      offset,\n    )\n    const parser = await this._getParser(parserName)\n    return parser.parse(buffer).result\n  }\n\n  /**\n   * @param {string} seqName name of the sequence you want\n   * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.\n   * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence\n   * @returns {Promise} for a string of sequence bases\n   */\n  async getSequence(seqName: string, regionStart = 0, regionEnd: number) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    // fetch the record for the seq\n    const record = await this._getSequenceRecord(offset)\n\n    if (regionStart < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    // end defaults to the end of the sequence\n    if (regionEnd === undefined || regionEnd > record.dnaSize) {\n      regionEnd = record.dnaSize\n    }\n\n    const nBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.nBlocks.starts,\n      record.nBlocks.sizes,\n    )\n    const maskBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.maskBlocks.starts,\n      record.maskBlocks.sizes,\n    )\n\n    const baseBytes = Buffer.allocUnsafe(\n      Math.ceil((regionEnd - regionStart) / 4) + 1,\n    )\n    const baseBytesOffset = Math.floor(regionStart / 4)\n    const { buffer } = await this.filehandle.read(\n      baseBytes,\n      0,\n      baseBytes.length,\n      record.dnaPosition + baseBytesOffset,\n    )\n\n    let sequenceBases = ''\n    for (\n      let genomicPosition = regionStart;\n      genomicPosition < regionEnd;\n      genomicPosition += 1\n    ) {\n      // check whether we are currently masked\n      while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {\n        maskBlocks.shift()\n      }\n      const baseIsMasked =\n        maskBlocks[0] &&\n        maskBlocks[0].start <= genomicPosition &&\n        maskBlocks[0].end > genomicPosition\n\n      // process the N block if we have one\n      if (\n        nBlocks[0] &&\n        genomicPosition >= nBlocks[0].start &&\n        genomicPosition < nBlocks[0].end\n      ) {\n        const currentNBlock = nBlocks.shift()\n        for (\n          ;\n          genomicPosition < currentNBlock.end && genomicPosition < regionEnd;\n          genomicPosition += 1\n        ) {\n          sequenceBases += baseIsMasked ? 'n' : 'N'\n        }\n        genomicPosition -= 1\n      } else {\n        const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset\n        const subPosition = genomicPosition % 4\n        const byte = buffer[bytePosition]\n        sequenceBases += baseIsMasked\n          ? maskedByteTo4Bases[byte][subPosition]\n          : byteTo4Bases[byte][subPosition]\n      }\n    }\n\n    return sequenceBases\n  }\n\n  _getOverlappingBlocks(\n    regionStart: number,\n    regionEnd: number,\n    blockStarts: number[],\n    blockSizes: number[],\n  ) {\n    // find the start and end indexes of the blocks that match\n    let startIndex\n    let endIndex\n    for (let i = 0; i < blockStarts.length; i += 1) {\n      const blockStart = blockStarts[i]\n      const blockSize = blockSizes[i]\n      if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n        // block does not overlap the region\n        if (startIndex !== undefined) {\n          endIndex = i\n          break\n        }\n      } else if (startIndex === undefined) {\n        startIndex = i\n      } // block does overlap the region, record this if it is the first\n    }\n\n    if (startIndex === undefined) {\n      return []\n    }\n\n    // now format some block objects to return\n    if (endIndex === undefined) {\n      endIndex = blockStarts.length\n    }\n\n    const blocks = new Array(endIndex - startIndex)\n    for (let blockNum = startIndex; blockNum < endIndex; blockNum += 1) {\n      blocks[blockNum - startIndex] = {\n        start: blockStarts[blockNum],\n        end: blockStarts[blockNum] + blockSizes[blockNum],\n        size: blockSizes[blockNum],\n      }\n    }\n    return blocks\n  }\n}\n\ntinyMemoize(TwoBitFile, '_getParsers')\ntinyMemoize(TwoBitFile, 'getIndex')\ntinyMemoize(TwoBitFile, 'getHeader')\n","import { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TwoBitFile } from '@gmod/twobit'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration/configurationSchema'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n  private twobit: TwoBitFile\n\n  // the chromSizesData can be used to speed up loading since TwoBit has to do\n  // many range requests at startup to perform the getRegions request\n  protected chromSizesData: Promise<Record<string, number> | undefined>\n\n  private async initChromSizes() {\n    const conf = readConfObject(this.config, 'chromSizesLocation')\n    // check against default and empty in case someone makes the field blank in\n    // config editor, may want better way to check \"optional config slots\" in\n    // future\n    if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n      const file = openLocation(conf, this.pluginManager)\n      const data = await file.readFile('utf8')\n      return Object.fromEntries(\n        data\n          ?.split(/\\n|\\r\\n|\\r/)\n          .filter(line => !!line.trim())\n          .map(line => {\n            const [name, length] = line.split('\\t')\n            return [name, +length]\n          }),\n      )\n    }\n    return undefined\n  }\n\n  constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    this.chromSizesData = this.initChromSizes()\n    this.twobit = new TwoBitFile({\n      filehandle: openLocation(\n        readConfObject(config, 'twoBitLocation'),\n        this.pluginManager,\n      ),\n    })\n  }\n\n  public async getRefNames() {\n    const chromSizesData = await this.chromSizesData\n    if (chromSizesData) {\n      return Object.keys(chromSizesData)\n    }\n    return this.twobit.getSequenceNames()\n  }\n\n  public async getRegions(): Promise<NoAssemblyRegion[]> {\n    const chromSizesData = await this.chromSizesData\n    if (chromSizesData) {\n      return Object.keys(chromSizesData).map(refName => ({\n        refName,\n        start: 0,\n        end: chromSizesData[refName],\n      }))\n    }\n    const refSizes = await this.twobit.getSequenceSizes()\n    return Object.keys(refSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: refSizes[refName],\n    }))\n  }\n\n  /**\n   * Fetch features for a certain region\n   * @param param -\n   * @returns Observable of Feature objects in the region\n   */\n  public getFeatures({ refName, start, end }: NoAssemblyRegion) {\n    return ObservableCreate<Feature>(async observer => {\n      const size = await this.twobit.getSequenceSize(refName)\n      const regionEnd = size !== undefined ? Math.min(size, end) : end\n      const seq = await this.twobit.getSequence(refName, start, regionEnd)\n      if (seq) {\n        observer.next(\n          new SimpleFeature({\n            id: `${refName} ${start}-${regionEnd}`,\n            data: { refName, start, end: regionEnd, seq },\n          }),\n        )\n      }\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  public freeResources(/* { region } */): void {}\n}\n"],"names":["TWOBIT_MAGIC","tinyMemoize","_class","methodName","method","prototype","memoAttrName","concat","this","call","twoBit","byteTo4Bases","i","push","maskedByteTo4Bases","map","bases","toLowerCase","TwoBitFile","_ref","filehandle","path","_classCallCheck","Error","LocalFile","isBigEndian","undefined","_createClass","key","value","_getParser2","_asyncToGenerator","_regeneratorRuntime","mark","_callee","name","parser","wrap","_context","prev","next","_getParsers","t0","sent","abrupt","stop","_x","apply","arguments","_detectEndianness2","_callee2","ret","buffer","_context2","read","Buffer","allocUnsafe","readInt32LE","version","readInt32BE","_getParsers2","_callee3","endianess","lebe","indexEntryParser","header","_context3","_detectEndianness","Parser","uint8","string","length","uint32","int32","assert","m","v","index","array","type","record1","record2","record3","_getHeader","_callee4","_yield$this$filehandl","headerParser","_context4","_getParser","parse","result","_getIndex","_callee5","maxIndexLength","_yield$this$filehandl2","indexParser","indexData","_this","_context5","getHeader","sequenceCount","forEach","_ref2","offsetBytes","long","Long","greaterThan","Number","MAX_SAFE_INTEGER","toNumber","_ref3","offset","_getSequenceNames","_callee6","_context6","getIndex","Object","keys","_getSequenceSizes","_callee7","seqNames","sizePromises","sizes","returnObject","_i","_this2","_context7","values","_getSequenceSize","Promise","all","_getSequenceSize2","_callee8","seqName","_context8","_x2","_getSequenceSize3","_callee9","rec1","_context9","_parseItem","dnaSize","_x3","_getSequenceRecord2","_callee10","rec2DataLength","rec2","rec3DataLength","rec3","rec","_context10","nBlockCount","maskBlockCount","nBlocks","starts","nBlockStarts","nBlockSizes","maskBlocks","maskBlockStarts","maskBlockSizes","dnaPosition","_x4","_parseItem2","_callee11","parserName","_yield$this$filehandl3","_context11","_x5","_x6","_x7","_getSequence","_callee12","regionStart","regionEnd","record","baseBytes","baseBytesOffset","_yield$this$filehandl4","sequenceBases","genomicPosition","baseIsMasked","currentNBlock","bytePosition","subPosition","byte","_args12","_context12","_getSequenceRecord","TypeError","_getOverlappingBlocks","Math","ceil","floor","end","shift","start","_x8","blockStarts","blockSizes","startIndex","endIndex","blockStart","blocks","Array","blockNum","size","TwoBitAdapter","_BaseSequenceAdapter","_inherits","_super","_createSuper","config","getSubAdapter","pluginManager","twobit","chromSizesData","initChromSizes","openLocation","readConfObject","_initChromSizes","conf","file","data","uri","readFile","fromEntries","split","filter","line","trim","_line$split","_line$split2","_slicedToArray","_getRefNames","getSequenceNames","_getRegions","refSizes","refName","getSequenceSizes","ObservableCreate","observer","seq","getSequenceSize","min","getSequence","SimpleFeature","id","complete","BaseSequenceAdapter"],"sourceRoot":""}