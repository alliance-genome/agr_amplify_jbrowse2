{"version":3,"file":"static/js/5828.f669a228.chunk.js","mappings":"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","sources":["../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/afterAttach.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/components/util.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawSynteny.ts"],"sourcesContent":["import { addDisposer, getSnapshot } from 'mobx-state-tree'\n\nimport { Feature, getContainingView, getSession } from '@jbrowse/core/util'\nimport { bpToPx } from '@jbrowse/core/util/Base1DUtils'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\nimport { reaction, autorun } from 'mobx'\n\n// locals\nimport { LinearSyntenyViewModel } from '../LinearSyntenyView/model'\nimport { drawMouseoverSynteny, drawRef } from './drawSynteny'\nimport { LinearSyntenyDisplayModel } from './model'\n\ninterface Pos {\n  offsetPx: number\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\ntype LSV = LinearSyntenyViewModel\n\nexport function doAfterAttach(self: LinearSyntenyDisplayModel) {\n  addDisposer(\n    self,\n    autorun(() => {\n      const view = getContainingView(self) as LinearSyntenyViewModel\n      if (!view.initialized) {\n        return\n      }\n      const ctx1 = self.mainCanvas?.getContext('2d')\n      const ctx3 = self.cigarClickMapCanvas?.getContext('2d')\n      if (!ctx1 || !ctx3) {\n        return\n      }\n\n      const height = view.middleComparativeHeight\n      const width = view.width\n      ctx1.clearRect(0, 0, width, height)\n      ctx3.clearRect(0, 0, width, height)\n      drawRef(self, ctx1, ctx3)\n    }),\n  )\n\n  addDisposer(\n    self,\n    autorun(() => {\n      const view = getContainingView(self) as LinearSyntenyViewModel\n      if (!view.initialized) {\n        return\n      }\n      drawMouseoverSynteny(self)\n    }),\n  )\n\n  // this attempts to reduce recalculation of feature positions drawn by\n  // the synteny view\n  //\n  // uses a reaction to say \"we know the positions don't change in any\n  // relevant way unless bpPerPx changes or displayedRegions changes\"\n  addDisposer(\n    self,\n    reaction(\n      () => {\n        const view = getContainingView(self) as LSV\n        return {\n          bpPerPx: view.views.map(v => v.bpPerPx),\n\n          // stringifying 'deeply' accesses the displayed regions, see\n          // issue #3456\n          displayedRegions: JSON.stringify(\n            view.views.map(v => v.displayedRegions),\n          ),\n          features: self.features,\n          initialized: view.initialized,\n        }\n      },\n      ({ initialized }) => {\n        if (!initialized) {\n          return\n        }\n        const { assemblyManager } = getSession(self)\n        const view = getContainingView(self) as LSV\n        const viewSnaps = view.views.map(view => ({\n          ...getSnapshot(view),\n          width: view.width,\n          staticBlocks: view.staticBlocks,\n          interRegionPaddingWidth: view.interRegionPaddingWidth,\n          minimumBlockWidth: view.minimumBlockWidth,\n        }))\n\n        const map = [] as FeatPos[]\n        const feats = self.features || []\n\n        for (const f of feats) {\n          const mate = f.get('mate')\n          let f1s = f.get('start')\n          let f1e = f.get('end')\n          const f2s = mate.start\n          const f2e = mate.end\n\n          if (f.get('strand') === -1) {\n            ;[f1e, f1s] = [f1s, f1e]\n          }\n          const a1 = assemblyManager?.get(f.get('assemblyName'))\n          const a2 = assemblyManager?.get(mate.assemblyName)\n          const r1 = f.get('refName')\n          const r2 = mate.refName\n          const ref1 = a1?.getCanonicalRefName(r1) || r1\n          const ref2 = a2?.getCanonicalRefName(r2) || r2\n          const v1 = viewSnaps[0]\n          const v2 = viewSnaps[1]\n          const p11 = bpToPx({ self: v1, refName: ref1, coord: f1s })\n          const p12 = bpToPx({ self: v1, refName: ref1, coord: f1e })\n          const p21 = bpToPx({ self: v2, refName: ref2, coord: f2s })\n          const p22 = bpToPx({ self: v2, refName: ref2, coord: f2e })\n\n          if (\n            p11 === undefined ||\n            p12 === undefined ||\n            p21 === undefined ||\n            p22 === undefined\n          ) {\n            continue\n          }\n\n          const cigar = f.get('CIGAR') as string | undefined\n          map.push({\n            p11,\n            p12,\n            p21,\n            p22,\n            f,\n            cigar: MismatchParser.parseCigar(cigar),\n          })\n        }\n\n        self.setFeatPositions(map)\n      },\n      { fireImmediately: true },\n    ),\n  )\n}\n","import { doesIntersect2, Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\nexport function drawMatchSimple({\n  feature,\n  ctx,\n  offsets,\n  cb,\n  height,\n  drawCurves,\n  oobLimit,\n  viewWidth,\n  hideTiny,\n}: {\n  feature: FeatPos\n  ctx: CanvasRenderingContext2D\n  offsets: number[]\n  oobLimit: number\n  viewWidth: number\n  cb: (ctx: CanvasRenderingContext2D) => void\n  height: number\n  drawCurves?: boolean\n  hideTiny?: boolean\n}) {\n  const { p11, p12, p21, p22 } = feature\n\n  const x11 = p11.offsetPx - offsets[0]\n  const x12 = p12.offsetPx - offsets[0]\n  const x21 = p21.offsetPx - offsets[1]\n  const x22 = p22.offsetPx - offsets[1]\n\n  const l1 = Math.abs(x12 - x11)\n  const l2 = Math.abs(x22 - x21)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n  const minX = Math.min(x21, x22)\n  const maxX = Math.max(x21, x22)\n\n  if (!doesIntersect2(minX, maxX, -oobLimit, viewWidth + oobLimit)) {\n    return\n  }\n\n  // drawing a line if the results are thin: drawing a line results in much\n  // less pixellation than filling in a thin polygon\n  if (l1 <= 1 && l2 <= 1) {\n    // hideTiny can be used to avoid drawing mouseover for thin lines in this\n    // case\n    if (!hideTiny) {\n      ctx.beginPath()\n      ctx.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx.lineTo(x21, y2)\n      }\n      ctx.stroke()\n    }\n  } else {\n    draw(ctx, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n    cb(ctx)\n  }\n}\n\nexport function draw(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  drawCurves?: boolean,\n) {\n  if (drawCurves) {\n    drawBezierBox(ctx, x1, x2, y1, x3, x4, y2, mid)\n  } else {\n    drawBox(ctx, x1, x2, y1, x3, x4, y2)\n  }\n}\n\nexport function drawBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.lineTo(x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.closePath()\n  ctx.fill()\n}\n\nexport function drawBezierBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n) {\n  const len1 = Math.abs(x1 - x2)\n  const len2 = Math.abs(x1 - x2)\n\n  // heuristic to not draw hourglass inversions with bezier curves when they\n  // are thin and far apart because it results in areas that are not drawn well\n  // demo https://codesandbox.io/s/fast-glitter-q3b1or?file=/src/index.js\n  if (len1 < 5 && len2 < 5 && x2 < x1 && Math.abs(x1 - x3) > 100) {\n    const tmp = x1\n    x1 = x2\n    x2 = tmp\n  }\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.bezierCurveTo(x2, mid, x3, mid, x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.bezierCurveTo(x4, mid, x1, mid, x1, y1)\n  ctx.closePath()\n  ctx.fill()\n}\n","import { doesIntersect2, getContainingView } from '@jbrowse/core/util'\nimport { LinearSyntenyViewModel } from '../LinearSyntenyView/model'\nimport { LinearSyntenyDisplayModel } from './model'\nimport { draw, drawMatchSimple } from './components/util'\n\nexport const MAX_COLOR_RANGE = 255 * 255 * 255 // max color range\n\nfunction makeColor(idx: number) {\n  const r = Math.floor(idx / (255 * 255)) % 255\n  const g = Math.floor(idx / 255) % 255\n  const b = idx % 255\n  return `rgb(${r},${g},${b})`\n}\n\nconst colorMap = {\n  I: '#ff03',\n  N: '#0a03',\n  D: '#00f3',\n  X: 'brown',\n  M: '#f003',\n  '=': '#f003',\n}\n\nconst lineLimit = 3\n\nconst oobLimit = 1600\n\nexport function getId(r: number, g: number, b: number, unitMultiplier: number) {\n  return Math.floor((r * 255 * 255 + g * 255 + b - 1) / unitMultiplier)\n}\n\nexport function drawRef(\n  model: LinearSyntenyDisplayModel,\n  ctx1: CanvasRenderingContext2D,\n  ctx3?: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const height = view.middleComparativeHeight\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  if (ctx3) {\n    ctx3.imageSmoothingEnabled = false\n  }\n\n  ctx1.beginPath()\n  const featPos = model.featPositions\n  const offsets = view.views.map(v => v.offsetPx)\n\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / featPos.length)\n\n  // this loop is optimized to draw many thin lines with a single ctx.stroke\n  // call, a separate loop below draws larger boxes\n  ctx1.fillStyle = colorMap.M\n  ctx1.strokeStyle = colorMap.M\n  for (const { p11, p12, p21, p22 } of featPos) {\n    const x11 = p11.offsetPx - offsets[0]\n    const x12 = p12.offsetPx - offsets[0]\n    const x21 = p21.offsetPx - offsets[1]\n    const x22 = p22.offsetPx - offsets[1]\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    // drawing a line if the results are thin results in much less pixellation\n    // than filling in a thin polygon\n    if (\n      l1 <= lineLimit &&\n      l2 <= lineLimit &&\n      x21 < width + oobLimit &&\n      x21 > -oobLimit\n    ) {\n      ctx1.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx1.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx1.lineTo(x21, y2)\n      }\n    }\n  }\n  ctx1.stroke()\n\n  // this loop only draws small lines as a polyline, the polyline calls\n  // ctx.stroke once is much more efficient than calling stroke() many times\n  ctx1.fillStyle = colorMap.M\n  ctx1.strokeStyle = colorMap.M\n  for (const { p11, p12, p21, p22, f, cigar } of featPos) {\n    const x11 = p11.offsetPx - offsets[0]\n    const x12 = p12.offsetPx - offsets[0]\n    const x21 = p21.offsetPx - offsets[1]\n    const x22 = p22.offsetPx - offsets[1]\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    if (\n      !(l1 <= lineLimit && l2 <= lineLimit) &&\n      doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)\n    ) {\n      const s1 = f.get('strand')\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      // rev1/rev2 flip the direction of the CIGAR drawing in horizontally flipped\n      // modes. somewhat heuristically determined, but tested for\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      // cx1/cx2 are the current x positions on top and bottom rows\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar?.length && drawCIGAR) {\n        // continuingFlag skips drawing commands on very small CIGAR features\n        let continuingFlag = false\n\n        // px1/px2 are the previous x positions on the top and bottom rows\n        let px1 = 0\n        let px2 = 0\n        const unitMultiplier2 = Math.floor(MAX_COLOR_RANGE / cigar.length)\n        for (let j = 0; j < cigar.length; j += 2) {\n          const idx = j * unitMultiplier2 + 1\n\n          const len = +cigar[j]\n          const op = cigar[j + 1] as keyof typeof colorMap\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len / bpPerPxs[0]\n          const d2 = len / bpPerPxs[1]\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          } else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          // check that we are even drawing in view here, e.g. that all\n          // points are not all less than 0 or greater than width\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            // if it is a small feature and not the last element of the\n            // CIGAR (which could skip rendering it entire if we did turn\n            // it on), then turn on continuing flag\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              continuingFlag = false\n\n              // allow rendering the dominant color when using continuing\n              // flag if the last element of continuing was a large\n              // feature, else just use match\n              ctx1.fillStyle =\n                colorMap[(continuingFlag && d1 > 1) || d2 > 1 ? op : 'M']\n\n              draw(ctx1, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n              if (ctx3) {\n                ctx3.fillStyle = makeColor(idx)\n                draw(ctx3, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n              }\n            }\n          }\n        }\n      } else {\n        draw(ctx1, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n      }\n    }\n  }\n\n  // draw click map\n  const ctx2 = model.clickMapCanvas?.getContext('2d')\n  if (!ctx2) {\n    return\n  }\n  ctx2.imageSmoothingEnabled = false\n  ctx2.clearRect(0, 0, width, height)\n  for (let i = 0; i < featPos.length; i++) {\n    const feature = featPos[i]\n    const idx = i * unitMultiplier + 1\n    ctx2.fillStyle = makeColor(idx)\n\n    // too many click map false positives with colored stroked lines\n    drawMatchSimple({\n      cb: ctx => ctx.fill(),\n      feature,\n      ctx: ctx2,\n      drawCurves,\n      offsets,\n      oobLimit,\n      viewWidth: view.width,\n      hideTiny: true,\n      height,\n    })\n  }\n}\n\nexport function drawMouseoverSynteny(model: LinearSyntenyDisplayModel) {\n  const { clickId, mouseoverId } = model\n  const highResolutionScaling = 1\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const height = view.middleComparativeHeight\n  const width = view.width\n  const ctx = model.mouseoverCanvas?.getContext('2d')\n  const offsets = view.views.map(v => v.offsetPx)\n\n  if (!ctx) {\n    return\n  }\n  ctx.resetTransform()\n  ctx.scale(highResolutionScaling, highResolutionScaling)\n  ctx.clearRect(0, 0, width, height)\n  const feature1 = model.featMap[mouseoverId || '']\n  if (feature1) {\n    ctx.fillStyle = 'rgb(0,0,0,0.1)'\n    drawMatchSimple({\n      cb: ctx => ctx.fill(),\n      feature: feature1,\n      ctx,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n  const feature2 = model.featMap[clickId || '']\n  if (feature2) {\n    ctx.strokeStyle = 'rgb(0, 0, 0, 0.9)'\n\n    drawMatchSimple({\n      cb: ctx => ctx.stroke(),\n      feature: feature2,\n      ctx,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n}\n"],"names":["doAfterAttach","self","addDisposer","autorun","_self$mainCanvas","_self$cigarClickMapCa","view","getContainingView","initialized","ctx1","mainCanvas","getContext","ctx3","cigarClickMapCanvas","height","middleComparativeHeight","width","clearRect","drawRef","drawMouseoverSynteny","reaction","bpPerPx","views","map","v","displayedRegions","JSON","stringify","features","_ref","_step","assemblyManager","getSession","viewSnaps","_objectSpread","getSnapshot","staticBlocks","interRegionPaddingWidth","minimumBlockWidth","feats","_iterator","_createForOfIteratorHelper","s","n","done","f","value","mate","get","f1s","f1e","f2s","start","f2e","end","_ref2","a1","a2","assemblyName","r1","r2","refName","ref1","getCanonicalRefName","ref2","v1","v2","p11","bpToPx","coord","p12","p21","p22","undefined","cigar","push","MismatchParser","err","e","setFeatPositions","fireImmediately","drawMatchSimple","feature","ctx","offsets","cb","drawCurves","oobLimit","viewWidth","hideTiny","x11","offsetPx","x12","x21","x22","l1","Math","abs","l2","y2","mid","minX","min","maxX","max","doesIntersect2","beginPath","moveTo","bezierCurveTo","lineTo","stroke","draw","x1","x2","y1","x3","x4","len1","len2","tmp","closePath","fill","drawBezierBox","drawBox","MAX_COLOR_RANGE","makeColor","idx","r","floor","g","b","concat","colorMap","I","N","D","X","M","lineLimit","getId","unitMultiplier","model","_model$clickMapCanvas","drawCIGAR","bpPerPxs","imageSmoothingEnabled","featPos","featPositions","length","fillStyle","strokeStyle","_step$value","_step2","_iterator2","_step2$value","s1","k1","rev1","rev2","cx1","cx2","continuingFlag","px1","px2","unitMultiplier2","j","len","op","d1","d2","isNotLast","ctx2","clickMapCanvas","i","_model$mouseoverCanva","clickId","mouseoverId","mouseoverCanvas","resetTransform","scale","feature1","featMap","feature2"],"sourceRoot":""}