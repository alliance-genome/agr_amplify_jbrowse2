{"version":3,"file":"static/js/2968.78570e87.chunk.js","mappings":"iVAgBoC,4CAgBlC,WACEA,EACAC,EACAC,GACC,IAAD,mBACA,cAAMF,EAAQC,EAAeC,IATrBC,SAAG,IAEHC,oBAAc,EAQtB,IAAMC,EAAK,EAAKH,cACVI,GAAgBC,EAAAA,EAAAA,gBAAeP,EAAQ,iBACvCQ,GAAYD,EAAAA,EAAAA,gBAAeP,EAAQ,CAAC,QAAS,cAC7CS,GAAWF,EAAAA,EAAAA,gBAAeP,EAAQ,CAAC,QAAS,aAC5CI,GAAiBG,EAAAA,EAAAA,gBAAeP,EAAQ,kBAE9C,EAAKI,eAAiBA,GAAkB,CAAC,aAAc,SAAU,UACjE,IAAMM,GAAMC,EAAAA,EAAAA,cAAaF,EAAUJ,GAOjC,OANF,EAAKF,IAAM,IAAIS,EAAAA,GAAiB,CAC9BC,YAAYF,EAAAA,EAAAA,cAAaL,EAAeD,GACxCS,cAA6B,QAAdN,EAAsBE,OAAMK,EAC3CC,cAA6B,QAAdR,EAAsBE,OAAMK,EAC3CE,eAAgB,GAAE,SAAG,EAAK,IAC1BC,cAAe,SAACC,GAAS,OAAKA,CAAC,IAC/B,CACJ,CA0MyC,OA1MxC,4EAED,qGAA+C,OAAtBC,EAAiB,+BAAG,CAAC,EAAC,kBACtCC,KAAKlB,IAAImB,0BAA0BF,IAAK,gDAChD,kDAJA,IAIA,gEAED,4GACSC,KAAKlB,IAAIoB,aAAW,gDAC5B,kDAJA,IAIA,yBAED,SAAmBC,GAAwC,IAAD,OAAxBJ,EAAiB,uDAAG,CAAC,EACrD,OAAOK,EAAAA,EAAAA,kBAAgB,yCAAU,WAAMC,GAAQ,4FACtB,EAAKvB,IAAIwB,cAAa,OAA/B,OAARC,EAAQ,gBACR,EAAKC,kBAAkBL,EAAOJ,EAAMQ,EAAUF,GAAU,GAAK,2CACpE,mDAHsB,GAGpBN,EAAKU,OACV,GAAC,wEAED,WACEN,GAAa,+GAQoB,OAPjCJ,EAAiB,+BAAG,CAAC,EACrBQ,EAA2D,uBAC3DF,EAA2B,uBAC3BK,EAAwB,uBACxBC,EAAa,+BAAGR,EAAK,SAGbS,EAAuB,GAAE,SAEzBZ,KAAKlB,IAAI+B,SACbV,EAAMW,QACNX,EAAMY,MACNZ,EAAMa,KACN,SAACC,EAAcC,GACbN,EAAMO,KAAK,EAAKC,UAAUb,EAASc,cAAeJ,EAAMC,GAC1D,IACD,WACGR,IAAmBE,EAAMU,OAAM,iBAgB/B,GAfEC,EAAWC,IACXC,GAAUD,IACdZ,EAAMc,SAAQ,SAAAT,GACZ,IAAMU,EAAcV,EAAKW,OAAO,GAGhC,IAAK,EAAK7C,eAAe8C,SAASF,GAAc,CAC9C,IAAMZ,EAAQE,EAAKF,MAAQ,EACvBA,EAAQQ,IACVA,EAAWR,GAETE,EAAKD,IAAMS,IACbA,EAASR,EAAKD,IAElB,CACF,MACIS,EAAStB,EAAMa,KAAOO,EAAWpB,EAAMY,OAAK,kCAGxCf,KAAKQ,mBAAkB,kBACtBL,GAAK,IAAEY,MAAOQ,EAAUP,IAAKS,IAClC1B,EACAQ,EACAF,GACA,EACAF,GACD,0CAKC2B,EAAOlB,EACVmB,KAAI,SAACC,GAQJ,OAPIA,EAAWJ,OAAO,IAA+B,MAAzBI,EAAWJ,OAAO,GACvCI,EAAWJ,OAAO,GAAGC,SAAS,eACjCG,EAAWJ,OAAO,IAAE,qBAAkBI,EAAWC,WAGnDD,EAAWJ,OAAO,GAAE,oBAAgBI,EAAWC,UAE1CD,EAAWJ,OAAOM,KAAK,KAChC,IACCA,KAAK,MAESpD,EAAAA,EAAAA,gBAAoBgD,EAAM,CACzCK,eAAe,EACfC,eAAe,EACfC,iBAAiB,EACjBC,gBAAgB,EAChBC,8BAA8B,IAGvBb,SAAQ,SAAAc,GAAW,OAC1B,EAAKC,eAAeD,GAAad,SAAQ,SAAAgB,IAErCC,EAAAA,EAAAA,IACED,EAAEE,IAAI,SACNF,EAAEE,IAAI,OACNjC,EAAcI,MACdJ,EAAcK,MAEE,WAAlB0B,EAAEE,IAAI,SAENvC,EAASwC,KAAKH,EAElB,GAAE,IAEJrC,EAASyC,WAAU,kDAEnBzC,EAAS0C,MAAM,EAAD,IAAG,0DAEpB,mDA7FA,IA6FA,uBAED,SACE1B,EACAJ,EACAC,GAEA,IAAMU,EAASX,EAAK+B,MAAM,MAG1B,MAAO,CACLjC,OAAQa,EAAOP,EAAcN,MAAQ,GACrCC,KAAMY,EAAOP,EAAcL,IAAM,GACjCiB,SAAUf,EACVU,OAAAA,EAEJ,GAAC,4BAED,SAAuBY,GAA2B,IAAD,OAC/C,OAAOA,EAAYT,KACjB,SAAAkB,GAAU,OACR,IAAIC,EAAAA,cAAc,CAChBC,KAAM,EAAKC,YAAYH,GAEvBI,GAAG,GAAD,OAAK,EAAKA,GAAE,mBAAWJ,EAAWK,WAAYC,UAAW,KAC3D,GAER,GAAC,yBAED,SAAoBJ,GAAgC,IAAD,OAC3CT,GAA0B,UAAQS,GACtCT,EAAE3B,OAAoB,EACJ,MAAhBoC,EAAKK,OACPd,EAAEc,OAAS,EACc,MAAhBL,EAAKK,OACdd,EAAEc,QAAU,EACa,MAAhBL,EAAKK,OACdd,EAAEc,OAAS,EAEXd,EAAEc,YAAS9D,EAEbgD,EAAEe,MAAQC,OAAOP,EAAKM,OACtBf,EAAE5B,QAAUqC,EAAKQ,OACE,OAAfR,EAAKS,cACAlB,EAAEkB,MAEQ,OAAfT,EAAKM,cACAf,EAAEkB,MAEX,IAAMC,EAAgB,CACpB,QACA,MACA,SACA,QACA,OACA,SACA,QACA,UAEIC,EAAiBX,EAAKG,YAAc,CAAC,EAgC3C,OA/BAS,OAAOC,KAAKF,GAAgBpC,SAAQ,SAAAuC,GAClC,IAAIC,EAAID,EAAEE,cAMV,GALIN,EAAchC,SAASqC,KAGzBA,GAAK,KAEmB,OAAtBJ,EAAeG,GAAa,CAC9B,IAAIG,EAAsCN,EAAeG,GACzD,GAAII,MAAMC,QAAQF,IAAyB,IAAhBA,EAAK9C,OAAc,CAC3C,MAAS8C,EAARA,GAAY,YAAR,EACR,CACA1B,EAAEwB,GAAKE,CACT,CACF,IACA1B,EAAE5B,QAAU4B,EAAEiB,OAGVR,EAAKoB,gBAAkBpB,EAAKoB,eAAejD,SAC7CoB,EAAE8B,YAAcrB,EAAKoB,eAClBxC,KAAI,SAAA0C,GAAS,OAAIA,EAAU1C,KAAI,SAAA2C,GAAQ,OAAI,EAAKtB,YAAYsB,EAAS,GAAC,IACtEC,eAGEjC,EAAE6B,sBACF7B,EAAES,YAEFT,EAAEkC,iBACFlC,EAAEY,kBACFZ,EAAEiB,OAEFjB,CACT,GAAC,2BAED,WAAwC,KAAC,EA/OP,CAWPmC,EAAAA,uB","sources":["../../../plugins/gff3/src/Gff3TabixAdapter/Gff3TabixAdapter.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { doesIntersect2 } from '@jbrowse/core/util/range'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { SimpleFeature, Feature } from '@jbrowse/core/util'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport gff, { GFF3Feature, GFF3FeatureLineWithRefs } from '@gmod/gff'\nimport { Observer } from 'rxjs'\nimport {\n  readConfObject,\n  AnyConfigurationModel,\n} from '@jbrowse/core/configuration'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\ninterface LineFeature {\n  start: number\n  end: number\n  lineHash: number\n  fields: string[]\n}\n\nexport default class extends BaseFeatureDataAdapter {\n  protected gff: TabixIndexedFile\n\n  protected dontRedispatch: string[]\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const pm = this.pluginManager\n    const gffGzLocation = readConfObject(config, 'gffGzLocation')\n    const indexType = readConfObject(config, ['index', 'indexType'])\n    const location = readConfObject(config, ['index', 'location'])\n    const dontRedispatch = readConfObject(config, 'dontRedispatch')\n\n    this.dontRedispatch = dontRedispatch || ['chromosome', 'contig', 'region']\n    const loc = openLocation(location, pm)\n    this.gff = new TabixIndexedFile({\n      filehandle: openLocation(gffGzLocation, pm),\n      csiFilehandle: indexType === 'CSI' ? loc : undefined,\n      tbiFilehandle: indexType !== 'CSI' ? loc : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n      renameRefSeqs: (n: string) => n,\n    })\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    return this.gff.getReferenceSequenceNames(opts)\n  }\n\n  public async getHeader() {\n    return this.gff.getHeader()\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const metadata = await this.gff.getMetadata()\n      await this.getFeaturesHelper(query, opts, metadata, observer, true)\n    }, opts.signal)\n  }\n\n  private async getFeaturesHelper(\n    query: Region,\n    opts: BaseOptions = {},\n    metadata: { columnNumbers: { start: number; end: number } },\n    observer: Observer<Feature>,\n    allowRedispatch: boolean,\n    originalQuery = query,\n  ) {\n    try {\n      const lines: LineFeature[] = []\n\n      await this.gff.getLines(\n        query.refName,\n        query.start,\n        query.end,\n        (line: string, fileOffset: number) => {\n          lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset))\n        },\n      )\n      if (allowRedispatch && lines.length) {\n        let minStart = Infinity\n        let maxEnd = -Infinity\n        lines.forEach(line => {\n          const featureType = line.fields[2]\n          // only expand redispatch range if feature is not a \"dontRedispatch\" type\n          // skips large regions like chromosome,region\n          if (!this.dontRedispatch.includes(featureType)) {\n            const start = line.start - 1 // gff is 1-based\n            if (start < minStart) {\n              minStart = start\n            }\n            if (line.end > maxEnd) {\n              maxEnd = line.end\n            }\n          }\n        })\n        if (maxEnd > query.end || minStart < query.start) {\n          // make a new feature callback to only return top-level features\n          // in the original query range\n          await this.getFeaturesHelper(\n            { ...query, start: minStart, end: maxEnd },\n            opts,\n            metadata,\n            observer,\n            false,\n            query,\n          )\n          return\n        }\n      }\n\n      const gff3 = lines\n        .map((lineRecord: LineFeature) => {\n          if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n            if (!lineRecord.fields[8].includes('_lineHash')) {\n              lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`\n            }\n          } else {\n            lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`\n          }\n          return lineRecord.fields.join('\\t')\n        })\n        .join('\\n')\n\n      const features = gff.parseStringSync(gff3, {\n        parseFeatures: true,\n        parseComments: false,\n        parseDirectives: false,\n        parseSequences: false,\n        disableDerivesFromReferences: true,\n      })\n\n      features.forEach(featureLocs =>\n        this.formatFeatures(featureLocs).forEach(f => {\n          if (\n            doesIntersect2(\n              f.get('start'),\n              f.get('end'),\n              originalQuery.start,\n              originalQuery.end,\n            ) &&\n            f.get('type') !== 'region'\n          ) {\n            observer.next(f)\n          }\n        }),\n      )\n      observer.complete()\n    } catch (e) {\n      observer.error(e)\n    }\n  }\n\n  private parseLine(\n    columnNumbers: { start: number; end: number },\n    line: string,\n    fileOffset: number,\n  ) {\n    const fields = line.split('\\t')\n\n    // note: index column numbers are 1-based\n    return {\n      start: +fields[columnNumbers.start - 1],\n      end: +fields[columnNumbers.end - 1],\n      lineHash: fileOffset,\n      fields,\n    }\n  }\n\n  private formatFeatures(featureLocs: GFF3Feature) {\n    return featureLocs.map(\n      featureLoc =>\n        new SimpleFeature({\n          data: this.featureData(featureLoc),\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          id: `${this.id}-offset-${featureLoc.attributes!._lineHash![0]}`,\n        }),\n    )\n  }\n\n  private featureData(data: GFF3FeatureLineWithRefs) {\n    const f: Record<string, unknown> = { ...data }\n    ;(f.start as number) -= 1 // convert to interbase\n    if (data.strand === '+') {\n      f.strand = 1\n    } else if (data.strand === '-') {\n      f.strand = -1\n    } else if (data.strand === '.') {\n      f.strand = 0\n    } else {\n      f.strand = undefined\n    }\n    f.phase = Number(data.phase)\n    f.refName = data.seq_id\n    if (data.score === null) {\n      delete f.score\n    }\n    if (data.phase === null) {\n      delete f.score\n    }\n    const defaultFields = [\n      'start',\n      'end',\n      'seq_id',\n      'score',\n      'type',\n      'source',\n      'phase',\n      'strand',\n    ]\n    const dataAttributes = data.attributes || {}\n    Object.keys(dataAttributes).forEach(a => {\n      let b = a.toLowerCase()\n      if (defaultFields.includes(b)) {\n        // add \"suffix\" to tag name if it already exists\n        // reproduces behavior of NCList\n        b += '2'\n      }\n      if (dataAttributes[a] !== null) {\n        let attr: string | string[] | undefined = dataAttributes[a]\n        if (Array.isArray(attr) && attr.length === 1) {\n          ;[attr] = attr\n        }\n        f[b] = attr\n      }\n    })\n    f.refName = f.seq_id\n\n    // the SimpleFeature constructor takes care of recursively inflating subfeatures\n    if (data.child_features && data.child_features.length) {\n      f.subfeatures = data.child_features\n        .map(childLocs => childLocs.map(childLoc => this.featureData(childLoc)))\n        .flat()\n    }\n\n    delete f.child_features\n    delete f.data\n    // delete f.derived_features\n    delete f._linehash\n    delete f.attributes\n    delete f.seq_id\n\n    return f\n  }\n\n  public freeResources(/* { region } */) {}\n}\n"],"names":["config","getSubAdapter","pluginManager","gff","dontRedispatch","pm","gffGzLocation","readConfObject","indexType","location","loc","openLocation","TabixIndexedFile","filehandle","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","renameRefSeqs","n","opts","this","getReferenceSequenceNames","getHeader","query","ObservableCreate","observer","getMetadata","metadata","getFeaturesHelper","signal","allowRedispatch","originalQuery","lines","getLines","refName","start","end","line","fileOffset","push","parseLine","columnNumbers","length","minStart","Infinity","maxEnd","forEach","featureType","fields","includes","gff3","map","lineRecord","lineHash","join","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","featureLocs","formatFeatures","f","doesIntersect2","get","next","complete","error","split","featureLoc","SimpleFeature","data","featureData","id","attributes","_lineHash","strand","phase","Number","seq_id","score","defaultFields","dataAttributes","Object","keys","a","b","toLowerCase","attr","Array","isArray","child_features","subfeatures","childLocs","childLoc","flat","_linehash","BaseFeatureDataAdapter"],"sourceRoot":""}