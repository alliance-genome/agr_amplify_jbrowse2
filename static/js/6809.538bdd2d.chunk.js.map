{"version":3,"file":"static/js/6809.538bdd2d.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedAdapter/BedAdapter.ts","../../../plugins/bed/src/util.ts"],"sourcesContent":["import BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Region, Feature } from '@jbrowse/core/util'\nimport { featureData } from '../util'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class BedAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    parser: BED\n    columnNames: string[]\n    scoreColumn: string\n    colRef: number\n    colStart: number\n    colEnd: number\n  }>\n\n  protected intervalTrees: {\n    [key: string]: Promise<IntervalTree | undefined> | undefined\n  } = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedLocation')\n    const buf = await openLocation(bedLoc, pm).readFile(opts)\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i].startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const features = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]\n      const tab = line.indexOf('\\t')\n      const refName = line.slice(0, tab)\n      if (!features[refName]) {\n        features[refName] = []\n      }\n      features[refName].push(line)\n    }\n\n    const autoSql = this.getConf('autoSql') as string\n    const parser = new BED({ autoSql })\n    const columnNames = this.getConf('columnNames')\n    const scoreColumn = this.getConf('scoreColumn')\n    const colRef = this.getConf('colRef')\n    const colStart = this.getConf('colStart')\n    const colEnd = this.getConf('colEnd')\n\n    return {\n      header,\n      features,\n      parser,\n      columnNames,\n      scoreColumn,\n      colRef,\n      colStart,\n      colEnd,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch(e => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs[defs.length - 1]\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { colRef, colStart, colEnd, features, parser, scoreColumn } =\n      await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = await this.getNames()\n\n    const intervalTree = new IntervalTree()\n    const ret = lines.map((f, i) => {\n      const uniqueId = `${this.id}-${refName}-${i}`\n      return featureData(\n        f,\n        colRef,\n        colStart,\n        colEnd,\n        scoreColumn,\n        parser,\n        uniqueId,\n        names,\n      )\n    })\n\n    for (let i = 0; i < ret.length; i++) {\n      const obj = ret[i]\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n    return intervalTree\n  }\n\n  private async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch(e => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      intervalTree?.search([start, end]).forEach(f => observer.next(f))\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","import { SimpleFeature, Feature } from '@jbrowse/core/util'\nimport BED from '@gmod/bed'\n\nexport function ucscProcessedTranscript(feature: Feature) {\n  const children = feature.children()\n  // split the blocks into UTR, CDS, and exons\n  const thickStart = feature.get('thickStart')\n  const thickEnd = feature.get('thickEnd')\n\n  if (!thickStart && !thickEnd) {\n    return feature\n  }\n\n  const blocks: Feature[] = children\n    ? children\n        .filter(child => child.get('type') === 'block')\n        .sort((a, b) => a.get('start') - b.get('start'))\n    : []\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const newChildren: Record<string, any> = []\n  blocks.forEach(block => {\n    const start = block.get('start')\n    const end = block.get('end')\n    if (thickStart >= end) {\n      // left-side UTR\n      const prime = feature.get('strand') > 0 ? 'five' : 'three'\n      newChildren.push({\n        type: `${prime}_prime_UTR`,\n        start,\n        end,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n      // UTR | CDS\n      const prime = feature.get('strand') > 0 ? 'five' : 'three'\n      newChildren.push(\n        {\n          type: `${prime}_prime_UTR`,\n          start,\n          end: thickStart,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end,\n        },\n      )\n    } else if (thickStart <= start && thickEnd >= end) {\n      // CDS\n      newChildren.push({\n        type: 'CDS',\n        start,\n        end,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd < end) {\n      // UTR | CDS | UTR\n      const leftPrime = feature.get('strand') > 0 ? 'five' : 'three'\n      const rightPrime = feature.get('strand') > 0 ? 'three' : 'five'\n      newChildren.push(\n        {\n          type: `${leftPrime}_prime_UTR`,\n          start,\n          end: thickStart,\n        },\n        {\n          type: `CDS`,\n          start: thickStart,\n          end: thickEnd,\n        },\n        {\n          type: `${rightPrime}_prime_UTR`,\n          start: thickEnd,\n          end,\n        },\n      )\n    } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n      // CDS | UTR\n      const prime = feature.get('strand') > 0 ? 'three' : 'five'\n      newChildren.push(\n        {\n          type: `CDS`,\n          start,\n          end: thickEnd,\n        },\n        {\n          type: `${prime}_prime_UTR`,\n          start: thickEnd,\n          end,\n        },\n      )\n    } else if (thickEnd <= start) {\n      // right-side UTR\n      const prime = feature.get('strand') > 0 ? 'three' : 'five'\n      newChildren.push({\n        type: `${prime}_prime_UTR`,\n        start,\n        end,\n      })\n    }\n  })\n  const newData = Object.fromEntries(\n    feature.tags().map(tag => [tag, feature.get(tag)]),\n  )\n  newData.subfeatures = newChildren\n  newData.type = 'mRNA'\n  newData.uniqueId = feature.id()\n  delete newData.chromStarts\n  delete newData.chromStart\n  delete newData.chromEnd\n  delete newData.chrom\n  delete newData.blockStarts\n  delete newData.blockSizes\n  delete newData.blockCount\n  delete newData.thickStart\n  delete newData.thickEnd\n  const newFeature = new SimpleFeature({\n    data: newData,\n    id: feature.id(),\n  })\n  return newFeature\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  return Object.fromEntries(line.split('\\t').map((f, i) => [fields[i], f]))\n}\n\nexport function featureData(\n  line: string,\n  colRef: number,\n  colStart: number,\n  colEnd: number,\n  scoreColumn: string,\n  parser: BED,\n  uniqueId: string,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const refName = l[colRef]\n  const start = +l[colStart]\n  const colSame = colStart === colEnd ? 1 : 0\n\n  const end = +l[colEnd] + colSame\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n\n  const { blockCount, blockSizes, blockStarts, chromStarts } = data\n\n  if (blockCount) {\n    const starts = chromStarts || blockStarts || []\n    const sizes = blockSizes\n    const blocksOffset = start\n    data.subfeatures = []\n\n    for (let b = 0; b < blockCount; b += 1) {\n      const bmin = (starts[b] || 0) + blocksOffset\n      const bmax = bmin + (sizes[b] || 0)\n      data.subfeatures.push({\n        uniqueId: `${uniqueId}-${b}`,\n        start: bmin,\n        end: bmax,\n        type: 'block',\n      })\n    }\n  }\n\n  if (scoreColumn) {\n    data.score = +data[scoreColumn]\n  }\n  delete data.chrom\n  delete data.chromStart\n  delete data.chromEnd\n  const f = new SimpleFeature({\n    ...data,\n    start,\n    end,\n    refName,\n    uniqueId,\n  })\n  return f.get('thickStart') ? ucscProcessedTranscript(f) : f\n}\n"],"names":["isGzip","buf","BedAdapter","bedFeatures","intervalTrees","opts","pm","this","pluginManager","bedLoc","getConf","openLocation","readFile","unzip","buffer","length","Error","data","TextDecoder","fatal","decode","lines","split","filter","f","headerLines","i","startsWith","push","header","join","features","line","tab","indexOf","refName","slice","autoSql","parser","BED","columnNames","scoreColumn","colRef","colStart","colEnd","loadDataP","catch","e","undefined","loadData","Object","keys","defs","defline","includes","map","field","trim","getNames","names","intervalTree","IntervalTree","ret","uniqueId","id","featureData","obj","insert","get","loadFeatureIntervalTreeHelper","query","ObservableCreate","observer","start","end","loadFeatureIntervalTree","search","forEach","next","complete","signal","BaseFeatureDataAdapter","capabilities","ucscProcessedTranscript","feature","children","thickStart","thickEnd","blocks","child","sort","a","b","newChildren","block","prime","type","leftPrime","rightPrime","newData","fromEntries","tags","tag","subfeatures","chromStarts","chromStart","chromEnd","chrom","blockStarts","blockSizes","blockCount","SimpleFeature","l","colSame","fields","defaultParser","parseLine","starts","sizes","blocksOffset","bmin","bmax","score"],"sourceRoot":""}