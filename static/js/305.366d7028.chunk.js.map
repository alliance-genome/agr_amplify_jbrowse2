{"version":3,"file":"static/js/305.366d7028.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nimport gff, { GFF3FeatureLineWithRefs } from '@gmod/gff'\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nconst decoder =\n  typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  protected gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<\n      string,\n      ((sc?: (arg: string) => void) => IntervalTree) | undefined\n    >\n  }>\n\n  private async loadDataP(opts: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const pm = this.pluginManager\n    const buf = await openLocation(this.getConf('gffLocation'), pm).readFile()\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n    const headerLines = []\n    const featureMap = {} as Record<string, string>\n    let blockStart = 0\n\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf('\\n', blockStart)\n      // could be a non-newline ended file, so slice to end of file if n===-1\n      const b =\n        n === -1 ? buffer.slice(blockStart) : buffer.slice(blockStart, n)\n      const line = (decoder?.decode(b) || b.toString()).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else if (line.startsWith('>')) {\n          break\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = ''\n          }\n          featureMap[refName] += line + '\\n'\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => {\n        return [\n          refName,\n          (sc?: (arg: string) => void) => {\n            sc?.(`Parsing GFF data`)\n            if (!this.calculatedIntervalTreeMap[refName]) {\n              const intervalTree = new IntervalTree()\n              gff\n                .parseStringSync(lines, {\n                  parseFeatures: true,\n                  parseComments: false,\n                  parseDirectives: false,\n                  parseSequences: false,\n                  disableDerivesFromReferences: true,\n                })\n                .flat()\n                .map(\n                  (f, i) =>\n                    new SimpleFeature({\n                      data: this.featureData(f),\n                      id: `${this.id}-${refName}-${i}`,\n                    }),\n                )\n                .forEach(obj =>\n                  intervalTree.insert([obj.get('start'), obj.get('end')], obj),\n                )\n              this.calculatedIntervalTreeMap[refName] = intervalTree\n            }\n            return this.calculatedIntervalTreeMap[refName]\n          },\n        ]\n      }),\n    )\n\n    return { header: headerLines.join('\\n'), intervalTreeMap }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch(e => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          ?.search([start, end])\n          .forEach(f => observer.next(f))\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  private featureData(data: GFF3FeatureLineWithRefs) {\n    const f: Record<string, unknown> = { ...data }\n    ;(f.start as number) -= 1 // convert to interbase\n    if (data.strand === '+') {\n      f.strand = 1\n    } else if (data.strand === '-') {\n      f.strand = -1\n    } else if (data.strand === '.') {\n      f.strand = 0\n    } else {\n      f.strand = undefined\n    }\n    f.phase = Number(data.phase)\n    f.refName = data.seq_id\n    if (data.score === null) {\n      delete f.score\n    }\n    if (data.phase === null) {\n      delete f.score\n    }\n    const defaultFields = new Set([\n      'start',\n      'end',\n      'seq_id',\n      'score',\n      'type',\n      'source',\n      'phase',\n      'strand',\n    ])\n    const dataAttributes = data.attributes || {}\n    for (const a of Object.keys(dataAttributes)) {\n      let b = a.toLowerCase()\n      if (defaultFields.has(b)) {\n        // add \"suffix\" to tag name if it already exists\n        // reproduces behavior of NCList\n        b += '2'\n      }\n      if (dataAttributes[a] !== null) {\n        let attr: string | string[] | undefined = dataAttributes[a]\n        if (Array.isArray(attr) && attr.length === 1) {\n          ;[attr] = attr\n        }\n        f[b] = attr\n      }\n    }\n    f.refName = f.seq_id\n\n    // the SimpleFeature constructor takes care of recursively inflating subfeatures\n    if (data.child_features && data.child_features.length > 0) {\n      f.subfeatures = data.child_features.flatMap(childLocs =>\n        childLocs.map(childLoc => this.featureData(childLoc)),\n      )\n    }\n\n    delete f.child_features\n    delete f.data\n    // delete f.derived_features\n    delete f.attributes\n    delete f.seq_id\n    return f\n  }\n\n  public freeResources(/* { region } */) {}\n}\n"],"names":["decoder","TextDecoder","undefined","Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","pm","this","pluginManager","buf","openLocation","getConf","readFile","buffer","isGzip","unzip","headerLines","featureMap","blockStart","i","length","n","indexOf","b","slice","line","decode","toString","trim","startsWith","push","ret","refName","Math","floor","toLocaleString","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","gff","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","flat","f","SimpleFeature","data","featureData","id","forEach","obj","insert","get","header","join","loadData","gffFeatures","catch","e","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","error","signal","strand","phase","Number","seq_id","score","defaultFields","Set","dataAttributes","attributes","a","toLowerCase","has","attr","Array","isArray","child_features","subfeatures","flatMap","childLocs","childLoc","freeResources"],"sourceRoot":""}