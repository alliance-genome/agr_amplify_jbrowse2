{"version":3,"file":"static/js/6156.99890433.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/gtf/src/util.ts","../../../node_modules/@gmod/gtf/src/parse.ts","../../../node_modules/@gmod/gtf/src/api.ts","../../../node_modules/@gmod/gtf/src/index.ts","../../../plugins/gtf/src/util.ts","../../../plugins/gtf/src/GtfAdapter/GtfAdapter.ts"],"sourcesContent":["//@ts-nocheck\n/** @module util */\n\n// Forks @gmod/gff-js and adapts it to parse and format GTF.\n\nconst fieldNames = [\n  'seq_name',\n  'source',\n  'featureType',\n  'start',\n  'end',\n  'score',\n  'strand',\n  'frame',\n  'attributes',\n]\n\n// TODO: check about enconding/escaping in gtf 9th column\n/**\n * Unescape a string/text value used in a GTF attribute.\n * Textual attributes should be surrounded by double quotes\n * source info:\n * https://mblab.wustl.edu/GTF22.html\n * https://en.wikipedia.org/wiki/Gene_transfer_format\n *\n * @param {String} s\n * @returns {String}\n */\nexport function unescape(s) {\n  if (s === null) {\n    return null\n  }\n  return String(s).replace(/%([0-9A-Fa-f]{2})/g, (_, seq) =>\n    String.fromCharCode(parseInt(seq, 16)),\n  )\n}\n\n/**\n * Escape a value for use in a GTF attribute value.\n *\n * @param {String} s\n * @returns {String}\n */\nfunction _escape(regex, s) {\n  return String(s).replace(regex, ch => {\n    let hex = ch.charCodeAt(0).toString(16).toUpperCase()\n\n    // lol, apparently there's no native function for fixed-width hex output\n    if (hex.length < 2) {\n      hex = `0${hex}`\n    }\n    return `%${hex}`\n  })\n}\n\nexport function escape(s) {\n  // eslint-disable-next-line no-control-regex\n  return _escape(/[\\n;\\r\\t=%&,\\x00-\\x1f\\x7f-\\xff]/g, s)\n}\n\n/**\n * Escape a value for use in a GTF column value.\n *\n * @param {String} s\n * @returns {String}\n */\nexport function escapeColumn(s) {\n  // eslint-disable-next-line no-control-regex\n  return _escape(/[\\n\\r\\t%\\x00-\\x1f\\x7f-\\xff]/g, s)\n}\n\n/**\n * Parse the 9th column (attributes) of a GTF feature line.\n *\n * @param {String} attrString\n * @returns {Object}\n */\nexport function parseAttributes(attrString) {\n  if (!(attrString && attrString.length) || attrString === '.') {\n    return {}\n  }\n\n  const attrs = {}\n\n  attrString\n    .replace(/\\r?\\n$/, '')\n    .slice(0, -1) // need to remove the last semicolon in the attributes\n    .split(';')\n    .forEach(attribute => {\n      if (!attribute) {\n        return\n      }\n      const attr = attribute.trim().split(' ')\n      if (!(attr[1] && attr[1].length)) {\n        return\n      }\n\n      attr[0] = attr[0].trim()\n      let arec = attrs[attr[0].trim()]\n      if (!arec) {\n        arec = []\n        attrs[attr[0]] = arec\n      }\n\n      // arec.push(unescape(attr[1].trim()))\n      arec.push(\n        ...attr[1]\n          .split(',')\n          .map(s => s.trim())\n          .map(unescape),\n      )\n    })\n  return attrs\n}\n\n/**\n * Parse a GTF feature line.\n *\n * @param {String} line\n * returns the parsed line in an object\n */\nexport function parseFeature(line) {\n  // assummed that there are no comments at the end of a line\n  // split the line into columns and replace '.' with null in each column\n  const f = line.split('\\t').map(a => (a === '.' ? null : a))\n\n  // unescape only the seq_name, source, and feature columns\n  f[0] = unescape(f[0])\n  f[1] = unescape(f[1])\n  f[2] = unescape(f[2])\n\n  f[8] = parseAttributes(f[8])\n  const parsed = {}\n  for (let i = 0; i < fieldNames.length; i += 1) {\n    parsed[fieldNames[i]] = f[i] === '.' ? null : f[i]\n  }\n  if (parsed.start !== null) {\n    parsed.start = parseInt(parsed.start, 10)\n  }\n  if (parsed.end !== null) {\n    parsed.end = parseInt(parsed.end, 10)\n  }\n  if (parsed.score !== null) {\n    parsed.score = parseFloat(parsed.score, 10)\n  }\n  if (parsed.strand != null) {\n    parsed.strand = parsed.strand\n  }\n  return parsed\n}\n\n/**\n * Parse a GTF directive/comment line.\n *\n * @param {String} line\n * @returns {Object} the information in the directive\n */\nexport function parseDirective(line) {\n  const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line)\n  // const match = /^\\s*\\#\\#\\s*(\\S+)\\s*(.*)/.exec(line)\n  if (!match) {\n    return null\n  }\n\n  // let [, name, contents] = match\n  const name = match[1]\n  let contents = match[2]\n  const parsed = { directive: name }\n  if (contents.length) {\n    contents = contents.replace(/\\r?\\n$/, '')\n    parsed.value = contents\n  }\n\n  // do a little additional parsing for sequence-region and genome-build directives\n  if (name === 'sequence-region') {\n    const [seqId, contentStart, contentEnd] = contents.split(/\\s+/, 3)\n    parsed.seq_id = seqId\n    parsed.start = contentStart && contentStart.replace(/\\D/g, '')\n    parsed.end = contentEnd && contentEnd.replace(/\\D/g, '')\n  } else if (name === 'genome-build') {\n    const [source, buildname] = contents.split(/\\s+/, 2)\n    parsed.source = source\n    parsed.buildname = buildname\n  }\n\n  return parsed\n}\n\n/**\n * Format an attributes object into a string suitable for the 9th column of GTF.\n *\n * @param {Object} attrs\n */\nexport function formatAttributes(attrs) {\n  const attrOrder = []\n  Object.keys(attrs).forEach(tag => {\n    const val = attrs[tag]\n    let valstring\n    // eslint-disable-next-line no-prototype-builtins\n    if (val.hasOwnProperty('toString')) {\n      valstring = escape(val.toString())\n    } else if (Array.isArray(val.values)) {\n      valstring = val.values.map(escape).join(',')\n    } else if (Array.isArray(val)) {\n      valstring = val.map(escape).join(',')\n    } else {\n      valstring = escape(val)\n    }\n    attrOrder.push(`${escape(tag)} ${valstring}`)\n  })\n  return attrOrder.length ? attrOrder.join('; ').concat(';') : '.'\n}\n\nconst translateStrand = ['-', '.', '+']\n\nfunction _formatSingleFeature(f, seenFeature) {\n  const attrString =\n    f.attributes === null || f.attributes === undefined\n      ? '.'\n      : formatAttributes(f.attributes)\n\n  const fields = []\n  for (let i = 0; i < 8; i += 1) {\n    const val = f[fieldNames[i]]\n    // deserialize strand\n    if (i === 6) {\n      fields[i] =\n        val === null || val === undefined\n          ? '.'\n          : translateStrand[val + 1] || val\n    } else {\n      fields[i] =\n        val === null || val === undefined ? '.' : escapeColumn(String(val))\n    }\n  }\n  fields[8] = attrString\n\n  const formattedString = `${fields.join('\\t')}\\n`\n\n  // if we have already output this exact feature, skip it\n  if (seenFeature[formattedString]) {\n    return ''\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  seenFeature[formattedString] = true\n  return formattedString\n}\n\nfunction _formatFeature(feature, seenFeature) {\n  if (Array.isArray(feature)) {\n    return feature.map(f => _formatFeature(f, seenFeature)).join('')\n  }\n\n  const strings = [_formatSingleFeature(feature, seenFeature)]\n  ;['child_features', 'derived_features'].forEach(multiSlot => {\n    if (feature[multiSlot]) {\n      strings.push(\n        ...feature[multiSlot].map(f => _formatFeature(f, seenFeature)),\n      )\n    }\n  })\n  return strings.join('')\n}\n\n/**\n * Format a feature object or array of\n * feature objects into one or more lines of GTF.\n *\n * @param {Object|Array[Object]} featureOrFeatures\n */\nexport function formatFeature(featureOrFeatures) {\n  const seen = {}\n  return _formatFeature(featureOrFeatures, seen)\n}\n\n/**\n * Format a directive into a line of GTF.\n *\n * @param {Object} directive\n * @returns {String}\n */\nexport function formatDirective(directive) {\n  let str = `##${directive.directive}`\n  if (directive.value) {\n    str += ` ${directive.value}`\n  }\n  str += '\\n'\n  return str\n}\n\n/**\n * Format a comment into a GTF comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param {Object} comment\n * @returns {String}\n */\nexport function formatComment(comment) {\n  return `# ${comment.comment}\\n`\n}\n\n/**\n * Format a sequence object as FASTA\n *\n * @param {Object} seq\n * @returns {String} formatted single FASTA sequence\n */\nexport function formatSequence(seq) {\n  return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${\n    seq.sequence\n  }\\n`\n}\n\n/**\n * Format a directive, comment, or feature,\n * or array of such items, into one or more lines of GTF.\n *\n * @param {Object|Array} itemOrItems\n */\nexport function formatItem(itemOrItems) {\n  function formatSingleItem(item) {\n    if (item[0] || item.attributes) {\n      return formatFeature(item)\n    }\n    if (item.directive) {\n      return formatDirective(item)\n    }\n    if (item.sequence) {\n      return formatSequence(item)\n    }\n    if (item.comment) {\n      return formatComment(item)\n    }\n    return '# (invalid item found during format)\\n'\n  }\n\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.map(item => formatSingleItem(item))\n  }\n  return formatSingleItem(itemOrItems)\n}\n","//@ts-nocheck\nimport * as GTF from './util'\n\nconst containerAttributes = {\n  Parent: 'child_features',\n  Derives_from: 'derived_features',\n}\n\nexport default class Parser {\n  constructor(args) {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const nullFunc = () => {}\n\n    Object.assign(this, {\n      featureCallback: args.featureCallback || nullFunc,\n      endCallback: args.endCallback || nullFunc,\n      commentCallback: args.commentCallback || nullFunc,\n      errorCallback: args.errorCallback || nullFunc,\n      directiveCallback: args.directiveCallback || nullFunc,\n      sequenceCallback: args.sequenceCallback || nullFunc,\n\n      // number of lines to buffer\n      bufferSize: args.bufferSize === undefined ? 1000 : args.bufferSize,\n\n      // features that we have to keep on hand for now because they\n      // might be referenced by something else\n      _underConstructionTopLevel: [],\n      // index of the above by ID\n      _underConstructionById: {},\n\n      _completedReferences: {},\n\n      // features that reference something we have not seen yet\n      // structured as:\n      // {  'some_id' : {\n      //     'Parent' : [ orphans that have a Parent attr referencing it ],\n      //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n      //    }\n      // }\n      _underConstructionOrphans: {},\n\n      // if this is true, the parser ignores the\n      // rest of the lines in the file.\n      eof: false,\n\n      lineNumber: 0,\n    })\n  }\n\n  addLine(line) {\n    if (this.eof) {\n      // otherwise, if we are done, ignore this line\n      return\n    }\n\n    this.lineNumber += 1\n\n    if (/^\\s*[^#\\s>]/.test(line)) {\n      // feature line, most common case\n      this._bufferLine(line)\n      return\n    }\n\n    const match = /^\\s*(#+)(.*)/.exec(line)\n    if (match) {\n      // directive or comment\n      // eslint-disable-next-line prefer-const\n      let [, hashsigns, contents] = match\n\n      if (hashsigns.length === 3) {\n        // sync directive, all forward-references are resolved.\n        this._emitAllUnderConstructionFeatures()\n      } else if (hashsigns.length === 2) {\n        const directive = GTF.parseDirective(line)\n\n        this._emitItem(directive)\n      } else {\n        contents = contents.replace(/\\s*/, '')\n        this._emitItem({ comment: contents })\n      }\n    } else if (/^\\s*$/.test(line)) {\n      // blank line, do nothing\n    } else {\n      // it's a parse error\n      const errLine = line.replace(/\\r?\\n?$/g, '')\n      throw new Error(`GTF parse error.  Cannot parse '${errLine}'.`)\n    }\n  }\n\n  _emitItem(i) {\n    if (i[0]) {\n      this.featureCallback(i)\n    } else if (i.directive) {\n      this.directiveCallback(i)\n    } else if (i.comment) {\n      this.commentCallback(i)\n    }\n  }\n\n  finish() {\n    this._emitAllUnderConstructionFeatures()\n    this.endCallback()\n  }\n\n  _enforceBufferSizeLimit(additionalItemCount = 0) {\n    const _unbufferItem = item => {\n      if (\n        item &&\n        item[0] &&\n        item[0].attributes &&\n        item[0].attributes.ID &&\n        item[0].attributes.ID[0]\n      ) {\n        const ids = item[0].attributes.ID\n        ids.forEach(id => {\n          delete this._underConstructionById[id]\n          delete this._completedReferences[id]\n        })\n        item.forEach(i => {\n          if (i.child_features) {\n            i.child_features.forEach(c => _unbufferItem(c))\n          }\n          if (i.derived_features) {\n            i.derived_features.forEach(d => _unbufferItem(d))\n          }\n        })\n      }\n    }\n\n    while (\n      this._underConstructionTopLevel.length + additionalItemCount >\n      this.bufferSize\n    ) {\n      const item = this._underConstructionTopLevel.shift()\n      this._emitItem(item)\n      _unbufferItem(item)\n    }\n  }\n\n  /**\n   * return all under-construction features, called when we know\n   * there will be no additional data to attach to them\n   * @private\n   */\n  _emitAllUnderConstructionFeatures() {\n    this._underConstructionTopLevel.forEach(this._emitItem.bind(this))\n\n    this._underConstructionTopLevel = []\n    this._underConstructionById = {}\n    this._completedReferences = {}\n\n    // if we have any orphans hanging around still, this is a\n    // problem. die with a parse error\n    if (\n      Object.values(this._underConstructionOrphans).filter(\n        entry => Object.keys(entry).length,\n      ).length\n    ) {\n      throw new Error(\n        `some features reference other features that do not exist in the file (or in the same '###' scope). ${JSON.stringify(\n          this._underConstructionOrphans,\n        )}`,\n      )\n    }\n  }\n\n  // do the right thing with a newly-parsed feature line\n  _bufferLine(line) {\n    const featureLine = GTF.parseFeature(line)\n    featureLine.child_features = []\n    featureLine.derived_features = []\n    // featureLine._lineNumber = this.lineNumber //< debugging aid\n\n    const featureNumber = this.lineNumber // no such thing as unique ID in GTF. make one up.\n    const isTranscript = featureLine.featureType === 'transcript' // trying to support the Cufflinks convention of adding a transcript line\n    // NOTE: a feature is an arrayref of one or more feature lines.\n    const ids = isTranscript\n      ? featureLine.attributes.transcript_id || []\n      : [featureNumber]\n    const parents = isTranscript\n      ? []\n      : featureLine.attributes.transcript_id || []\n    const derives = featureLine.attributes.Derives_from || []\n\n    if (!ids.length && !parents.length && !derives.length) {\n      // if it has no IDs and does not refer to anything, we can just\n      // output it\n      this._emitItem([featureLine])\n      return\n    }\n\n    function createTranscript(feature) {\n      const result = JSON.parse(JSON.stringify(feature))\n      result.featureType = 'transcript'\n      return GTF.formatFeature(result)\n    }\n\n    parents.forEach(parent => {\n      const underConst = this._underConstructionById[parent]\n      if (!underConst) {\n        this._bufferLine(createTranscript(featureLine))\n      }\n    })\n\n    let feature\n    ids.forEach(id => {\n      const existing = this._underConstructionById[id]\n      if (existing) {\n        existing.push(featureLine)\n        feature = existing\n      } else {\n        // haven't seen it yet, so buffer it so we can attach\n        // child features to it\n        feature = [featureLine]\n\n        this._enforceBufferSizeLimit(1)\n        if (!parents.length && !derives.length) {\n          this._underConstructionTopLevel.push(feature)\n        }\n        this._underConstructionById[id] = feature\n\n        // see if we have anything buffered that refers to it\n        this._resolveReferencesTo(feature, id)\n      }\n    })\n\n    // try to resolve all its references\n    this._resolveReferencesFrom(\n      feature || [featureLine],\n      { Parent: parents, Derives_from: derives },\n      ids,\n    )\n  }\n\n  _resolveReferencesTo(feature, id) {\n    const references = this._underConstructionOrphans[id]\n    if (!references) {\n      return\n    }\n\n    Object.keys(references).forEach(attrname => {\n      const pname = containerAttributes[attrname] || attrname.toLowerCase()\n      feature.forEach(loc => {\n        loc[pname].push(...references[attrname])\n        delete references[attrname]\n      })\n    })\n  }\n\n  _parseError(message) {\n    this.eof = true\n    this.errorCallback(`${this.lineNumber}: ${message}`)\n  }\n\n  _resolveReferencesFrom(feature, references, ids) {\n    // this is all a bit more awkward in javascript than it was in perl\n    function postSet(obj, slot1, slot2) {\n      let subObj = obj[slot1]\n      if (!subObj) {\n        subObj = {}\n        // eslint-disable-next-line no-param-reassign\n        obj[slot1] = subObj\n      }\n      const returnVal = subObj[slot2] || false\n      subObj[slot2] = true\n      return returnVal\n    }\n\n    function expandFeature(parentFeature, childFeature) {\n      // eslint-disable-next-line no-param-reassign\n      parentFeature[0].start = Math.min(\n        parentFeature[0].start,\n        childFeature[0].start,\n      )\n      // eslint-disable-next-line no-param-reassign\n      parentFeature[0].end = Math.max(parentFeature[0].end, childFeature[0].end)\n    }\n\n    Object.entries(references).forEach(([attrname, toIds]) => {\n      let pname\n      toIds.forEach(toId => {\n        const otherFeature = this._underConstructionById[toId]\n        if (otherFeature) {\n          expandFeature(otherFeature, feature)\n          if (!pname) {\n            pname = containerAttributes[attrname] || attrname.toLowerCase()\n          }\n\n          if (\n            !ids.filter(id =>\n              postSet(this._completedReferences, id, `${attrname},${toId}`),\n            ).length\n          ) {\n            otherFeature.forEach(location => {\n              location[pname].push(feature)\n            })\n          }\n        } else {\n          if (!this._underConstructionOrphans[toId]) {\n            this._underConstructionOrphans[toId] = {}\n          }\n          if (!this._underConstructionOrphans[toId][attrname]) {\n            this._underConstructionOrphans[toId][attrname] = []\n          }\n          this._underConstructionOrphans[toId][attrname].push(feature)\n        }\n      })\n    })\n  }\n}\n","//@ts-nocheck\nimport Parser from './parse'\nimport { formatItem, formatSequence } from './util'\n\nimport { Transform } from 'stream'\nimport { StringDecoder as Decoder } from 'string_decoder'\n\n// don't load fs native module if running in webpacked code\n// eslint-disable-next-line camelcase\nconst fs = typeof __webpack_require__ !== 'function' ? require('fs') : null\n\n// call a callback on the next process tick if running in\n// an environment that supports it\nfunction _callback(callback) {\n  if (process && process.nextTick) {\n    process.nextTick(callback)\n  } else {\n    callback()\n  }\n}\n\n// shared arg processing for the parse routines\nfunction _processParseOptions(options, additionalDefaults = {}) {\n  const out = Object.assign(\n    {\n      parseFeatures: true,\n      parseDirectives: false,\n      parseSequences: true,\n      parseComments: false,\n    },\n    additionalDefaults,\n    options,\n  )\n\n  if (options.parseAll) {\n    out.parseFeatures = true\n    out.parseDirectives = true\n    out.parseComments = true\n    out.parseSequences = true\n  }\n\n  return out\n}\n\nclass GTFTransform extends Transform {\n  constructor(inputOptions = {}) {\n    const options = _processParseOptions(inputOptions)\n    super({ objectMode: true })\n\n    this.encoding = inputOptions.encoding || 'utf8'\n\n    this.decoder = new Decoder()\n    this.textBuffer = ''\n\n    const push = this.push.bind(this)\n    this.parser = new Parser({\n      featureCallback: options.parseFeatures ? push : null,\n      directiveCallback: options.parseDirectives ? push : null,\n      commentCallback: options.parseComments ? push : null,\n      sequenceCallback: options.parseSequences ? push : null,\n      errorCallback: err => this.emit('error', err),\n      bufferSize: options.bufferSize,\n    })\n  }\n\n  _addLine(data) {\n    const line = data.toString('utf8')\n    if (line) {\n      this.parser.addLine(line)\n    }\n  }\n\n  _nextText(buffer) {\n    const pieces = (this.textBuffer + buffer).split(/\\r?\\n/)\n    this.textBuffer = pieces.pop()\n\n    if (this.maxLineLength && this.textBuffer.length > this.maxLineLength) {\n      this.emit('error', new Error('maximum line size exceeded'))\n      return\n    }\n\n    pieces.forEach(piece => this._addLine(piece))\n  }\n\n  _transform(chunk, encoding, callback) {\n    this._nextText(this.decoder.write(chunk))\n    _callback(callback)\n  }\n\n  _flush(callback) {\n    if (this.decoder.end) {\n      this._nextText(this.decoder.end())\n    }\n    if (this.textBuffer != null) {\n      this._addLine(this.textBuffer)\n    }\n    this.parser.finish()\n    _callback(callback)\n  }\n}\n\n/**\n * Parse a stream of text data into a stream of feature,\n * directive, and comment objects.\n *\n * @param {Object} options optional options object\n * @param {string} options.encoding text encoding of the input GTF. default 'utf8'\n * @param {boolean} options.parseAll default false.  if true, will parse all items. overrides other flags\n * @param {boolean} options.parseFeatures default true\n * @param {boolean} options.parseDirectives default false\n * @param {boolean} options.parseComments default false\n * @param {boolean} options.parseSequences default true\n * @param {Number} options.bufferSize maximum number of GTF lines to buffer. defaults to 1000\n * @returns {ReadableStream} stream (in objectMode) of parsed items\n */\nexport function parseStream(options = {}) {\n  const newOptions = Object.assign({ bufferSize: 1000 }, options)\n  return new GTFTransform(newOptions)\n}\n\n/**\n * Read and parse a GTF file from the filesystem.\n *\n * @param {string} filename the filename of the file to parse\n * @param {Object} options optional options object\n * @param {string} options.encoding the file's string encoding, defaults to 'utf8'\n * @param {boolean} options.parseAll default false.  if true, will parse all items. overrides other flags\n * @param {boolean} options.parseFeatures default true\n * @param {boolean} options.parseDirectives default false\n * @param {boolean} options.parseComments default false\n * @param {boolean} options.parseSequences default true\n * @param {Number} options.bufferSize maximum number of GTF lines to buffer. defaults to 1000\n * @returns {ReadableStream} stream (in objectMode) of parsed items\n */\nexport function parseFile(filename, options) {\n  return fs.createReadStream(filename).pipe(parseStream(options))\n}\n\n/**\n * Synchronously parse a string containing GTF and return\n * an arrayref of the parsed items.\n *\n * @param {string} str\n * @param {Object} inputOptions optional options object\n * @param {boolean} inputOptions.parseAll default false.  if true, will parse all items. overrides other flags\n * @param {boolean} inputOptions.parseFeatures default true\n * @param {boolean} inputOptions.parseDirectives default false\n * @param {boolean} inputOptions.parseComments default false\n * @param {boolean} inputOptions.parseSequences default true\n * @returns {Array} array of parsed features, directives, and/or comments\n */\nexport function parseStringSync(str, inputOptions = {}) {\n  if (!str) {\n    return []\n  }\n\n  const options = _processParseOptions(inputOptions)\n\n  const items = []\n  const push = items.push.bind(items)\n\n  const parser = new Parser({\n    featureCallback: options.parseFeatures ? push : null,\n    directiveCallback: options.parseDirectives ? push : null,\n    commentCallback: options.parseComments ? push : null,\n    sequenceCallback: options.parseSequences ? push : null,\n    bufferSize: Infinity,\n    errorCallback: err => {\n      throw err\n    },\n  })\n\n  str.split(/\\r?\\n/).forEach(parser.addLine.bind(parser))\n  parser.finish()\n\n  return items\n}\n\n/**\n * Format an array of GTF items (features,directives,comments) into string of GTF.\n * Does not insert synchronization (###) marks.\n * Does not insert directive if it's not already there.\n *\n * @param {Array[Object]} items\n * @returns {String} the formatted GTF\n */\nexport function formatSync(items) {\n  // sort items into seq and other\n  const other = []\n  const sequences = []\n  items.forEach(i => {\n    if (i.sequence) {\n      sequences.push(i)\n    } else {\n      other.push(i)\n    }\n  })\n  let str = other.map(formatItem).join('')\n  if (sequences.length) {\n    str += '##FASTA\\n'\n    str += sequences.map(formatSequence).join('')\n  }\n  return str\n}\n\nclass FormattingTransform extends Transform {\n  constructor(options = {}) {\n    super(Object.assign(options, { objectMode: true }))\n    this.linesSinceLastSyncMark = 0\n    this.minLinesBetweenSyncMarks = options.minSyncLines || 100\n    this.insertVersionDirective = options.insertVersionDirective || false\n    this.haveWeEmittedData = false\n    this.fastaMode = false\n  }\n\n  _transform(chunk, encoding, callback) {\n    // if we have not emitted anything yet, and this first\n    // chunk is not a gtf directive, emit one\n    let str\n    if (\n      !this.haveWeEmittedData &&\n      this.insertVersionDirective &&\n      (chunk[0] || chunk).directive !== 'gtf'\n    ) {\n      this.push('##gtf\\n')\n    }\n\n    // if it's a sequence chunk coming down, emit a FASTA directive and\n    // change to FASTA mode\n    if (chunk.sequence && !this.fastaMode) {\n      this.push('##FASTA\\n')\n      this.fastaMode = true\n    }\n\n    if (Array.isArray(chunk)) {\n      str = chunk.map(formatItem).join('')\n    } else {\n      str = formatItem(chunk)\n    }\n\n    this.push(str)\n\n    if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {\n      this.push('###\\n')\n      this.linesSinceLastSyncMark = 0\n    } else {\n      // count the number of newlines in this chunk\n      let count = 0\n      for (let i = 0; i < str.length; i += 1) {\n        if (str[i] === '\\n') {\n          count += 1\n        }\n      }\n      this.linesSinceLastSyncMark += count\n    }\n\n    this.haveWeEmittedData = true\n    _callback(callback)\n  }\n}\n\n/**\n * Format a stream of items (of the type produced\n * by this script) into a stream of GTF text.\n *\n * Inserts synchronization (###) marks automatically.\n *\n * @param {Object} options\n * @param {Object} options.minSyncLines minimum number of lines between ### marks. default 100\n * @param {Boolean} options.insertVersionDirective\n *  if the first item in the stream is not a ##gff-version directive, insert one to show it's gtf\n *  default false\n */\nexport function formatStream(options) {\n  return new FormattingTransform(options)\n}\n\n/**\n * Format a stream of items (of the type produced\n * by this script) into a GTF file and write it to the filesystem.\n\n * Inserts synchronization (###) marks and a ##gtf\n * directive automatically (if one is not already present).\n *\n * @param {ReadableStream} stream the stream to write to the file\n * @param {String} filename the file path to write to\n * @param {Object} options\n * @param {String} options.encoding default 'utf8'. encoding for the written file\n * @param {Number} options.minSyncLines\n *  minimum number of lines between sync (###) marks. default 100\n * @param {Boolean} options.insertVersionDirective\n *  if the first item in the stream is not a ##gtf directive, insert one.\n *  default false\n * @returns {Promise} promise for the written filename\n */\nexport function formatFile(stream, filename, options = {}) {\n  const newOptions = Object.assign(\n    {\n      insertVersionDirective: false,\n    },\n    options,\n  )\n\n  return new Promise((resolve, reject) => {\n    stream\n      .pipe(new FormattingTransform(newOptions))\n      .on('end', () => resolve(filename))\n      .on('error', reject)\n      .pipe(\n        fs.createWriteStream(filename, {\n          encoding: newOptions.encoding || 'utf8',\n        }),\n      )\n  })\n}\n","//@ts-nocheck\nimport {\n  parseStream,\n  parseFile,\n  parseStringSync,\n  formatSync,\n  formatStream,\n  formatFile,\n} from './api'\n\nimport * as util from './util'\n\nexport default {\n  parseStream,\n  parseFile,\n  parseStringSync,\n  formatSync,\n  formatStream,\n  formatFile,\n  util,\n}\n","export type Strand = '+' | '-' | '.' | '?'\nexport interface FeatureLoc {\n  [key: string]: unknown\n  start: number\n  end: number\n  strand: Strand\n  seq_name: string\n  child_features: FeatureLoc[][]\n  data: unknown\n  derived_features: unknown\n  attributes: { [key: string]: unknown[] }\n}\n\nexport function featureData(data: FeatureLoc) {\n  const f: Record<string, unknown> = { ...data }\n  ;(f.start as number) -= 1 // convert to interbase\n  f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[data.strand] // convert strand\n  f.phase = Number(data.frame)\n  f.refName = data.seq_name\n  if (data.score === null) {\n    delete f.score\n  }\n  if (data.frame === null) {\n    delete f.score\n  }\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_name',\n    'score',\n    'featureType',\n    'source',\n    'frame',\n    'strand',\n  ])\n  for (const a of Object.keys(data.attributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (data.attributes[a] !== null) {\n      let attr = data.attributes[a] as string[] | string\n      if (Array.isArray(attr) && attr.length === 1) {\n        // gtf uses double quotes for text values in the attributes column,\n        // remove them\n        attr = `${attr[0]}`.replaceAll(/^\"|\"$/g, '')\n      }\n      f[b] = attr\n    }\n  }\n  f.refName = f.seq_name\n  f.type = f.featureType\n\n  // the SimpleFeature constructor takes care of recursively inflating subfeatures\n  if (data.child_features && data.child_features.length > 0) {\n    f.subfeatures = data.child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    )\n  }\n\n  delete f.child_features\n  delete f.data\n  delete f.derived_features\n  // eslint-disable-next-line no-underscore-dangle\n  delete f._linehash\n  delete f.attributes\n  delete f.seq_name\n  delete f.featureType\n  delete f.frame\n\n  if (f.transcript_id) {\n    f.name = f.transcript_id\n  }\n  return f\n}\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { SimpleFeature, Feature } from '@jbrowse/core/util'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport gtf from '@gmod/gtf'\n\n// locals\nimport { FeatureLoc, featureData } from '../util'\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class extends BaseFeatureDataAdapter {\n  protected gtfFeatures?: Promise<{\n    feats: { [key: string]: string[] }\n  }>\n\n  protected intervalTrees: {\n    [key: string]: Promise<IntervalTree | undefined> | undefined\n  } = {}\n\n  private async loadDataP(opts: BaseOptions = {}) {\n    const gtfLoc = this.getConf('gtfLocation')\n    const buffer = await openLocation(gtfLoc, this.pluginManager).readFile(opts)\n\n    const buf = isGzip(buffer) ? await unzip(buffer) : buffer\n    // 512MB  max chrome string length is 512MB\n    if (buf.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buf)\n\n    const lines = data\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && !f.startsWith('#'))\n    const feats = {} as { [key: string]: string[] }\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]\n      if (line.startsWith('#')) {\n        continue\n      }\n      const tab = line.indexOf('\\t')\n      const refName = line.slice(0, tab)\n      if (!feats[refName]) {\n        feats[refName] = []\n      }\n      feats[refName].push(lines[i])\n    }\n\n    return { feats }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.gtfFeatures) {\n      this.gtfFeatures = this.loadDataP(opts).catch(e => {\n        this.gtfFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gtfFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { feats } = await this.loadData(opts)\n    return Object.keys(feats)\n  }\n\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { feats } = await this.loadData()\n    const lines = feats[refName]\n    if (!lines) {\n      return undefined\n    }\n    const data = gtf.parseStringSync(lines.join('\\n'), {\n      parseFeatures: true,\n      parseComments: false,\n      parseDirectives: false,\n      parseSequences: false,\n    }) as FeatureLoc[][]\n\n    const intervalTree = new IntervalTree()\n    const ret = data.flat().map(\n      (f, i) =>\n        new SimpleFeature({\n          data: featureData(f),\n          id: `${this.id}-${refName}-${i}`,\n        }),\n    )\n\n    for (let i = 0; i < ret.length; i++) {\n      const obj = ret[i]\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n    return intervalTree\n  }\n\n  private async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch(e => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const intervalTree = await this.loadFeatureIntervalTree(refName)\n        intervalTree?.search([start, end]).forEach(f => observer.next(f))\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n  public freeResources(/* { region } */) {}\n}\n"],"names":["fieldNames","unescape","s","String","replace","_","seq","fromCharCode","parseInt","_escape","regex","ch","hex","charCodeAt","toString","toUpperCase","length","concat","escape","escapeColumn","parseAttributes","attrString","attrs","slice","split","forEach","attribute","_arec","attr","trim","arec","push","apply","_toConsumableArray","map","parseFeature","line","f","a","parsed","i","start","end","score","parseFloat","strand","parseDirective","match","exec","name","contents","directive","value","_contents$split","_contents$split2","_slicedToArray","seqId","contentStart","contentEnd","seq_id","_contents$split3","_contents$split4","source","buildname","formatAttributes","attrOrder","Object","keys","tag","valstring","val","hasOwnProperty","Array","isArray","values","join","translateStrand","_formatSingleFeature","seenFeature","attributes","undefined","fields","formattedString","_formatFeature","feature","strings","multiSlot","formatFeature","featureOrFeatures","formatDirective","str","formatComment","comment","formatSequence","id","description","sequence","formatItem","itemOrItems","formatSingleItem","item","containerAttributes","Parent","Derives_from","Parser","args","_classCallCheck","nullFunc","assign","this","featureCallback","endCallback","commentCallback","errorCallback","directiveCallback","sequenceCallback","bufferSize","_underConstructionTopLevel","_underConstructionById","_completedReferences","_underConstructionOrphans","eof","lineNumber","_createClass","key","test","_bufferLine","_match","hashsigns","_emitAllUnderConstructionFeatures","GTF","_emitItem","errLine","Error","_this","additionalItemCount","arguments","_unbufferItem","ID","child_features","c","derived_features","d","shift","bind","filter","entry","JSON","stringify","_this2","featureLine","featureNumber","isTranscript","featureType","ids","transcript_id","parents","derives","parent","result","parse","createTranscript","existing","_enforceBufferSizeLimit","_resolveReferencesTo","_resolveReferencesFrom","references","attrname","pname","toLowerCase","loc","_loc$pname","message","_this3","entries","_ref","_ref2","toId","parentFeature","childFeature","otherFeature","Math","min","max","obj","slot1","slot2","subObj","returnVal","postSet","location","fs","_callback","callback","process","nextTick","_processParseOptions","options","additionalDefaults","out","parseFeatures","parseDirectives","parseSequences","parseComments","parseAll","GTFTransform","_Transform","_inherits","_super","_createSuper","inputOptions","call","objectMode","encoding","decoder","Decoder","textBuffer","_assertThisInitialized","parser","err","emit","data","addLine","buffer","pieces","pop","maxLineLength","piece","_addLine","chunk","_nextText","write","finish","Transform","parseStream","newOptions","FormattingTransform","_Transform2","_super2","linesSinceLastSyncMark","minLinesBetweenSyncMarks","minSyncLines","insertVersionDirective","haveWeEmittedData","fastaMode","count","parseFile","filename","createReadStream","pipe","parseStringSync","items","Infinity","formatSync","other","sequences","formatStream","formatFile","stream","Promise","resolve","reject","on","createWriteStream","util","featureData","_objectSpread","phase","Number","frame","refName","seq_name","defaultFields","Set","_i","_Object$keys","b","has","replaceAll","type","subfeatures","flatMap","childLocs","childLoc","_linehash","isGzip","buf","_default","_BaseFeatureDataAdapt","_len","_key","gtfFeatures","intervalTrees","_loadDataP","_asyncToGenerator","_regeneratorRuntime","mark","_callee","opts","gtfLoc","lines","feats","tab","_args","wrap","_context","prev","next","getConf","openLocation","pluginManager","readFile","sent","unzip","t0","TextDecoder","fatal","decode","startsWith","abrupt","indexOf","stop","_loadData","_callee2","_args2","_context2","loadDataP","catch","e","_getRefNames","_callee3","_yield$this$loadData","_args3","_context3","loadData","_loadFeatureIntervalTreeHelper","_callee4","_yield$this$loadData2","intervalTree","ret","_context4","gtf","IntervalTree","flat","SimpleFeature","insert","get","_x","_loadFeatureIntervalTree","_callee5","_this4","_context5","loadFeatureIntervalTreeHelper","_x2","query","_this5","ObservableCreate","_callee6","observer","_context6","loadFeatureIntervalTree","search","complete","error","_x3","signal","BaseFeatureDataAdapter"],"sourceRoot":""}