{"version":3,"file":"static/js/6834.97a117fc.chunk.js","mappings":"sOA0Be,MAAMA,UAAsBC,EAAAA,uBAOzC,kBAAaC,CAAaC,GACxB,MAAMC,EAAKC,KAAKC,cACVC,EAAS,IAAIC,EAAAA,EAAO,CACxBC,YAAYC,EAAAA,EAAAA,cAAaL,KAAKM,QAAQ,kBAAmBP,KAErDQ,QAAeL,EAAOM,UAAUV,GAEtC,MAAO,CAAEI,SAAQK,SAAQE,OADV,IAAIC,EAAAA,EAAI,CAAEC,QAASJ,EAAOI,UAE3C,CAEA,eAAaC,CAAUd,GAOrB,OANKE,KAAKa,SACRb,KAAKa,OAASb,KAAKH,aAAaC,GAAMgB,OAAMC,IAE1C,MADAf,KAAKa,YAASG,EACRD,CAAC,KAGJf,KAAKa,MACd,CAEA,iBAAaI,CAAYnB,GACvB,MAAM,OAAES,SAAiBP,KAAKY,UAAUd,GACxC,OAAOoB,OAAOC,KAAKZ,EAAOa,WAC5B,CAEA,eAAMZ,CAAUV,GACd,MAAM,OAAEW,EAAM,OAAEF,SAAiBP,KAAKY,UAAUd,IAC1C,QAAEuB,EAAO,SAAEC,GAAaf,GACxB,OAAEgB,KAAWC,GAASf,EAAOE,QACnC,MAAO,CACLU,UACAC,WACAX,QAAS,IAAKa,GACdD,OAAQL,OAAOO,YACbF,EAAOG,KAAI,EAAGC,OAAMC,aAAc,CAACD,EAAMC,MAG/C,CAEA,uBAAaC,CACXC,EACAhC,EAAoB,CAAC,EACrBiC,EACAC,EACAC,EAAgBH,GAEhB,MAAM,OAAEI,GAAWpC,EACbqC,EAAcnC,KAAKM,QAAQ,eAC3B8B,EAAiBpC,KAAKM,QAAQ,mBAC9B,OAAEG,EAAM,OAAEP,SAAiBF,KAAKY,UAAUd,GAC1CuC,QAAcnC,EAAOoC,YACzBR,EAAMS,QACNT,EAAMU,MACNV,EAAMW,IACN,CACEP,SACAQ,aAAcZ,EAAMW,IAAMX,EAAMU,QAGpC,GAAIR,GAAmBK,EAAMM,OAAQ,CACnC,IAAIC,EAAWC,IACXC,GAAS,IACb,IAAK,MAAMC,KAAQV,EACbU,EAAKP,MAAQI,IACfA,EAAWG,EAAKP,OAEdO,EAAKN,IAAMK,IACbA,EAASC,EAAKN,KAGlB,GAAIK,EAAShB,EAAMW,KAAOG,EAAWd,EAAMU,MAQzC,kBAPMxC,KAAK6B,kBACT,IAAKC,EAAOU,MAAOI,EAAUH,IAAKK,GAClChD,EACAiC,GACA,EACAD,EAIN,CAEA,MAAMkB,EAAoB,CAAC,EAK3B,GAAIX,EAAMY,MAAKC,QAAoBlC,IAAfkC,EAAEC,WACpB,MAAM,IAAIC,MAAM,4BAElB,IAAK,MAAML,KAAQV,EAAO,CACxB,MAAMgB,EAAO5C,EAAO6C,UAClB,GAAGxB,EAAMS,YAAYQ,EAAKP,UAAUO,EAAKN,QAAQM,EAAKvB,OACtD,CAAE2B,SAAUJ,EAAKI,WAGbI,EAAOF,EAAKjB,GACbY,EAAkBO,KACrBP,EAAkBO,GAAQ,IAE5B,MAAM,SACJJ,EAAQ,KACRK,EAAI,WACJC,EAAU,YACVC,EAAW,YACXC,EAAW,WACXC,EAAU,WACVC,EAAU,SACVC,EAAQ,WACRC,EAAU,SACVC,EAAQ,MACRC,EAAK,MACLC,KACG1C,GACD6B,EAEEc,EAAcP,GAChBQ,EAAAA,EAAAA,IAAW,CACTV,cACAC,cACAC,aACAC,aACAV,WACAZ,QAAST,EAAMS,QACfC,MAAOO,EAAKP,QAEd,GAEJ,IAAI6B,EAAAA,EAAAA,IAA0BhB,GAAO,CACnC,MAAMH,GAAIoB,EAAAA,EAAAA,IAAwB,IAC7B9C,EACH2B,WACAK,OACAhB,MAAOO,EAAKP,MACZC,IAAKM,EAAKN,IACVF,QAAST,EAAMS,QACf2B,MAAO/B,GAAekB,EAAKlB,GAAe+B,EAC1CR,cACAE,aACAC,aACAE,aACAC,WACAG,gBAEEZ,EACFP,EAAkBO,GAAMgB,KAAKrB,IAG3BsB,EAAAA,EAAAA,gBACEtB,EAAEV,MACFU,EAAET,IACFR,EAAcO,MACdP,EAAcQ,MAGhBV,EAAS0C,KACP,IAAIC,EAAAA,cAAc,CAAEC,GAAI,GAAG3E,KAAK2E,MAAMxB,IAAYE,KAAMH,IAIhE,MAEIsB,EAAAA,EAAAA,gBACEzB,EAAKP,MACLO,EAAKN,IACLR,EAAcO,MACdP,EAAcQ,MAGhBV,EAAS0C,KACP,IAAIC,EAAAA,cAAc,CAChBC,GAAI,GAAG3E,KAAK2E,MAAMxB,IAClBE,KAAM,IACD7B,EACH2B,WACAK,OACAhB,MAAOO,EAAKP,MACZ0B,MAAO/B,GAAekB,EAAKlB,GAAe+B,EAC1CzB,IAAKM,EAAKN,IACVF,QAAST,EAAMS,QACf4B,iBAMZ,CAEAjD,OAAO0D,QAAQ5B,GAAmBtB,KAAI,EAAEC,EAAMwC,MAC5C,MAAMU,GAAIC,EAAAA,EAAAA,KAAIX,EAAYzC,KAAIwB,GAAKA,EAAEV,SAC/BzB,GAAIgE,EAAAA,EAAAA,KAAIZ,EAAYzC,KAAIwB,GAAKA,EAAET,OACrC,IAAI+B,EAAAA,EAAAA,gBAAeK,EAAG9D,EAAGkB,EAAcO,MAAOP,EAAcQ,KAAM,CAChE,MAAM,SAAEU,EAAQ,OAAE6B,GAAWb,EAAY,GACzCpC,EAAS0C,KACP,IAAIC,EAAAA,cAAc,CAChBC,GAAI,GAAG3E,KAAK2E,MAAMxB,WAClBE,KAAM,CACJG,KAAM,OACNW,cACAa,SACArD,OACAa,MAAOqC,EACPpC,IAAK1B,EACLwB,QAAST,EAAMS,WAIvB,KAEFR,EAASkD,UACX,CACO3C,WAAAA,CAAYR,EAAehC,EAAoB,CAAC,GACrD,OAAOoF,EAAAA,EAAAA,mBAA0BC,UAC/B,UACQnF,KAAK6B,kBAAkBC,EAAOhC,EAAMiC,GAAU,EACtD,CAAE,MAAOhB,GACPgB,EAASqD,MAAMrE,EACjB,IACCjB,EAAKoC,OACV,CAEOmD,aAAAA,GAAuB,E,6ECzOzB,SAASf,EAAwBgB,GACtC,MACEnB,YAAaoB,EAAc,WAC3BxB,EAAU,SACVC,EAAQ,WACRJ,EAAU,WACVC,EAAU,YACVH,EAAW,QACXnB,EAAO,OACPyC,EAAS,KACNxD,GACD8D,EAEJ,IAAKvB,IAAeC,IAAagB,EAC/B,OAAOM,EAGT,MAAMnB,EAAgC,GA8FtC,OA7FAoB,EACGC,QAAOC,GAAwB,UAAfA,EAAMjC,OACtBkC,MAAK,CAACC,EAAGC,IAAMD,EAAEnD,MAAQoD,EAAEpD,SAC1BqD,SAAQC,IACR,MAAMtD,EAAQsD,EAAMtD,MACdC,EAAMqD,EAAMrD,IAClB,GAAIsB,GAActB,EAAK,CAErB,MAAMsD,EAAQf,EAAS,EAAI,OAAS,QACpCb,EAAYI,KAAK,CACff,KAAM,GAAGuC,cACTvD,QACAC,MACAF,WAEJ,MAAO,GAAIwB,EAAavB,GAASuB,EAAatB,GAAOuB,GAAYvB,EAAK,CAEpE,MAAMsD,EAAQf,EAAS,EAAI,OAAS,QACpCb,EAAYI,KACV,CACEf,KAAM,GAAGuC,cACTvD,QACAC,IAAKsB,EACLxB,WAEF,CACEiB,KAAM,MACNhB,MAAOuB,EACPtB,MACAF,WAGN,MAAO,GAAIwB,GAAcvB,GAASwB,GAAYvB,EAE5C0B,EAAYI,KAAK,CACff,KAAM,MACNhB,QACAC,MACAF,iBAEG,GAAIwB,EAAavB,GAASuB,EAAatB,GAAOuB,EAAWvB,EAAK,CAEnE,MAAMuD,EAAYhB,EAAS,EAAI,OAAS,QAClCiB,EAAajB,EAAS,EAAI,QAAU,OAC1Cb,EAAYI,KACV,CACEf,KAAM,GAAGwC,cACTxD,QACAC,IAAKsB,EACLxB,WAEF,CACEiB,KAAM,MACNhB,MAAOuB,EACPtB,IAAKuB,EACLzB,WAEF,CACEiB,KAAM,GAAGyC,cACTzD,MAAOwB,EACPvB,MACAF,WAGN,MAAO,GAAIwB,GAAcvB,GAASwB,EAAWxB,GAASwB,EAAWvB,EAAK,CAEpE,MAAMsD,EAAQf,EAAS,EAAI,QAAU,OACrCb,EAAYI,KACV,CACEf,KAAM,MACNhB,QACAC,IAAKuB,EACLzB,WAEF,CACEiB,KAAM,GAAGuC,cACTvD,MAAOwB,EACPvB,MACAF,WAGN,MAAO,GAAIyB,GAAYxB,EAAO,CAE5B,MAAMuD,EAAQf,EAAS,EAAI,QAAU,OACrCb,EAAYI,KAAK,CACff,KAAM,GAAGuC,cACTvD,QACAC,MACAF,WAEJ,KAGG,IAAKf,EAAMwD,SAAQxB,KAAM,OAAQjB,UAAS4B,cACnD,CAwBO,SAASC,GAAW,MACzB5B,EAAK,SACLW,EAAQ,QACRZ,EAAO,YACPmB,EAAW,WACXE,EAAU,WACVC,EAAU,YACVF,IAUA,MAAMQ,EAAc,GACd+B,EAASxC,GAAeC,GAAe,GAC7C,IAAK,IAAIiC,EAAI,EAAGA,EAAIhC,EAAYgC,IAAK,CACnC,MAAMO,GAAQD,EAAON,IAAM,GAAKpD,EAC1B4D,EAAOD,GAAQtC,IAAa+B,IAAM,GACxCzB,EAAYI,KAAK,CACfpB,SAAU,GAAGA,KAAYyC,IACzBpD,MAAO2D,EACP1D,IAAK2D,EACL7D,UACAiB,KAAM,SAEV,CACA,OAAOW,CACT,CACO,SAASkC,EACdC,EACAC,EACAC,EACAC,EACAtE,EACA1B,EACA0C,EACAuD,GAEA,MAAMC,EAAIL,EAAKM,MAAM,MACfrE,EAAUoE,EAAEJ,GACZ/D,GAASmE,EAAEH,GACXK,EAAUL,IAAaC,EAAS,EAAI,EACpChE,GAAOkE,EAAEF,GAAUI,EACnBxD,EAAOqD,EArEf,SAAuBnF,EAAkB+E,GACvC,MAAM,YACJ3C,EAAW,WACXC,EAAU,YACVF,EAAW,SACXM,EAAQ,WACRD,EAAU,WACVF,KACGrC,GACDN,OAAOO,YAAY6E,EAAKM,MAAM,MAAMlF,KAAI,CAACwB,EAAG4D,IAAM,CAACvF,EAAOuF,GAAI5D,MAElE,MAAO,IACF1B,EACHmC,YAAaA,GAAaiD,MAAM,KAAKlF,KAAIqF,IAAMA,IAC/CrD,YAAaA,GAAakD,MAAM,KAAKlF,KAAIqF,IAAMA,IAC/ClD,WAAYA,GAAY+C,MAAM,KAAKlF,KAAIqF,IAAMA,IAC7ChD,YAAaA,EACbC,UAAWA,EACXJ,YAAaA,EAEjB,CAkDMoD,CAAcN,EAAOJ,GACrB7F,EAAO6C,UAAUgD,EAAM,CAAEnD,cAEvB,WACJS,EAAU,WACVC,EAAU,YACVF,EAAW,YACXD,EAAW,WACXK,EAAU,SACVC,EAAQ,KACRR,EAAI,MACJU,EACAD,MAAOgD,EACPxD,WAAYyD,EACZpD,SAAUqD,KACP3F,GACD6B,EACEc,EAAcP,EAChBQ,EAAW,CACT5B,QACAW,WACAZ,UACAmB,cACAE,aACAC,aACAF,gBAEF,GACET,EAAI,IACL1B,EACHgC,OACAU,MAAO/B,GAAekB,EAAKlB,GAAe+B,EAC1C1B,QACAC,MACAF,UACAY,WACAgB,eAEF,OAAO,IAAIO,EAAAA,cAAc,CACvBC,GAAIxB,EACJE,KAAMgB,EAA0BhB,GAC5BiB,EAAwB,CACtBP,aACAC,WACAJ,aACAC,aACAH,iBACGR,IAELA,GAER,CAEO,SAASmB,EAA0BnB,GAKxC,OAAOA,EAAEa,YAAcb,EAAEU,YAA2B,IAAbV,EAAE8B,MAC3C,C","sources":["../../../plugins/bed/src/BigBedAdapter/BigBedAdapter.ts","../../../plugins/bed/src/util.ts"],"sourcesContent":["import { BigBed } from '@gmod/bbi'\nimport BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  doesIntersect2,\n  max,\n  min,\n  Feature,\n  SimpleFeature,\n} from '@jbrowse/core/util'\nimport { Observer } from 'rxjs'\nimport { SimpleFeatureSerializedNoId } from '@jbrowse/core/util/simpleFeature'\n\n// locals\nimport {\n  isUcscProcessedTranscript,\n  makeBlocks,\n  ucscProcessedTranscript,\n} from '../util'\n\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n  private cached?: Promise<{\n    bigbed: BigBed\n    header: Awaited<ReturnType<BigBed['getHeader']>>\n    parser: BED\n  }>\n\n  public async configurePre(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bigbed = new BigBed({\n      filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n    })\n    const header = await bigbed.getHeader(opts)\n    const parser = new BED({ autoSql: header.autoSql })\n    return { bigbed, header, parser }\n  }\n\n  public async configure(opts?: BaseOptions) {\n    if (!this.cached) {\n      this.cached = this.configurePre(opts).catch(e => {\n        this.cached = undefined\n        throw e\n      })\n    }\n    return this.cached\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { parser, header } = await this.configure(opts)\n    const { version, fileType } = header\n    const { fields, ...rest } = parser.autoSql\n    return {\n      version,\n      fileType,\n      autoSql: { ...rest },\n      fields: Object.fromEntries(\n        fields.map(({ name, comment }) => [name, comment]),\n      ),\n    }\n  }\n\n  public async getFeaturesHelper(\n    query: Region,\n    opts: BaseOptions = {},\n    observer: Observer<Feature>,\n    allowRedispatch: boolean,\n    originalQuery = query,\n  ) {\n    const { signal } = opts\n    const scoreColumn = this.getConf('scoreColumn')\n    const aggregateField = this.getConf('aggregateField')\n    const { parser, bigbed } = await this.configure(opts)\n    const feats = await bigbed.getFeatures(\n      query.refName,\n      query.start,\n      query.end,\n      {\n        signal,\n        basesPerSpan: query.end - query.start,\n      },\n    )\n    if (allowRedispatch && feats.length) {\n      let minStart = Infinity\n      let maxEnd = -Infinity\n      for (const feat of feats) {\n        if (feat.start < minStart) {\n          minStart = feat.start\n        }\n        if (feat.end > maxEnd) {\n          maxEnd = feat.end\n        }\n      }\n      if (maxEnd > query.end || minStart < query.start) {\n        await this.getFeaturesHelper(\n          { ...query, start: minStart, end: maxEnd },\n          opts,\n          observer,\n          false,\n          query,\n        )\n        return\n      }\n    }\n\n    const parentAggregation = {} as Record<\n      string,\n      SimpleFeatureSerializedNoId[]\n    >\n\n    if (feats.some(f => f.uniqueId === undefined)) {\n      throw new Error('found uniqueId undefined')\n    }\n    for (const feat of feats) {\n      const data = parser.parseLine(\n        `${query.refName}\\t${feat.start}\\t${feat.end}\\t${feat.rest}`,\n        { uniqueId: feat.uniqueId! },\n      )\n\n      const aggr = data[aggregateField]\n      if (!parentAggregation[aggr]) {\n        parentAggregation[aggr] = []\n      }\n      const {\n        uniqueId,\n        type,\n        chromStart,\n        chromStarts,\n        blockStarts,\n        blockCount,\n        blockSizes,\n        chromEnd,\n        thickStart,\n        thickEnd,\n        chrom,\n        score,\n        ...rest\n      } = data\n\n      const subfeatures = blockCount\n        ? makeBlocks({\n            chromStarts,\n            blockStarts,\n            blockCount,\n            blockSizes,\n            uniqueId,\n            refName: query.refName,\n            start: feat.start,\n          })\n        : []\n\n      if (isUcscProcessedTranscript(data)) {\n        const f = ucscProcessedTranscript({\n          ...rest,\n          uniqueId,\n          type,\n          start: feat.start,\n          end: feat.end,\n          refName: query.refName,\n          score: scoreColumn ? +data[scoreColumn] : score,\n          chromStarts,\n          blockCount,\n          blockSizes,\n          thickStart,\n          thickEnd,\n          subfeatures,\n        })\n        if (aggr) {\n          parentAggregation[aggr].push(f)\n        } else {\n          if (\n            doesIntersect2(\n              f.start,\n              f.end,\n              originalQuery.start,\n              originalQuery.end,\n            )\n          ) {\n            observer.next(\n              new SimpleFeature({ id: `${this.id}-${uniqueId}`, data: f }),\n            )\n          }\n        }\n      } else {\n        if (\n          doesIntersect2(\n            feat.start,\n            feat.end,\n            originalQuery.start,\n            originalQuery.end,\n          )\n        ) {\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${uniqueId}`,\n              data: {\n                ...rest,\n                uniqueId,\n                type,\n                start: feat.start,\n                score: scoreColumn ? +data[scoreColumn] : score,\n                end: feat.end,\n                refName: query.refName,\n                subfeatures,\n              },\n            }),\n          )\n        }\n      }\n    }\n\n    Object.entries(parentAggregation).map(([name, subfeatures]) => {\n      const s = min(subfeatures.map(f => f.start))\n      const e = max(subfeatures.map(f => f.end))\n      if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n        const { uniqueId, strand } = subfeatures[0]\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${uniqueId}-parent`,\n            data: {\n              type: 'gene',\n              subfeatures,\n              strand,\n              name,\n              start: s,\n              end: e,\n              refName: query.refName,\n            },\n          }),\n        )\n      }\n    })\n    observer.complete()\n  }\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        await this.getFeaturesHelper(query, opts, observer, true)\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeature } from '@jbrowse/core/util'\n\nexport interface MinimalFeature {\n  type: string\n  start: number\n  end: number\n  refName: string\n  [key: string]: unknown\n}\nexport interface TranscriptFeat extends MinimalFeature {\n  thickStart: number\n  thickEnd: number\n  blockCount: number\n  blockSizes: number[]\n  chromStarts: number[]\n  refName: string\n  strand?: number\n  subfeatures: MinimalFeature[]\n}\n\nexport function ucscProcessedTranscript(feature: TranscriptFeat) {\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    blockSizes,\n    chromStarts,\n    refName,\n    strand = 0,\n    ...rest\n  } = feature\n\n  if (!thickStart || !thickEnd || !strand) {\n    return feature\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n    ?.forEach(block => {\n      const start = block.start\n      const end = block.end\n      if (thickStart >= end) {\n        // left-side UTR\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n        // UTR | CDS\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push(\n          {\n            type: `${prime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd >= end) {\n        // CDS\n        subfeatures.push({\n          type: 'CDS',\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd < end) {\n        // UTR | CDS | UTR\n        const leftPrime = strand > 0 ? 'five' : 'three'\n        const rightPrime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `${leftPrime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: `CDS`,\n            start: thickStart,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${rightPrime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n        // CDS | UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `CDS`,\n            start,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${prime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickEnd <= start) {\n        // right-side UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      }\n    })\n\n  return { ...rest, strand, type: 'mRNA', refName, subfeatures }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = Object.fromEntries(line.split('\\t').map((f, i) => [fields[i], f]))\n\n  return {\n    ...rest,\n    blockStarts: blockStarts?.split(',').map(r => +r),\n    chromStarts: chromStarts?.split(',').map(r => +r),\n    blockSizes: blockSizes?.split(',').map(r => +r),\n    thickStart: +thickStart,\n    thickEnd: +thickEnd,\n    blockCount: +blockCount,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts: number[]\n  blockSizes: number[]\n  blockStarts: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bmax = bmin + (blockSizes?.[b] || 0)\n    subfeatures.push({\n      uniqueId: `${uniqueId}-${b}`,\n      start: bmin,\n      end: bmax,\n      refName,\n      type: 'block',\n    })\n  }\n  return subfeatures\n}\nexport function featureData(\n  line: string,\n  colRef: number,\n  colStart: number,\n  colEnd: number,\n  scoreColumn: string,\n  parser: BED,\n  uniqueId: string,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const refName = l[colRef]\n  const start = +l[colStart]\n  const colSame = colStart === colEnd ? 1 : 0\n  const end = +l[colEnd] + colSame\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n\n  const {\n    blockCount,\n    blockSizes,\n    blockStarts,\n    chromStarts,\n    thickStart,\n    thickEnd,\n    type,\n    score,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n  const subfeatures = blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts,\n        blockCount,\n        blockSizes,\n        blockStarts,\n      })\n    : []\n  const f = {\n    ...rest,\n    type,\n    score: scoreColumn ? +data[scoreColumn] : score,\n    start,\n    end,\n    refName,\n    uniqueId,\n    subfeatures,\n  }\n  return new SimpleFeature({\n    id: uniqueId,\n    data: isUcscProcessedTranscript(data)\n      ? ucscProcessedTranscript({\n          thickStart,\n          thickEnd,\n          blockCount,\n          blockSizes,\n          chromStarts,\n          ...f,\n        })\n      : f,\n  })\n}\n\nexport function isUcscProcessedTranscript(f: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return f.thickStart && f.blockCount && f.strand !== 0\n}\n"],"names":["BigBedAdapter","BaseFeatureDataAdapter","configurePre","opts","pm","this","pluginManager","bigbed","BigBed","filehandle","openLocation","getConf","header","getHeader","parser","BED","autoSql","configure","cached","catch","e","undefined","getRefNames","Object","keys","refsByName","version","fileType","fields","rest","fromEntries","map","name","comment","getFeaturesHelper","query","observer","allowRedispatch","originalQuery","signal","scoreColumn","aggregateField","feats","getFeatures","refName","start","end","basesPerSpan","length","minStart","Infinity","maxEnd","feat","parentAggregation","some","f","uniqueId","Error","data","parseLine","aggr","type","chromStart","chromStarts","blockStarts","blockCount","blockSizes","chromEnd","thickStart","thickEnd","chrom","score","subfeatures","makeBlocks","isUcscProcessedTranscript","ucscProcessedTranscript","push","doesIntersect2","next","SimpleFeature","id","entries","s","min","max","strand","complete","ObservableCreate","async","error","freeResources","feature","oldSubfeatures","filter","child","sort","a","b","forEach","block","prime","leftPrime","rightPrime","starts","bmin","bmax","featureData","line","colRef","colStart","colEnd","names","l","split","colSame","i","r","defaultParser","_1","_2","_3"],"sourceRoot":""}