{"version":3,"file":"static/js/6849.43f88cba.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\n\nimport CramAdapter from './CramAdapter'\n\nexport interface Mismatch {\n  qual?: number\n  start: number\n  length: number\n  type: string\n  base: string\n  altbase?: string\n  seq?: string\n  cliplen?: number\n}\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(private record: any, private _store: CramAdapter) {}\n\n  _get_name() {\n    return this.record.readName\n  }\n\n  _get_start() {\n    return this.record.alignmentStart - 1\n  }\n\n  _get_end() {\n    return this.record.alignmentStart + this.record.lengthOnRef - 1\n  }\n\n  _get_cram_read_features() {\n    return this.record.readFeatures\n  }\n\n  _get_type() {\n    return 'match'\n  }\n\n  _get_score() {\n    return this.record.mappingQuality\n  }\n\n  _get_flags() {\n    return this.record.flags\n  }\n\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _read_group_id() {\n    const rg = this._store.samHeader.readGroups\n    return rg ? rg[this.record.readGroupId] : undefined\n  }\n\n  _get_qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  qualRaw() {\n    return this.record.qualityScores\n  }\n\n  _get_seq_id() {\n    return this._store.refIdToName(this.record.sequenceId)\n  }\n\n  _get_refName() {\n    return this._get_seq_id()\n  }\n\n  _get_is_paired() {\n    return !!this.record.mate\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  _get_next_seq_id() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.mate ? this.record.mate.alignmentStart : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  _get_tags() {\n    const RG = this._read_group_id()\n    const { tags } = this.record\n    // avoids a tag copy if no RG, but just copy if there is one\n    return RG !== undefined ? { ...tags, RG } : tags\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  _get_CIGAR() {\n    let seq = ''\n    let cigar = ''\n    let op = 'M'\n    let oplen = 0\n\n    // not sure I should access these, but...\n    const ref = this.record._refRegion.seq\n    const refStart = this.record._refRegion.start\n    let last_pos = this.record.alignmentStart\n    let sublen = 0\n    if (typeof this.record.readFeatures !== 'undefined') {\n      // @ts-ignore\n      for (let i = 0; i < this.record.readFeatures.length; i++) {\n        const { code, refPos, sub, data } = this.record.readFeatures[i]\n        sublen = refPos - last_pos\n        seq += ref.substring(last_pos - refStart, refPos - refStart)\n        last_pos = refPos\n\n        if (oplen && op !== 'M') {\n          cigar += oplen + op\n          oplen = 0\n        }\n        if (sublen) {\n          op = 'M'\n          oplen += sublen\n        }\n\n        if (code === 'b') {\n          // An array of bases stored verbatim\n          const ret = data.split(',')\n          const added = String.fromCharCode(...ret)\n          seq += added\n          last_pos += added.length\n          oplen += added.length\n        } else if (code === 'B') {\n          // Single base (+ qual score)\n          seq += sub\n          last_pos++\n          oplen++\n        } else if (code === 'X') {\n          // Substitution\n          seq += sub\n          last_pos++\n          oplen++\n        } else if (code === 'D' || code === 'N') {\n          // Deletion or Ref Skip\n          last_pos += data\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += data + code\n          oplen = 0\n        } else if (code === 'I' || code === 'S') {\n          // Insertion or soft-clip\n          seq += data\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += data.length + code\n          oplen = 0\n        } else if (code === 'i') {\n          // Single base insertion\n          seq += data\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += `${1}I`\n          oplen = 0\n        } else if (code === 'P') {\n          // Padding\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += `${data}P`\n        } else if (code === 'H') {\n          // Hard clip\n          if (oplen) {\n            cigar += oplen + op\n          }\n          cigar += `${data}H`\n          oplen = 0\n        } // else q or Q\n      }\n    } else {\n      sublen = this.record.readLength - seq.length\n    }\n    if (seq.length !== this.record.readLength) {\n      sublen = this.record.readLength - seq.length\n      seq += ref.substring(last_pos - refStart, last_pos - refStart + sublen)\n\n      if (oplen && op !== 'M') {\n        cigar += oplen + op\n        oplen = 0\n      }\n      op = 'M'\n      oplen += sublen\n    }\n    if (oplen) {\n      cigar += oplen + op\n    }\n    return cigar\n  }\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      CramSlightlyLazyFeature.prototype,\n    )\n    return properties\n      .filter(\n        prop =>\n          prop.startsWith('_get_') &&\n          prop !== '_get_mismatches' &&\n          prop !== '_get_cram_read_features',\n      )\n      .map(methodName => methodName.replace('_get_', ''))\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string) {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) {\n      // @ts-ignore\n      return this[methodName]()\n    }\n    return undefined\n  }\n\n  parent(): undefined | Feature {\n    return undefined\n  }\n\n  children(): undefined | Feature[] {\n    return undefined\n  }\n\n  set(): void {}\n\n  pairedFeature() {\n    return false\n  }\n\n  _get_clipPos() {\n    const mismatches = this.get('mismatches')\n    if (mismatches.length) {\n      const record =\n        this.get('strand') === -1\n          ? mismatches[mismatches.length - 1]\n          : mismatches[0]\n      const { type, cliplen } = record\n      if (type === 'softclip' || type === 'hardclip') {\n        return cliplen\n      }\n    }\n    return 0\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const tags: Record<string, any> = {}\n    this.tags().forEach((t: string) => {\n      const val = this.get(t)\n      if (val !== undefined) {\n        tags[t] = val\n      }\n    })\n\n    return {\n      ...tags,\n      name: this.get('name'),\n      type: this.get('type'),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches(): Mismatch[] {\n    const readFeatures = this.get('cram_read_features')\n    const qual = this.qualRaw()\n    if (!readFeatures) {\n      return []\n    }\n    const start = this.get('start')\n    const mismatches: Mismatch[] = new Array(readFeatures.length)\n    let j = 0\n    for (let i = 0; i < readFeatures.length; i++) {\n      const f = readFeatures[i]\n      const { code, pos, data, sub, ref } = f\n      const refPos = f.refPos - 1 - start\n      if (code === 'X') {\n        // substitution\n        mismatches[j++] = {\n          start: refPos,\n          length: 1,\n          base: sub,\n          qual: qual?.[pos],\n          altbase: ref,\n          type: 'mismatch',\n        }\n      } else if (code === 'I') {\n        // insertion\n        mismatches[j++] = {\n          start: refPos,\n          type: 'insertion',\n          base: `${data.length}`,\n          length: 0,\n        }\n      } else if (code === 'N') {\n        // reference skip\n        mismatches[j++] = {\n          type: 'skip',\n          length: data,\n          start: refPos,\n          base: 'N',\n        }\n      } else if (code === 'S') {\n        // soft clip\n        const len = data.length\n        mismatches[j++] = {\n          start: refPos,\n          type: 'softclip',\n          base: `S${len}`,\n          cliplen: len,\n          length: 1,\n        }\n      } else if (code === 'P') {\n        // padding\n      } else if (code === 'H') {\n        // hard clip\n        const len = data\n        mismatches[j++] = {\n          start: refPos,\n          type: 'hardclip',\n          base: `H${len}`,\n          cliplen: len,\n          length: 1,\n        }\n      } else if (code === 'D') {\n        // deletion\n        mismatches[j++] = {\n          type: 'deletion',\n          length: data,\n          start: refPos,\n          base: '*',\n        }\n      } else if (code === 'b') {\n        // stretch of bases\n      } else if (code === 'q') {\n        // stretch of qual scores\n      } else if (code === 'B') {\n        // a pair of [base, qual]\n      } else if (code === 'i') {\n        // single-base insertion\n        // insertion\n        mismatches[j++] = {\n          start: refPos,\n          type: 'insertion',\n          base: data,\n          length: 1,\n        }\n      } else if (code === 'Q') {\n        // single quality value\n      }\n    }\n    return mismatches.slice(0, j)\n  }\n}\n","import { CraiIndex, IndexedCramFile } from '@gmod/cram'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { checkAbortSignal, Region, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\n\ninterface HeaderLine {\n  tag: string\n  value: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  data: HeaderLine[]\n}\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: number[]\n}\n\ninterface FilterBy {\n  flagInclude: number\n  flagExclude: number\n  tagFilter: { tag: string; value: unknown }\n  readName: string\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  samHeader: Header = {}\n\n  private setupP?: Promise<{\n    samHeader: Header\n    cram: any // eslint-disable-line @typescript-eslint/no-explicit-any\n    sequenceAdapter: any // eslint-disable-line @typescript-eslint/no-explicit-any\n  }>\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configure() {\n    const cramLocation = this.getConf('cramLocation')\n    const craiLocation = this.getConf('craiLocation')\n    if (!cramLocation) {\n      throw new Error('missing cramLocation argument')\n    }\n    if (!craiLocation) {\n      throw new Error('missing craiLocation argument')\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const cram: any = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation, this.pluginManager),\n      index: new CraiIndex({\n        filehandle: openLocation(craiLocation, this.pluginManager),\n      }),\n      seqFetch: this.seqFetch.bind(this),\n      checkSequenceMD5: false,\n      fetchSizeLimit: 200_000_000, // just make this a large size to avoid hitting it\n    })\n    // instantiate the sequence adapter\n    const sequenceAdapterType = this.getConf(['sequenceAdapter', 'type'])\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const seqConf = this.getConf('sequenceAdapter')\n    const { dataAdapter: sequenceAdapter } = await this.getSubAdapter(seqConf)\n\n    if (!(sequenceAdapter instanceof BaseFeatureDataAdapter)) {\n      throw new Error(\n        `CRAM feature adapters cannot use sequence adapters of type '${sequenceAdapterType}'`,\n      )\n    }\n\n    return { cram, sequenceAdapter }\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    return cram.cram.getHeaderText(opts)\n  }\n\n  private async seqFetch(seqId: number, start: number, end: number) {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const { sequenceAdapter } = await this.configure()\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) {\n      return undefined\n    }\n\n    const seqChunks = await sequenceAdapter\n      .getFeatures({\n        refName,\n        start,\n        end,\n        assemblyName: '',\n      })\n      .pipe(toArray())\n      .toPromise()\n\n    const sequence = seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .map(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        return chunkSeq.substr(trimStart, trimLength)\n      })\n      .join('')\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const configured = await this.configure()\n    statusCallback('Downloading index')\n    const { cram } = configured\n    const samHeader: HeaderLine[] = await cram.cram.getSamHeader(opts?.signal)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    samHeader\n      .filter(l => l.tag === 'SQ')\n      .forEach((sqLine, refId) => {\n        sqLine.data.forEach(item => {\n          if (item.tag === 'SN') {\n            // this is the ref name\n            const refName = item.value\n            nameToId[refName] = refId\n            idToName[refId] = refName\n          }\n        })\n      })\n\n    const readGroups = samHeader\n      .filter(l => l.tag === 'RG')\n      .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n    const data = { idToName, nameToId, readGroups }\n    statusCallback('')\n    this.samHeader = data\n    return { samHeader: data, ...configured }\n  }\n\n  private async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    if (!samHeader.idToName) {\n      throw new Error('CRAM file has no header lines')\n    }\n    return samHeader.idToName\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    if (this.samHeader.idToName) {\n      return this.samHeader.idToName[refId]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName[refId]\n    }\n    return undefined\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: FilterBy\n    },\n  ) {\n    const { signal, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram, sequenceAdapter } = await this.setup(opts)\n      statusCallback('Downloading alignments')\n      if (!this.seqIdToRefName) {\n        this.seqIdToRefName = await sequenceAdapter.getRefNames(opts)\n      }\n      const refId = this.refNameToId(refName)\n      if (refId !== undefined) {\n        if (originalRefName) {\n          this.seqIdToOriginalRefName[refId] = originalRefName\n        }\n        const records = await cram.getRecordsForRange(refId, start, end, opts)\n        checkAbortSignal(signal)\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let filtered = records.filter((record: any) => {\n          const flags = record.flags\n          return (flags & flagInclude) === flagInclude && !(flags & flagExclude)\n        })\n\n        if (tagFilter) {\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          filtered = filtered.filter((record: any) => {\n            const val = record[tagFilter.tag]\n            return val === '*' ? val !== undefined : val === tagFilter.value\n          })\n        }\n\n        if (readName) {\n          filtered = filtered.filter(\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (record: any) => record.readName === readName,\n          )\n        }\n\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        filtered.forEach((record: any) => {\n          observer.next(this.cramRecordToFeature(record))\n        })\n      } else {\n        console.warn('Unknown refName', refName)\n      }\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  cramRecordToFeature(record: unknown) {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n\n  // we return the configured fetchSizeLimit, and the bytes for the region\n  async estimateRegionsStats(regions: Region[], opts?: BaseOptions) {\n    const bytes = await this.bytesForRegions(regions, opts)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[], _opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return cram.index.getEntriesForRange(chrId, start, end)\n      }),\n    )\n\n    return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0)\n  }\n}\n"],"names":["CramSlightlyLazyFeature","record","_store","this","readName","alignmentStart","lengthOnRef","readFeatures","mappingQuality","flags","isReverseComplemented","rg","samHeader","readGroups","readGroupId","undefined","qualityScores","join","refIdToName","sequenceId","_get_seq_id","mate","isPaired","getPairOrientation","templateLength","templateSize","RG","_read_group_id","tags","getReadBases","seq","cigar","op","oplen","ref","_refRegion","refStart","start","last_pos","sublen","i","length","code","refPos","sub","data","substring","ret","split","added","String","fromCharCode","readLength","Object","getOwnPropertyNames","prototype","filter","prop","startsWith","map","methodName","replace","id","uniqueId","field","mismatches","get","type","cliplen","forEach","t","val","name","qual","qualRaw","Array","j","f","pos","base","altbase","len","slice","CramAdapter","setupP","seqIdToRefName","seqIdToOriginalRefName","cramLocation","getConf","craiLocation","Error","cram","IndexedCramFile","cramFilehandle","openLocation","pluginManager","index","CraiIndex","filehandle","seqFetch","bind","checkSequenceMD5","fetchSizeLimit","sequenceAdapterType","getSubAdapter","seqConf","sequenceAdapter","dataAdapter","BaseFeatureDataAdapter","opts","configure","getHeaderText","seqId","end","refName","refIdToOriginalName","getFeatures","assemblyName","pipe","toArray","toPromise","seqChunks","sequence","sort","a","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","substr","toLocaleString","statusCallback","configured","getSamHeader","signal","idToName","nameToId","l","tag","sqLine","refId","item","value","rgLine","find","setupPre","catch","e","setup","indexOf","region","filterBy","originalRefName","ObservableCreate","observer","getRefNames","refNameToId","getRecordsForRange","records","checkAbortSignal","flagInclude","flagExclude","tagFilter","filtered","next","cramRecordToFeature","console","warn","complete","regions","bytesForRegions","bytes","_opts","Promise","all","chrId","getEntriesForRange","blockResults","flat","reduce","sliceBytes"],"sourceRoot":""}