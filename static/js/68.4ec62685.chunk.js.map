{"version":3,"sources":["../../../plugins/gtf/src/util.ts","../../../plugins/gtf/src/GtfAdapter/GtfAdapter.ts"],"names":["featureData","data","f","start","strand","undefined","phase","Number","frame","refName","seq_name","score","defaultFields","Object","keys","attributes","forEach","a","b","toLowerCase","includes","attr","Array","isArray","length","formattedAttr","replace","type","featureType","child_features","subfeatures","map","childLocs","childLoc","flat","derived_features","_linehash","transcript_id","name","isGzip","buf","gtfFeatures","openLocation","readConfObject","this","config","pluginManager","readFile","buffer","unzip","Error","TextDecoder","fatal","decode","feats","gtf","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","intervalTree","i","SimpleFeature","id","reduce","acc","obj","key","get","IntervalTree","insert","loadDataP","catch","e","loadData","query","opts","ObservableCreate","observer","end","search","next","complete","error","signal","BaseFeatureDataAdapter"],"mappings":"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","file":"static/js/68.4ec62685.chunk.js","sourcesContent":["export type Strand = '+' | '-' | '.' | '?'\nexport interface FeatureLoc {\n  [key: string]: unknown\n  start: number\n  end: number\n  strand: Strand\n  seq_name: string\n  child_features: FeatureLoc[][]\n  data: unknown\n  derived_features: unknown\n  attributes: { [key: string]: unknown[] }\n}\n\nexport function featureData(data: FeatureLoc) {\n  const f: Record<string, unknown> = { ...data }\n  ;(f.start as number) -= 1 // convert to interbase\n  f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[data.strand] // convert strand\n  f.phase = Number(data.frame)\n  f.refName = data.seq_name\n  if (data.score === null) {\n    delete f.score\n  }\n  if (data.frame === null) {\n    delete f.score\n  }\n  const defaultFields = [\n    'start',\n    'end',\n    'seq_name',\n    'score',\n    'featureType',\n    'source',\n    'frame',\n    'strand',\n  ]\n  Object.keys(data.attributes).forEach(a => {\n    let b = a.toLowerCase()\n    if (defaultFields.includes(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (data.attributes[a] !== null) {\n      let attr = data.attributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        // gtf uses double quotes for text values in the attributes column, remove them\n        const formattedAttr = attr[0].replace(/^\"|\"$/g, '')\n        attr = formattedAttr\n      }\n      f[b] = attr\n    }\n  })\n  f.refName = f.seq_name\n  f.type = f.featureType\n\n  // the SimpleFeature constructor takes care of recursively inflating subfeatures\n  if (data.child_features && data.child_features.length) {\n    f.subfeatures = data.child_features\n      .map(childLocs => childLocs.map(childLoc => featureData(childLoc)))\n      .flat()\n  }\n\n  delete f.child_features\n  delete f.data\n  delete f.derived_features\n  // eslint-disable-next-line no-underscore-dangle\n  delete f._linehash\n  delete f.attributes\n  delete f.seq_name\n  delete f.featureType\n  delete f.frame\n\n  if (f.transcript_id) {\n    f.name = f.transcript_id\n  }\n  return f\n}\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nimport gtf from '@gmod/gtf'\nimport { FeatureLoc, featureData } from '../util'\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class extends BaseFeatureDataAdapter {\n  protected gtfFeatures?: Promise<{\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  private async loadDataP() {\n    const buffer = await openLocation(\n      readConfObject(this.config, 'gtfLocation'),\n      this.pluginManager,\n    ).readFile()\n\n    const buf = isGzip(buffer) ? await unzip(buffer) : buffer\n    // 512MB  max chrome string length is 512MB\n    if (buf.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buf)\n    const feats = gtf.parseStringSync(data, {\n      parseFeatures: true,\n      parseComments: false,\n      parseDirectives: false,\n      parseSequences: false,\n    }) as FeatureLoc[][]\n\n    const intervalTree = feats\n      .flat()\n      .map(\n        (f, i) =>\n          new SimpleFeature({\n            data: featureData(f),\n            id: `${this.id}-offset-${i}`,\n          }),\n      )\n      .reduce((acc, obj) => {\n        const key = obj.get('refName')\n        if (!acc[key]) {\n          acc[key] = new IntervalTree()\n        }\n        acc[key].insert([obj.get('start'), obj.get('end')], obj)\n        return acc\n      }, {} as Record<string, IntervalTree>)\n    return { intervalTree }\n  }\n\n  private async loadData() {\n    if (!this.gtfFeatures) {\n      this.gtfFeatures = this.loadDataP().catch(e => {\n        this.gtfFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gtfFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTree } = await this.loadData()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTree } = await this.loadData()\n        intervalTree[refName]\n          ?.search([start, end])\n          .forEach(f => observer.next(f))\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n  public freeResources(/* { region } */) {}\n}\n"],"sourceRoot":""}