{"version":3,"file":"static/js/6443.f599cae0.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/util.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\nimport { CramRecord } from '@gmod/cram'\nimport CramAdapter from './CramAdapter'\nimport { Mismatch, readFeaturesToCIGAR, readFeaturesToMismatches } from './util'\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(private record: CramRecord, private _store: CramAdapter) {}\n\n  _get_name() {\n    return this.record.readName\n  }\n\n  _get_start() {\n    return this.record.alignmentStart - 1\n  }\n\n  _get_end() {\n    return this.record.alignmentStart + (this.record.lengthOnRef ?? 1) - 1\n  }\n\n  _get_cram_read_features() {\n    return this.record.readFeatures\n  }\n\n  _get_type() {\n    return 'match'\n  }\n\n  _get_score() {\n    return this.record.mappingQuality\n  }\n\n  _get_flags() {\n    return this.record.flags\n  }\n\n  _get_strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _read_group_id() {\n    const rg = this._store.samHeader.readGroups\n    return rg ? rg[this.record.readGroupId] : undefined\n  }\n\n  _get_qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  qualRaw() {\n    return this.record.qualityScores\n  }\n\n  _get_seq_id() {\n    return this._store.refIdToName(this.record.sequenceId)\n  }\n\n  _get_refName() {\n    return this._get_seq_id()\n  }\n\n  _get_is_paired() {\n    return !!this.record.mate\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  _get_next_seq_id() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.mate ? this.record.mate.alignmentStart : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  _get_tags() {\n    const RG = this._read_group_id()\n    const { tags } = this.record\n    // avoids a tag copy if no RG, but just copy if there is one\n    return RG !== undefined ? { ...tags, RG } : tags\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  _get_CIGAR() {\n    return readFeaturesToCIGAR(\n      this.record.readFeatures,\n      this.record.alignmentStart,\n      this.record.readLength,\n      this.record._refRegion,\n    )\n  }\n\n  tags() {\n    return Object.getOwnPropertyNames(CramSlightlyLazyFeature.prototype)\n      .filter(\n        prop =>\n          prop.startsWith('_get_') &&\n          prop !== '_get_mismatches' &&\n          prop !== '_get_cram_read_features',\n      )\n      .map(methodName => methodName.replace('_get_', ''))\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string) {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) {\n      // @ts-ignore\n      return this[methodName]()\n    }\n    return undefined\n  }\n\n  parent(): undefined | Feature {\n    return undefined\n  }\n\n  children(): undefined | Feature[] {\n    return undefined\n  }\n\n  set(): void {}\n\n  pairedFeature() {\n    return false\n  }\n\n  _get_clipPos() {\n    const mismatches = this.get('mismatches')\n    if (mismatches.length) {\n      const record =\n        this.get('strand') === -1\n          ? mismatches[mismatches.length - 1]\n          : mismatches[0]\n      const { type, cliplen } = record\n      if (type === 'softclip' || type === 'hardclip') {\n        return cliplen\n      }\n    }\n    return 0\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...Object.fromEntries(\n        this.tags()\n          .map(t => [t, this.get(t)])\n          .filter(elt => elt[1] !== undefined),\n      ),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches(): Mismatch[] {\n    const readFeatures = this.record.readFeatures\n    const qual = this.qualRaw()\n    const start = this.get('start')\n    return readFeaturesToMismatches(readFeatures, start, qual)\n  }\n}\n","import { CramRecord } from '@gmod/cram'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\nexport interface Mismatch {\n  qual?: number\n  start: number\n  length: number\n  type: string\n  base: string | undefined\n  altbase?: string\n  seq?: string\n  cliplen?: number\n}\n\nexport function readFeaturesToMismatches(\n  readFeatures: ReadFeatures,\n  start: number,\n  qual?: number[] | null,\n) {\n  if (!readFeatures) {\n    return []\n  }\n  const mismatches: Mismatch[] = new Array(readFeatures.length)\n  let j = 0\n  let insLen = 0\n  let refPos = 0\n  let sublen = 0\n  let lastPos = start\n\n  for (let i = 0; i < readFeatures.length; i++) {\n    const f = readFeatures[i]\n    const { code, pos, data, sub, ref } = f\n    sublen = refPos - lastPos\n    lastPos = refPos\n\n    if (sublen && insLen > 0) {\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${insLen}`,\n        length: 0,\n      }\n      insLen = 0\n    }\n    refPos = f.refPos - 1 - start\n\n    if (code === 'X') {\n      // substitution\n      mismatches[j++] = {\n        start: refPos,\n        length: 1,\n        base: sub,\n        qual: qual?.[pos - 1],\n        altbase: ref?.toUpperCase(),\n        type: 'mismatch',\n      }\n    } else if (code === 'I') {\n      // insertion\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${data.length}`,\n        length: 0,\n      }\n    } else if (code === 'N') {\n      // reference skip\n      mismatches[j++] = {\n        type: 'skip',\n        length: data,\n        start: refPos,\n        base: 'N',\n      }\n    } else if (code === 'S') {\n      // soft clip\n      const len = data.length\n      mismatches[j++] = {\n        start: refPos,\n        type: 'softclip',\n        base: `S${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'P') {\n      // padding\n    } else if (code === 'H') {\n      // hard clip\n      const len = data\n      mismatches[j++] = {\n        start: refPos,\n        type: 'hardclip',\n        base: `H${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'D') {\n      // deletion\n      mismatches[j++] = {\n        type: 'deletion',\n        length: data,\n        start: refPos,\n        base: '*',\n      }\n    } else if (code === 'b') {\n      // stretch of bases\n    } else if (code === 'q') {\n      // stretch of qual scores\n    } else if (code === 'B') {\n      // a pair of [base, qual]\n    } else if (code === 'i') {\n      // single-base insertion, we collect these if there are multiple in a row\n      // into a single insertion entry\n      insLen++\n    } else if (code === 'Q') {\n      // single quality value\n    }\n  }\n\n  if (sublen && insLen > 0) {\n    mismatches[j++] = {\n      start: refPos,\n      type: 'insertion',\n      base: `${insLen}`,\n      length: 0,\n    }\n    insLen = 0\n  }\n\n  return mismatches.slice(0, j)\n}\n\nexport function readFeaturesToCIGAR(\n  readFeatures: ReadFeatures,\n  alignmentStart: number,\n  readLen: number,\n  refRegion?: { seq: string; start: number },\n) {\n  let seq = ''\n  let cigar = ''\n  let op = 'M'\n  let oplen = 0\n  if (!refRegion) {\n    return ''\n  }\n\n  // not sure I should access these, but...\n  const ref = refRegion.seq\n  const refStart = refRegion.start\n  let lastPos = alignmentStart\n  let sublen = 0\n  let insLen = 0\n  if (readFeatures !== undefined) {\n    for (let i = 0; i < readFeatures.length; i++) {\n      const { code, refPos, sub, data } = readFeatures[i]\n      sublen = refPos - lastPos\n      seq += ref.substring(lastPos - refStart, refPos - refStart)\n      lastPos = refPos\n\n      if (insLen > 0 && sublen) {\n        cigar += `${insLen}I`\n        insLen = 0\n      }\n      if (oplen && op !== 'M') {\n        cigar += oplen + op\n        oplen = 0\n      }\n      if (sublen) {\n        op = 'M'\n        oplen += sublen\n      }\n\n      if (code === 'b') {\n        // An array of bases stored verbatim\n        const ret = data.split(',')\n        const added = String.fromCharCode(...ret)\n        seq += added\n        lastPos += added.length\n        oplen += added.length\n      } else if (code === 'B') {\n        // Single base (+ qual score)\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'X') {\n        // Substitution\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'D' || code === 'N') {\n        // Deletion or Ref Skip\n        lastPos += data\n        if (oplen) {\n          cigar += oplen + op\n        }\n        cigar += data + code\n        oplen = 0\n      } else if (code === 'I' || code === 'S') {\n        // Insertion or soft-clip\n        seq += data\n        if (oplen) {\n          cigar += oplen + op\n        }\n        cigar += data.length + code\n        oplen = 0\n      } else if (code === 'i') {\n        // Single base insertion\n        // seq += data\n        if (oplen) {\n          cigar += oplen + op\n        }\n        insLen++\n        seq += data\n        oplen = 0\n      } else if (code === 'P') {\n        // Padding\n        if (oplen) {\n          cigar += oplen + op\n        }\n        cigar += `${data}P`\n      } else if (code === 'H') {\n        // Hard clip\n        if (oplen) {\n          cigar += oplen + op\n        }\n        cigar += `${data}H`\n        oplen = 0\n      } // else q or Q\n    }\n  } else {\n    sublen = readLen - seq.length\n  }\n  if (seq.length !== readLen) {\n    sublen = readLen - seq.length\n    seq += ref.substring(lastPos - refStart, lastPos - refStart + sublen)\n\n    if (oplen && op !== 'M') {\n      cigar += oplen + op\n      oplen = 0\n    }\n    op = 'M'\n    oplen += sublen\n  }\n  if (sublen && insLen > 0) {\n    cigar += `${insLen}I`\n  }\n  if (oplen) {\n    cigar += oplen + op\n  }\n\n  return cigar\n}\n","import { CraiIndex, IndexedCramFile, CramRecord } from '@gmod/cram'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { checkAbortSignal, Region, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\n\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: (string | undefined)[]\n}\n\ninterface FilterBy {\n  flagInclude: number\n  flagExclude: number\n  tagFilter: { tag: string; value: unknown }\n  readName: string\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  samHeader: Header = {}\n\n  private setupP?: Promise<{\n    samHeader: Header\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  private configureP?: Promise<{\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configurePre() {\n    const cramLocation = this.getConf('cramLocation')\n    const craiLocation = this.getConf('craiLocation')\n    if (!cramLocation) {\n      throw new Error('missing cramLocation argument')\n    }\n    if (!craiLocation) {\n      throw new Error('missing craiLocation argument')\n    }\n    const pm = this.pluginManager\n\n    const cram = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation, pm),\n      index: new CraiIndex({ filehandle: openLocation(craiLocation, pm) }),\n      seqFetch: (...args) => this.seqFetch(...args),\n      checkSequenceMD5: false,\n      fetchSizeLimit: 200_000_000, // just make this a large size to avoid hitting it\n    })\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const seqConf = this.getConf('sequenceAdapter')\n    const subadapter = await this.getSubAdapter(seqConf)\n\n    return {\n      cram,\n      sequenceAdapter: subadapter.dataAdapter as BaseSequenceAdapter,\n    }\n  }\n\n  public async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch(e => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    return cram.cram.getHeaderText()\n  }\n\n  private async seqFetch(\n    seqId: number,\n    start: number,\n    end: number,\n  ): Promise<string> {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const { sequenceAdapter } = await this.configure()\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) {\n      throw new Error('unknown')\n    }\n\n    const seqChunks = await sequenceAdapter\n      .getFeatures({\n        refName,\n        start,\n        end,\n        assemblyName: '',\n      })\n      .pipe(toArray())\n      .toPromise()\n\n    const sequence = seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .map(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        return chunkSeq.substr(trimStart, trimLength)\n      })\n      .join('')\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const conf = await this.configure()\n    statusCallback('Downloading index')\n    const { cram } = conf\n    const samHeader = await cram.cram.getSamHeader()\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    samHeader\n      .filter(l => l.tag === 'SQ')\n      .forEach((sqLine, refId) => {\n        sqLine.data.forEach(item => {\n          if (item.tag === 'SN') {\n            // this is the ref name\n            const refName = item.value\n            nameToId[refName] = refId\n            idToName[refId] = refName\n          }\n        })\n      })\n\n    const readGroups = samHeader\n      .filter(l => l.tag === 'RG')\n      .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n    const data = { idToName, nameToId, readGroups }\n    statusCallback('')\n    this.samHeader = data\n    return { samHeader: data, ...conf }\n  }\n\n  private async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    if (!samHeader.idToName) {\n      throw new Error('CRAM file has no header lines')\n    }\n    return samHeader.idToName\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    return this.samHeader.idToName?.[refId] || this.seqIdToRefName?.[refId]\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: FilterBy\n    },\n  ) {\n    const { signal, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram } = await this.setup(opts)\n\n      const refId = this.refNameToId(refName)\n      if (refId === undefined) {\n        console.warn('Unknown refName', refName)\n        observer.complete()\n        return\n      }\n\n      if (originalRefName) {\n        this.seqIdToOriginalRefName[refId] = originalRefName\n      }\n      statusCallback('Downloading alignments')\n      const records = await cram.getRecordsForRange(refId, start, end)\n      checkAbortSignal(signal)\n      const {\n        flagInclude = 0,\n        flagExclude = 0,\n        tagFilter,\n        readName,\n      } = filterBy || {}\n\n      let filtered = records.filter(record => {\n        const flags = record.flags\n        return (flags & flagInclude) === flagInclude && !(flags & flagExclude)\n      })\n\n      if (tagFilter) {\n        filtered = filtered.filter(record => {\n          // @ts-ignore\n          const val = record[tagFilter.tag]\n          return val === '*' ? val !== undefined : val === tagFilter.value\n        })\n      }\n\n      if (readName) {\n        filtered = filtered.filter(record => record.readName === readName)\n      }\n\n      filtered.forEach(record => {\n        observer.next(this.cramRecordToFeature(record))\n      })\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  cramRecordToFeature(record: CramRecord) {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n\n  // we return the configured fetchSizeLimit, and the bytes for the region\n  async estimateRegionsStats(regions: Region[], opts?: BaseOptions) {\n    const bytes = await this.bytesForRegions(regions, opts)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[], _opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return chrId !== undefined\n          ? cram.index.getEntriesForRange(chrId, start, end)\n          : [{ sliceBytes: 0 }]\n      }),\n    )\n\n    return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0)\n  }\n}\n"],"names":["CramSlightlyLazyFeature","record","_store","this","readName","alignmentStart","lengthOnRef","readFeatures","mappingQuality","flags","isReverseComplemented","rg","samHeader","readGroups","readGroupId","undefined","qualityScores","join","refIdToName","sequenceId","_get_seq_id","mate","isPaired","getPairOrientation","templateLength","templateSize","RG","_read_group_id","tags","getReadBases","readLen","refRegion","seq","cigar","op","oplen","ref","refStart","start","lastPos","sublen","insLen","i","length","code","refPos","sub","data","substring","ret","split","added","String","fromCharCode","readFeaturesToCIGAR","readLength","_refRegion","Object","getOwnPropertyNames","prototype","filter","prop","startsWith","map","methodName","replace","id","uniqueId","field","mismatches","get","type","cliplen","fromEntries","t","elt","qual","qualRaw","Array","j","f","pos","base","altbase","toUpperCase","len","slice","readFeaturesToMismatches","CramAdapter","setupP","configureP","seqIdToRefName","seqIdToOriginalRefName","cramLocation","getConf","craiLocation","Error","pm","pluginManager","cram","IndexedCramFile","cramFilehandle","openLocation","index","CraiIndex","filehandle","seqFetch","checkSequenceMD5","fetchSizeLimit","getSubAdapter","seqConf","subadapter","sequenceAdapter","dataAdapter","configurePre","catch","e","opts","configure","getHeaderText","seqId","end","refName","refIdToOriginalName","getFeatures","assemblyName","pipe","toArray","toPromise","seqChunks","sequence","sort","a","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","substr","toLocaleString","statusCallback","conf","getSamHeader","idToName","nameToId","l","tag","forEach","sqLine","refId","item","value","rgLine","find","setupPre","setup","indexOf","region","signal","filterBy","originalRefName","ObservableCreate","observer","refNameToId","console","warn","complete","getRecordsForRange","records","checkAbortSignal","flagInclude","flagExclude","tagFilter","filtered","val","next","cramRecordToFeature","regions","bytesForRegions","bytes","_opts","Promise","all","chrId","getEntriesForRange","sliceBytes","blockResults","flat","reduce","BaseFeatureDataAdapter"],"sourceRoot":""}