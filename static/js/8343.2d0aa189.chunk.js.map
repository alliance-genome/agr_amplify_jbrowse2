{"version":3,"file":"static/js/8343.2d0aa189.chunk.js","mappings":"sOAkCe,MAAMA,UAAmBC,EAAAA,uBACtC,oBAA6B,CAAC,cAAe,eAO7C,eAAaC,GACX,MAAM,OAAEC,SAAiBC,KAAKC,QAC9B,OAAOF,CACT,CAEA,iBAAMG,GACJ,MAAM,OAAEH,SAAiBC,KAAKC,QAE9B,OADe,IAAIE,EAAAA,EAAI,CAAEJ,OAAQA,IACnBG,aAChB,CAGA,YAAaE,GACX,MAAMC,EAAKL,KAAKM,cACVC,QAAYC,EAAAA,EAAAA,cAAaR,KAAKS,QAAQ,eAAgBJ,GAAIK,WAC1DC,EA3BV,SAAgBJ,GACd,OAAkB,KAAXA,EAAI,IAAwB,MAAXA,EAAI,IAAyB,IAAXA,EAAI,EAChD,CAyBmBK,CAAOL,SAAaM,EAAAA,EAAAA,OAAMN,GAAOA,EAGhD,GAAII,EAAOG,OAAS,UAClB,MAAM,IAAIC,MAAM,8CAGlB,MAAMC,GAAM,IAAIC,aAAcC,OAAOP,IAC/B,OAAEZ,EAAM,MAAEoB,GAnDHC,KACf,MAAMrB,EAAmB,GACnBsB,EAAiB,GAWvB,OAVAD,EAAEE,MAAM,cACLC,KAAIH,GAAKA,EAAEI,SACXC,QAAOL,KAAOA,IACdM,SAAQC,IACHA,EAAKC,WAAW,KAClB7B,EAAO8B,KAAKF,GACHA,GACTN,EAAKQ,KAAKF,EACZ,IAEG,CAAE5B,OAAQA,EAAO+B,KAAK,MAAOX,MAAOE,EAAM,EAsCrBU,CAAQf,GAC5BgB,EAAe,CAAC,EAEhBC,EAAS,IAAI9B,EAAAA,EAAI,CAAEJ,WACzB,IAAImC,EAAM,EACV,IAAK,MAAMP,KAAQR,EAAO,CACxB,MAAMC,EAAI,IAAIe,EAAAA,EAAW,CACvBC,QAASH,EAAOI,UAAUV,GAC1BM,SACAK,GAAI,GAAGtC,KAAKsC,MAAMJ,QAEdK,EAAMnB,EAAEoB,IAAI,WACbR,EAAaO,KAChBP,EAAaO,GAAO,IAAIE,EAAAA,IAE1BT,EAAaO,GAAKG,OAAO,CAACtB,EAAEoB,IAAI,SAAUpB,EAAEoB,IAAI,QAASpB,EAC3D,CAEA,MAAO,CAAErB,SAAQiC,eACnB,CAEA,WAAa/B,GAOX,OANKD,KAAK2C,cACR3C,KAAK2C,YAAc3C,KAAKI,SAASwC,OAAMC,IAErC,MADA7C,KAAK2C,iBAAcG,EACbD,CAAC,KAGJ7C,KAAK2C,WACd,CAEA,iBAAaI,CAAYC,EAAiB,CAAC,GACzC,MAAM,aAAEhB,SAAuBhC,KAAKC,QACpC,OAAOgD,OAAOC,KAAKlB,EACrB,CAEOmB,WAAAA,CAAYC,EAAgBC,EAAoB,CAAC,GACtD,OAAOC,EAAAA,EAAAA,mBAA0BC,UAC/B,IACE,MAAM,MAAEC,EAAK,IAAEC,EAAG,QAAEC,GAAYN,GAC1B,aAAEpB,SAAuBhC,KAAKC,QACpC+B,EAAa0B,IAAUC,OAAO,CAACH,EAAOC,IAAM/B,SAASN,IACnDwC,EAASC,KAAKzC,EAAE,IAElBwC,EAASE,UACX,CAAE,MAAOjB,GACPe,EAASG,MAAMlB,EACjB,IACCQ,EAAKW,OACV,CAEOC,aAAAA,GAAuB,E","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\n\n// local\nimport VcfFeature from '../VcfFeature'\n\nconst readVcf = (f: string) => {\n  const header: string[] = []\n  const rest: string[] = []\n  f.split(/\\n|\\r\\n|\\r/)\n    .map(f => f.trim())\n    .filter(f => !!f)\n    .forEach(line => {\n      if (line.startsWith('#')) {\n        header.push(line)\n      } else if (line) {\n        rest.push(line)\n      }\n    })\n  return { header: header.join('\\n'), lines: rest }\n}\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected vcfFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree<VcfFeature>>\n  }>\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header: header })\n    return parser.getMetadata()\n  }\n\n  // converts lines into an interval tree\n  public async setupP() {\n    const pm = this.pluginManager\n    const buf = await openLocation(this.getConf('vcfLocation'), pm).readFile()\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n\n    const str = new TextDecoder().decode(buffer)\n    const { header, lines } = readVcf(str)\n    const intervalTree = {} as Record<string, IntervalTree<VcfFeature>>\n\n    const parser = new VCF({ header })\n    let idx = 0\n    for (const line of lines) {\n      const f = new VcfFeature({\n        variant: parser.parseLine(line),\n        parser,\n        id: `${this.id}-${idx++}`,\n      })\n      const key = f.get('refName')\n      if (!intervalTree[key]) {\n        intervalTree[key] = new IntervalTree<VcfFeature>()\n      }\n      intervalTree[key].insert([f.get('start'), f.get('end')], f)\n    }\n\n    return { header, intervalTree }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch(e => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTree } = await this.setup()\n    return Object.keys(intervalTree)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { intervalTree } = await this.setup()\n        intervalTree[refName]?.search([start, end]).forEach((f: VcfFeature) => {\n          observer.next(f)\n        })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","getHeader","header","this","setup","getMetadata","VCF","setupP","pm","pluginManager","buf","openLocation","getConf","readFile","buffer","isGzip","unzip","length","Error","str","TextDecoder","decode","lines","f","rest","split","map","trim","filter","forEach","line","startsWith","push","join","readVcf","intervalTree","parser","idx","VcfFeature","variant","parseLine","id","key","get","IntervalTree","insert","vcfFeatures","catch","e","undefined","getRefNames","_","Object","keys","getFeatures","region","opts","ObservableCreate","async","start","end","refName","search","observer","next","complete","error","signal","freeResources"],"sourceRoot":""}