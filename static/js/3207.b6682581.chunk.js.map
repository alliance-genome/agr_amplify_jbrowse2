{"version":3,"file":"static/js/3207.b6682581.chunk.js","mappings":"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","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/BedImport.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"sourcesContent":["import { ParseOptions, parseTsvBuffer } from './ImportUtils'\n\nconst browserBytes = 'browser '.split('').map(c => c.charCodeAt(0))\nconst trackBytes = 'track '.split('').map(c => c.charCodeAt(0))\nconst commentBytes = '#'.split('').map(c => c.charCodeAt(0))\n\nfunction bytesAreFoundAt(position: number, buffer: Buffer, bytes: number[]) {\n  let i = 0\n  for (; i < bytes.length; i += 1) {\n    if (buffer[position + i] !== bytes[i]) {\n      return false\n    }\n  }\n  return true\n}\nexport function removeBedHeaders(buffer: Buffer) {\n  // slice off the first lines of the buffer if it starts with one or more\n  // header lines\n  let i = 0\n  for (; i < buffer.length; i += 1) {\n    if (\n      bytesAreFoundAt(i, buffer, browserBytes) ||\n      bytesAreFoundAt(i, buffer, trackBytes) ||\n      bytesAreFoundAt(i, buffer, commentBytes)\n    ) {\n      // consume up to the next newline\n      do {\n        i += 1\n      } while (buffer[i] !== 10)\n    } else {\n      // end of headers, return\n      break\n    }\n  }\n  if (i) {\n    return buffer.slice(i)\n  }\n  return buffer\n}\n\nexport async function parseBedBuffer(buffer: Buffer, options: ParseOptions) {\n  const b = removeBedHeaders(buffer)\n  const data = await parseTsvBuffer(b)\n  const bedColumns = [\n    { name: 'chrom', dataType: { type: 'LocRef' } },\n    { name: 'chromStart', dataType: { type: 'LocStart' } },\n    { name: 'chromEnd', dataType: { type: 'LocEnd' } },\n    { name: 'name', dataType: { type: 'Text' } },\n    { name: 'score', dataType: { type: 'Number' } },\n    { name: 'strand', dataType: { type: 'Text' } },\n  ]\n  data.columns.forEach((col, colNumber) => {\n    const bedColumn = bedColumns[colNumber]\n    if (bedColumn) {\n      col.name = bedColumn.name\n      col.dataType = bedColumn.dataType\n    }\n  })\n  data.hasColumnNames = true\n  data.assemblyName = options.selectedAssemblyName\n\n  data.columnDisplayOrder.push(data.columnDisplayOrder.length)\n  data.columns.unshift({\n    name: 'Location',\n    dataType: { type: 'LocString' },\n    isDerived: true,\n    derivationFunctionText: `jexl:{text:row.cells[0].text+':'+row.cells[1].text+'..'+row.cells[2].text,\\n\n    extendedData: {refName: row.cells.ref.text, start: parseInt(row.cells.start.text,10), end: parseInt(row.cells.end.text,10)}}`,\n  })\n  return data\n}\n\nexport async function parseBedPEBuffer(buffer: Buffer, options: ParseOptions) {\n  const b = removeBedHeaders(buffer)\n  const data = await parseTsvBuffer(b)\n  interface BedColumn {\n    name: string\n    dataType: {\n      type: string\n    }\n    featureField: string[]\n  }\n  const bedColumns: BedColumn[] = [\n    { name: 'chrom1', dataType: { type: 'Text' }, featureField: ['refName'] },\n    { name: 'start1', dataType: { type: 'Number' }, featureField: ['start'] },\n    { name: 'end1', dataType: { type: 'Number' }, featureField: ['end'] },\n    {\n      name: 'chrom2',\n      dataType: { type: 'Text' },\n      featureField: ['mate', 'refName'],\n    },\n    {\n      name: 'start2',\n      dataType: { type: 'Number' },\n      featureField: ['mate', 'start'],\n    },\n    {\n      name: 'end2',\n      dataType: { type: 'Number' },\n      featureField: ['mate', 'end'],\n    },\n    { name: 'name', dataType: { type: 'Text' }, featureField: ['name'] },\n    { name: 'score', dataType: { type: 'Number' }, featureField: ['score'] },\n    { name: 'strand1', dataType: { type: 'Text' }, featureField: ['strand'] },\n    {\n      name: 'strand2',\n      dataType: { type: 'Text' },\n      featureField: ['mate', 'strand'],\n    },\n  ]\n  data.columns.forEach((col, colNumber) => {\n    const bedColumn = bedColumns[colNumber]\n    if (bedColumn) {\n      col.name = bedColumn.name\n      col.dataType = bedColumn.dataType\n    }\n  })\n  data.hasColumnNames = true\n\n  // decorate each row with a feature object in its extendedData\n  data.rowSet.rows.forEach((row, rowNumber) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const featureData: Record<string, any> = {}\n    row.cells.forEach(({ text }, columnNumber) => {\n      const bedColumn = bedColumns[columnNumber]\n      const val =\n        bedColumn && bedColumn.dataType.type === 'Number' && text\n          ? parseFloat(text)\n          : text\n      if (bedColumn) {\n        // a predefined column\n        if (bedColumn.featureField.length === 2) {\n          if (!featureData[bedColumn.featureField[0]]) {\n            featureData[bedColumn.featureField[0]] = {}\n          }\n          featureData[bedColumn.featureField[0]][bedColumn.featureField[1]] =\n            val\n        } else {\n          featureData[bedColumn.featureField[0]] = val\n        }\n      } else {\n        // some other column\n        featureData[`column${columnNumber + 1}`] = val\n      }\n    })\n    featureData.uniqueId = `bedpe-${rowNumber}`\n    row.extendedData = {\n      feature: featureData,\n    }\n  })\n\n  data.assemblyName = options.selectedAssemblyName\n\n  return data\n}\n","import { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf-8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc && parsedLoc.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (options.hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (options.hasColumnNameLine && options.columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(\n      options.columnNameLineNumber - 1,\n      1,\n    )\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(\n      rowSet,\n      columnNumber,\n      options.isValidRefName,\n    )\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      rowSet.rows.forEach(row => {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, options.isValidRefName)\n      })\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!options.hasColumnNameLine,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"names":["browserBytes","split","map","c","charCodeAt","trackBytes","commentBytes","bytesAreFoundAt","position","buffer","bytes","i","length","removeBedHeaders","slice","parseBedBuffer","_x","_x2","_parseBedBuffer","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","b","data","bedColumns","wrap","_context","prev","next","parseTsvBuffer","sent","name","dataType","type","columns","forEach","col","colNumber","bedColumn","hasColumnNames","assemblyName","selectedAssemblyName","columnDisplayOrder","push","unshift","isDerived","derivationFunctionText","abrupt","stop","parseBedPEBuffer","_x3","_x4","_parseBedPEBuffer","_callee2","_context2","featureField","rowSet","rows","row","rowNumber","featureData","cells","_ref","columnNumber","text","val","parseFloat","concat","uniqueId","extendedData","feature","bufferToString","TextDecoder","fatal","decode","parseWith","_parseWith","csv","_args","undefined","then","module","default","_objectSpread","noheader","output","fromString","dataToSpreadsheetSnapshot","hasColumnNameLine","columnNameLineNumber","isValidRefName","maxCols","isLoaded","id","String","columnNames","_rowSet$rows$splice","splice","colNamesRow","_slicedToArray","cell","_loop","guessedType","parsedLoc","parseLocString","error","refName","start","test","guessColumnType","parseCsvBuffer","_parseCsvBuffer","_args2","_parseTsvBuffer","_callee3","_args3","_context3","delimiter"],"sourceRoot":""}