{"version":3,"sources":["../../../node_modules/@gmod/gtf/dist/index.js","../../../node_modules/@gmod/gtf/dist/api.js","../../../node_modules/@gmod/gtf/dist/parse.js","../../../node_modules/@gmod/gtf/dist/util.js","../../../node_modules/stream-browserify/index.js","../../../node_modules/readable-stream/writable-browser.js","../../../node_modules/readable-stream/duplex-browser.js","../../../node_modules/readable-stream/transform.js","../../../node_modules/readable-stream/passthrough.js"],"names":["_typeof","obj","Symbol","iterator","constructor","prototype","Object","defineProperty","exports","value","default","_api","require","util","nodeInterop","__esModule","cache","_getRequireWildcardCache","has","get","newObj","hasPropertyDescriptor","getOwnPropertyDescriptor","key","hasOwnProperty","call","desc","set","_interopRequireWildcard","WeakMap","cacheBabelInterop","cacheNodeInterop","_default","parseStream","parseFile","parseStringSync","formatSync","formatStream","formatFile","stream","filename","options","arguments","length","undefined","newOptions","assign","insertVersionDirective","Promise","resolve","reject","pipe","FormattingTransform","on","fs","createWriteStream","encoding","items","other","sequences","forEach","i","sequence","push","str","map","_util","formatItem","join","formatSequence","createReadStream","inputOptions","_processParseOptions","bind","parser","_parse","featureCallback","parseFeatures","directiveCallback","parseDirectives","commentCallback","parseComments","sequenceCallback","parseSequences","bufferSize","Infinity","errorCallback","err","split","addLine","finish","_classCallCheck","instance","Constructor","TypeError","_defineProperties","target","props","descriptor","enumerable","configurable","writable","_createClass","protoProps","staticProps","_inherits","subClass","superClass","create","_setPrototypeOf","o","p","setPrototypeOf","__proto__","_createSuper","Derived","hasNativeReflectConstruct","Reflect","construct","sham","Proxy","Boolean","valueOf","e","_isNativeReflectConstruct","result","Super","_getPrototypeOf","NewTarget","this","apply","_possibleConstructorReturn","self","_assertThisInitialized","ReferenceError","getPrototypeOf","Transform","Decoder","StringDecoder","_callback","callback","process","nextTick","additionalDefaults","out","parseAll","GTFTransform","_Transform","_super","_this","objectMode","decoder","textBuffer","emit","data","line","toString","buffer","_this2","pieces","pop","maxLineLength","Error","piece","_addLine","chunk","_nextText","write","end","_Transform2","_super2","_this3","linesSinceLastSyncMark","minLinesBetweenSyncMarks","minSyncLines","haveWeEmittedData","fastaMode","directive","Array","isArray","count","GTF","_toConsumableArray","arr","_arrayLikeToArray","_arrayWithoutHoles","iter","from","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","_slicedToArray","_arrayWithHoles","_i","_s","_e","_arr","_n","_d","next","done","_iterableToArrayLimit","_nonIterableRest","minLen","n","slice","name","test","len","arr2","containerAttributes","Parent","Derives_from","FASTAParser","seqCallback","currentSequence","defMatch","exec","_flush","id","description","trim","replace","Parser","args","nullFunc","endCallback","_underConstructionTopLevel","_underConstructionById","_completedReferences","_underConstructionOrphans","eof","lineNumber","fastaParser","_bufferLine","match","_match","hashsigns","contents","_emitAllUnderConstructionFeatures","parseDirective","_emitItem","comment","errLine","concat","additionalItemCount","_unbufferItem","item","attributes","ID","child_features","c","derived_features","d","shift","values","filter","entry","keys","JSON","stringify","featureLine","parseFeature","feature","featureNumber","isTranscript","featureType","ids","transcript_id","parents","derives","parent","parse","formatFeature","createTranscript","existing","_enforceBufferSizeLimit","_resolveReferencesTo","_resolveReferencesFrom","references","attrname","pname","toLowerCase","loc","_loc$pname","message","entries","_ref","_ref2","toId","parentFeature","childFeature","otherFeature","start","Math","min","max","slot1","slot2","subObj","returnVal","postSet","location","escape","escapeColumn","formatAttributes","formatComment","formatDirective","itemOrItems","formatSingleItem","parseAttributes","parsed","_contents$split2","seqId","contentStart","contentEnd","seq_id","_contents$split4","source","buildname","f","a","unescape","fieldNames","parseInt","score","parseFloat","strand","s","String","_","seq","fromCharCode","_escape","regex","ch","hex","charCodeAt","toUpperCase","attrString","attrs","attribute","_arec","attr","arec","attrOrder","tag","valstring","val","translateStrand","_formatSingleFeature","seenFeature","fields","formattedString","_formatFeature","strings","multiSlot","featureOrFeatures","module","Stream","EE","EventEmitter","inherits","Readable","Writable","Duplex","PassThrough","dest","ondata","pause","ondrain","readable","resume","_isStdio","onend","onclose","didOnEnd","destroy","onerror","er","cleanup","listenerCount","removeListener"],"mappings":"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","file":"static/js/18.0a214341.chunk.js","sourcesContent":["\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _api = require(\"./api\");\n\nvar util = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nvar _default = {\n  parseStream: _api.parseStream,\n  parseFile: _api.parseFile,\n  parseStringSync: _api.parseStringSync,\n  formatSync: _api.formatSync,\n  formatStream: _api.formatStream,\n  formatFile: _api.formatFile,\n  util: util\n};\nexports.default = _default;","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatFile = formatFile;\nexports.formatStream = formatStream;\nexports.formatSync = formatSync;\nexports.parseFile = parseFile;\nexports.parseStream = parseStream;\nexports.parseStringSync = parseStringSync;\n\nvar _parse = _interopRequireDefault(require(\"./parse\"));\n\nvar _util = require(\"./util\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar _require = require('stream'),\n    Transform = _require.Transform;\n\nvar Decoder = require('string_decoder').StringDecoder; // don't load fs native module if running in webpacked code\n// eslint-disable-next-line camelcase\n\n\nvar fs = typeof __webpack_require__ !== 'function' ? require('fs') : null; // call a callback on the next process tick if running in\n// an environment that supports it\n\nfunction _callback(callback) {\n  if (process && process.nextTick) process.nextTick(callback);else callback();\n} // shared arg processing for the parse routines\n\n\nfunction _processParseOptions(options) {\n  var additionalDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var out = Object.assign({\n    parseFeatures: true,\n    parseDirectives: false,\n    parseSequences: true,\n    parseComments: false\n  }, additionalDefaults, options);\n\n  if (options.parseAll) {\n    out.parseFeatures = true;\n    out.parseDirectives = true;\n    out.parseComments = true;\n    out.parseSequences = true;\n  }\n\n  return out;\n}\n\nvar GTFTransform = /*#__PURE__*/function (_Transform) {\n  _inherits(GTFTransform, _Transform);\n\n  var _super = _createSuper(GTFTransform);\n\n  function GTFTransform() {\n    var _this;\n\n    var inputOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, GTFTransform);\n\n    var options = _processParseOptions(inputOptions);\n\n    _this = _super.call(this, {\n      objectMode: true\n    });\n    _this.encoding = inputOptions.encoding || 'utf8';\n    _this.decoder = new Decoder();\n    _this.textBuffer = '';\n\n    var push = _this.push.bind(_assertThisInitialized(_this));\n\n    _this.parser = new _parse.default({\n      featureCallback: options.parseFeatures ? push : null,\n      directiveCallback: options.parseDirectives ? push : null,\n      commentCallback: options.parseComments ? push : null,\n      sequenceCallback: options.parseSequences ? push : null,\n      errorCallback: function errorCallback(err) {\n        return _this.emit('error', err);\n      },\n      bufferSize: options.bufferSize\n    });\n    return _this;\n  }\n\n  _createClass(GTFTransform, [{\n    key: \"_addLine\",\n    value: function _addLine(data) {\n      var line = data.toString('utf8');\n\n      if (line) {\n        this.parser.addLine(line);\n      }\n    }\n  }, {\n    key: \"_nextText\",\n    value: function _nextText(buffer) {\n      var _this2 = this;\n\n      var pieces = (this.textBuffer + buffer).split(/\\r?\\n/);\n      this.textBuffer = pieces.pop();\n\n      if (this.maxLineLength && this.textBuffer.length > this.maxLineLength) {\n        this.emit('error', new Error('maximum line size exceeded'));\n        return;\n      }\n\n      pieces.forEach(function (piece) {\n        return _this2._addLine(piece);\n      });\n    }\n  }, {\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      this._nextText(this.decoder.write(chunk));\n\n      _callback(callback);\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush(callback) {\n      if (this.decoder.end) this._nextText(this.decoder.end());\n      if (this.textBuffer != null) this._addLine(this.textBuffer);\n      this.parser.finish();\n\n      _callback(callback);\n    }\n  }]);\n\n  return GTFTransform;\n}(Transform);\n/**\n * Parse a stream of text data into a stream of feature,\n * directive, and comment objects.\n *\n * @param {Object} options optional options object\n * @param {string} options.encoding text encoding of the input GTF. default 'utf8'\n * @param {boolean} options.parseAll default false.  if true, will parse all items. overrides other flags\n * @param {boolean} options.parseFeatures default true\n * @param {boolean} options.parseDirectives default false\n * @param {boolean} options.parseComments default false\n * @param {boolean} options.parseSequences default true\n * @param {Number} options.bufferSize maximum number of GTF lines to buffer. defaults to 1000\n * @returns {ReadableStream} stream (in objectMode) of parsed items\n */\n\n\nfunction parseStream() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var newOptions = Object.assign({\n    bufferSize: 1000\n  }, options);\n  return new GTFTransform(newOptions);\n}\n/**\n * Read and parse a GTF file from the filesystem.\n *\n * @param {string} filename the filename of the file to parse\n * @param {Object} options optional options object\n * @param {string} options.encoding the file's string encoding, defaults to 'utf8'\n * @param {boolean} options.parseAll default false.  if true, will parse all items. overrides other flags\n * @param {boolean} options.parseFeatures default true\n * @param {boolean} options.parseDirectives default false\n * @param {boolean} options.parseComments default false\n * @param {boolean} options.parseSequences default true\n * @param {Number} options.bufferSize maximum number of GTF lines to buffer. defaults to 1000\n * @returns {ReadableStream} stream (in objectMode) of parsed items\n */\n\n\nfunction parseFile(filename, options) {\n  return fs.createReadStream(filename).pipe(parseStream(options));\n}\n/**\n * Synchronously parse a string containing GTF and return\n * an arrayref of the parsed items.\n *\n * @param {string} str\n * @param {Object} inputOptions optional options object\n * @param {boolean} inputOptions.parseAll default false.  if true, will parse all items. overrides other flags\n * @param {boolean} inputOptions.parseFeatures default true\n * @param {boolean} inputOptions.parseDirectives default false\n * @param {boolean} inputOptions.parseComments default false\n * @param {boolean} inputOptions.parseSequences default true\n * @returns {Array} array of parsed features, directives, and/or comments\n */\n\n\nfunction parseStringSync(str) {\n  var inputOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (!str) return [];\n\n  var options = _processParseOptions(inputOptions);\n\n  var items = [];\n  var push = items.push.bind(items);\n  var parser = new _parse.default({\n    featureCallback: options.parseFeatures ? push : null,\n    directiveCallback: options.parseDirectives ? push : null,\n    commentCallback: options.parseComments ? push : null,\n    sequenceCallback: options.parseSequences ? push : null,\n    bufferSize: Infinity,\n    errorCallback: function errorCallback(err) {\n      throw err;\n    }\n  });\n  str.split(/\\r?\\n/).forEach(parser.addLine.bind(parser));\n  parser.finish();\n  return items;\n}\n/**\n * Format an array of GTF items (features,directives,comments) into string of GTF.\n * Does not insert synchronization (###) marks.\n * Does not insert directive if it's not already there.\n *\n * @param {Array[Object]} items\n * @returns {String} the formatted GTF\n */\n\n\nfunction formatSync(items) {\n  // sort items into seq and other\n  var other = [];\n  var sequences = [];\n  items.forEach(function (i) {\n    if (i.sequence) {\n      sequences.push(i);\n    } else {\n      other.push(i);\n    }\n  });\n  var str = other.map(_util.formatItem).join('');\n\n  if (sequences.length) {\n    str += '##FASTA\\n';\n    str += sequences.map(_util.formatSequence).join('');\n  }\n\n  return str;\n}\n\nvar FormattingTransform = /*#__PURE__*/function (_Transform2) {\n  _inherits(FormattingTransform, _Transform2);\n\n  var _super2 = _createSuper(FormattingTransform);\n\n  function FormattingTransform() {\n    var _this3;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, FormattingTransform);\n\n    _this3 = _super2.call(this, Object.assign(options, {\n      objectMode: true\n    }));\n    _this3.linesSinceLastSyncMark = 0;\n    _this3.minLinesBetweenSyncMarks = options.minSyncLines || 100;\n    _this3.insertVersionDirective = options.insertVersionDirective || false;\n    _this3.haveWeEmittedData = false;\n    _this3.fastaMode = false;\n    return _this3;\n  }\n\n  _createClass(FormattingTransform, [{\n    key: \"_transform\",\n    value: function _transform(chunk, encoding, callback) {\n      // if we have not emitted anything yet, and this first\n      // chunk is not a gtf directive, emit one\n      var str;\n\n      if (!this.haveWeEmittedData && this.insertVersionDirective && (chunk[0] || chunk).directive !== 'gtf') {\n        this.push('##gtf\\n');\n      } // if it's a sequence chunk coming down, emit a FASTA directive and\n      // change to FASTA mode\n\n\n      if (chunk.sequence && !this.fastaMode) {\n        this.push('##FASTA\\n');\n        this.fastaMode = true;\n      }\n\n      if (Array.isArray(chunk)) {\n        str = chunk.map(_util.formatItem).join('');\n      } else {\n        str = (0, _util.formatItem)(chunk);\n      }\n\n      this.push(str);\n\n      if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {\n        this.push('###\\n');\n        this.linesSinceLastSyncMark = 0;\n      } else {\n        // count the number of newlines in this chunk\n        var count = 0;\n\n        for (var i = 0; i < str.length; i += 1) {\n          if (str[i] === '\\n') count += 1;\n        }\n\n        this.linesSinceLastSyncMark += count;\n      }\n\n      this.haveWeEmittedData = true;\n\n      _callback(callback);\n    }\n  }]);\n\n  return FormattingTransform;\n}(Transform);\n/**\n * Format a stream of items (of the type produced\n * by this script) into a stream of GTF text.\n *\n * Inserts synchronization (###) marks automatically.\n *\n * @param {Object} options\n * @param {Object} options.minSyncLines minimum number of lines between ### marks. default 100\n * @param {Boolean} options.insertVersionDirective\n *  if the first item in the stream is not a ##gff-version directive, insert one to show it's gtf\n *  default false\n */\n\n\nfunction formatStream(options) {\n  return new FormattingTransform(options);\n}\n/**\n * Format a stream of items (of the type produced\n * by this script) into a GTF file and write it to the filesystem.\n\n * Inserts synchronization (###) marks and a ##gtf\n * directive automatically (if one is not already present).\n *\n * @param {ReadableStream} stream the stream to write to the file\n * @param {String} filename the file path to write to\n * @param {Object} options\n * @param {String} options.encoding default 'utf8'. encoding for the written file\n * @param {Number} options.minSyncLines\n *  minimum number of lines between sync (###) marks. default 100\n * @param {Boolean} options.insertVersionDirective\n *  if the first item in the stream is not a ##gtf directive, insert one.\n *  default false\n * @returns {Promise} promise for the written filename\n */\n\n\nfunction formatFile(stream, filename) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var newOptions = Object.assign({\n    insertVersionDirective: false\n  }, options);\n  return new Promise(function (resolve, reject) {\n    stream.pipe(new FormattingTransform(newOptions)).on('end', function () {\n      return resolve(filename);\n    }).on('error', reject).pipe(fs.createWriteStream(filename, {\n      encoding: newOptions.encoding || 'utf8'\n    }));\n  });\n}","\"use strict\";\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar GTF = _interopRequireWildcard(require(\"./util\"));\n\nfunction _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== \"function\") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }\n\nfunction _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== \"default\" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar containerAttributes = {\n  Parent: 'child_features',\n  Derives_from: 'derived_features'\n}; // Note this is a reimplementation of https://github.com/GMOD/jbrowse/src/JBrowse/Store/SeqFeature/GTF/Parser.js\n\nvar FASTAParser = /*#__PURE__*/function () {\n  function FASTAParser(seqCallback) {\n    _classCallCheck(this, FASTAParser);\n\n    this.seqCallback = seqCallback;\n    this.currentSequence = undefined;\n  }\n\n  _createClass(FASTAParser, [{\n    key: \"addLine\",\n    value: function addLine(line) {\n      var defMatch = /^>\\s*(\\S+)\\s*(.*)/.exec(line);\n\n      if (defMatch) {\n        this._flush();\n\n        this.currentSequence = {\n          id: defMatch[1],\n          sequence: ''\n        };\n        if (defMatch[2]) this.currentSequence.description = defMatch[2].trim();\n      } else if (this.currentSequence && /\\S/.test(line)) {\n        this.currentSequence.sequence += line.replace(/\\s/g, '');\n      }\n    }\n  }, {\n    key: \"_flush\",\n    value: function _flush() {\n      if (this.currentSequence) this.seqCallback(this.currentSequence);\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this._flush();\n    }\n  }]);\n\n  return FASTAParser;\n}();\n\nvar Parser = /*#__PURE__*/function () {\n  function Parser(args) {\n    _classCallCheck(this, Parser);\n\n    var nullFunc = function nullFunc() {};\n\n    Object.assign(this, {\n      featureCallback: args.featureCallback || nullFunc,\n      endCallback: args.endCallback || nullFunc,\n      commentCallback: args.commentCallback || nullFunc,\n      errorCallback: args.errorCallback || nullFunc,\n      directiveCallback: args.directiveCallback || nullFunc,\n      sequenceCallback: args.sequenceCallback || nullFunc,\n      // number of lines to buffer\n      bufferSize: args.bufferSize === undefined ? 1000 : args.bufferSize,\n      // features that we have to keep on hand for now because they\n      // might be referenced by something else\n      _underConstructionTopLevel: [],\n      // index of the above by ID\n      _underConstructionById: {},\n      _completedReferences: {},\n      // features that reference something we have not seen yet\n      // structured as:\n      // {  'some_id' : {\n      //     'Parent' : [ orphans that have a Parent attr referencing it ],\n      //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n      //    }\n      // }\n      _underConstructionOrphans: {},\n      // if this is true, the parser ignores the\n      // rest of the lines in the file.  currently\n      // set when the file switches over to FASTA\n      eof: false,\n      lineNumber: 0\n    });\n  }\n\n  _createClass(Parser, [{\n    key: \"addLine\",\n    value: function addLine(line) {\n      // if we have transitioned to a fasta section, just delegate to that parser\n      if (this.fastaParser) {\n        this.fastaParser.addLine(line);\n        return;\n      }\n\n      if (this.eof) {\n        // otherwise, if we are done, ignore this line\n        return;\n      }\n\n      this.lineNumber += 1;\n\n      if (/^\\s*[^#\\s>]/.test(line)) {\n        // feature line, most common case\n        this._bufferLine(line);\n\n        return;\n      }\n\n      var match = /^\\s*(#+)(.*)/.exec(line);\n\n      if (match) {\n        // directive or comment\n        // eslint-disable-next-line prefer-const\n        var _match = _slicedToArray(match, 3),\n            hashsigns = _match[1],\n            contents = _match[2];\n\n        if (hashsigns.length === 3) {\n          // sync directive, all forward-references are resolved.\n          this._emitAllUnderConstructionFeatures();\n        } else if (hashsigns.length === 2) {\n          var directive = GTF.parseDirective(line);\n\n          if (directive.directive === 'FASTA') {\n            this._emitAllUnderConstructionFeatures();\n\n            this.eof = true;\n            this.fastaParser = new FASTAParser(this.sequenceCallback);\n          } else {\n            this._emitItem(directive);\n          }\n        } else {\n          contents = contents.replace(/\\s*/, '');\n\n          this._emitItem({\n            comment: contents\n          });\n        }\n      } else if (/^\\s*$/.test(line)) {// blank line, do nothing\n      } else if (/^\\s*>/.test(line)) {\n        // implicit beginning of a FASTA section\n        this._emitAllUnderConstructionFeatures();\n\n        this.eof = true;\n        this.fastaParser = new FASTAParser(this.sequenceCallback);\n        this.fastaParser.addLine(line);\n      } else {\n        // it's a parse error\n        var errLine = line.replace(/\\r?\\n?$/g, '');\n        throw new Error(\"GTF parse error.  Cannot parse '\".concat(errLine, \"'.\"));\n      }\n    }\n  }, {\n    key: \"_emitItem\",\n    value: function _emitItem(i) {\n      if (i[0]) {\n        this.featureCallback(i);\n      } else if (i.directive) {\n        this.directiveCallback(i);\n      } else if (i.comment) {\n        this.commentCallback(i);\n      }\n    }\n  }, {\n    key: \"finish\",\n    value: function finish() {\n      this._emitAllUnderConstructionFeatures();\n\n      if (this.fastaParser) {\n        this.fastaParser.finish();\n      }\n\n      this.endCallback();\n    }\n  }, {\n    key: \"_enforceBufferSizeLimit\",\n    value: function _enforceBufferSizeLimit() {\n      var _this = this;\n\n      var additionalItemCount = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _unbufferItem = function _unbufferItem(item) {\n        if (item && item[0] && item[0].attributes && item[0].attributes.ID && item[0].attributes.ID[0]) {\n          var ids = item[0].attributes.ID;\n          ids.forEach(function (id) {\n            delete _this._underConstructionById[id];\n            delete _this._completedReferences[id];\n          });\n          item.forEach(function (i) {\n            if (i.child_features) i.child_features.forEach(function (c) {\n              return _unbufferItem(c);\n            });\n            if (i.derived_features) i.derived_features.forEach(function (d) {\n              return _unbufferItem(d);\n            });\n          });\n        }\n      };\n\n      while (this._underConstructionTopLevel.length + additionalItemCount > this.bufferSize) {\n        var item = this._underConstructionTopLevel.shift();\n\n        this._emitItem(item);\n\n        _unbufferItem(item);\n      }\n    }\n    /**\n     * return all under-construction features, called when we know\n     * there will be no additional data to attach to them\n     * @private\n     */\n\n  }, {\n    key: \"_emitAllUnderConstructionFeatures\",\n    value: function _emitAllUnderConstructionFeatures() {\n      this._underConstructionTopLevel.forEach(this._emitItem.bind(this));\n\n      this._underConstructionTopLevel = [];\n      this._underConstructionById = {};\n      this._completedReferences = {}; // if we have any orphans hanging around still, this is a\n      // problem. die with a parse error\n\n      if (Object.values(this._underConstructionOrphans).filter(function (entry) {\n        return Object.keys(entry).length;\n      }).length) {\n        throw new Error(\"some features reference other features that do not exist in the file (or in the same '###' scope). \".concat(JSON.stringify(this._underConstructionOrphans)));\n      }\n    } // do the right thing with a newly-parsed feature line\n\n  }, {\n    key: \"_bufferLine\",\n    value: function _bufferLine(line) {\n      var _this2 = this;\n\n      var featureLine = GTF.parseFeature(line);\n      featureLine.child_features = [];\n      featureLine.derived_features = []; // featureLine._lineNumber = this.lineNumber //< debugging aid\n\n      var featureNumber = this.lineNumber; // no such thing as unique ID in GTF. make one up.\n\n      var isTranscript = featureLine.featureType === 'transcript'; // trying to support the Cufflinks convention of adding a transcript line\n      // NOTE: a feature is an arrayref of one or more feature lines.\n\n      var ids = isTranscript ? featureLine.attributes.transcript_id || [] : [featureNumber];\n      var parents = isTranscript ? [] : featureLine.attributes.transcript_id || [];\n      var derives = featureLine.attributes.Derives_from || [];\n\n      if (!ids.length && !parents.length && !derives.length) {\n        // if it has no IDs and does not refer to anything, we can just\n        // output it\n        this._emitItem([featureLine]);\n\n        return;\n      }\n\n      function createTranscript(feature) {\n        var result = JSON.parse(JSON.stringify(feature));\n        result.featureType = 'transcript'; // result.attributes={'transcript_id':result.attributes.transcript_id, 'gene_id':result.attributes.gene_id};\n\n        return GTF.formatFeature(result);\n      } // here we just create transcript features with children features and let 'gene_ids' simply be attributes not a feature in themselves\n\n\n      parents.forEach(function (parent) {\n        var underConst = _this2._underConstructionById[parent];\n\n        if (!underConst) {\n          _this2._bufferLine(createTranscript(featureLine));\n        }\n      });\n      var feature;\n      ids.forEach(function (id) {\n        var existing = _this2._underConstructionById[id];\n\n        if (existing) {\n          existing.push(featureLine);\n          feature = existing;\n        } else {\n          // haven't seen it yet, so buffer it so we can attach\n          // child features to it\n          feature = [featureLine];\n\n          _this2._enforceBufferSizeLimit(1);\n\n          if (!parents.length && !derives.length) {\n            _this2._underConstructionTopLevel.push(feature);\n          }\n\n          _this2._underConstructionById[id] = feature; // see if we have anything buffered that refers to it\n\n          _this2._resolveReferencesTo(feature, id);\n        }\n      }); // try to resolve all its references\n\n      this._resolveReferencesFrom(feature || [featureLine], {\n        Parent: parents,\n        Derives_from: derives\n      }, ids);\n    }\n  }, {\n    key: \"_resolveReferencesTo\",\n    value: function _resolveReferencesTo(feature, id) {\n      var references = this._underConstructionOrphans[id]; //   references is of the form\n      //   {\n      //     'Parent' : [ orphans that have a Parent attr referencing this feature ],\n      //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],\n      //    }\n\n      if (!references) return;\n      Object.keys(references).forEach(function (attrname) {\n        var pname = containerAttributes[attrname] || attrname.toLowerCase();\n        feature.forEach(function (loc) {\n          var _loc$pname;\n\n          (_loc$pname = loc[pname]).push.apply(_loc$pname, _toConsumableArray(references[attrname]));\n\n          delete references[attrname];\n        });\n      });\n    }\n  }, {\n    key: \"_parseError\",\n    value: function _parseError(message) {\n      this.eof = true;\n      this.errorCallback(\"\".concat(this.lineNumber, \": \").concat(message));\n    }\n  }, {\n    key: \"_resolveReferencesFrom\",\n    value: function _resolveReferencesFrom(feature, references, ids) {\n      var _this3 = this;\n\n      // this is all a bit more awkward in javascript than it was in perl\n      function postSet(obj, slot1, slot2) {\n        var subObj = obj[slot1];\n\n        if (!subObj) {\n          subObj = {}; // eslint-disable-next-line no-param-reassign\n\n          obj[slot1] = subObj;\n        }\n\n        var returnVal = subObj[slot2] || false;\n        subObj[slot2] = true;\n        return returnVal;\n      }\n\n      function expandFeature(parentFeature, childFeature) {\n        // eslint-disable-next-line no-param-reassign\n        parentFeature[0].start = Math.min(parentFeature[0].start, childFeature[0].start); // eslint-disable-next-line no-param-reassign\n\n        parentFeature[0].end = Math.max(parentFeature[0].end, childFeature[0].end);\n      }\n\n      Object.entries(references).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            attrname = _ref2[0],\n            toIds = _ref2[1];\n\n        var pname;\n        toIds.forEach(function (toId) {\n          var otherFeature = _this3._underConstructionById[toId];\n\n          if (otherFeature) {\n            expandFeature(otherFeature, feature);\n            if (!pname) pname = containerAttributes[attrname] || attrname.toLowerCase();\n\n            if (!ids.filter(function (id) {\n              return postSet(_this3._completedReferences, id, \"\".concat(attrname, \",\").concat(toId));\n            }).length) {\n              otherFeature.forEach(function (location) {\n                location[pname].push(feature);\n              });\n            }\n          } else {\n            if (!_this3._underConstructionOrphans[toId]) _this3._underConstructionOrphans[toId] = {};\n            if (!_this3._underConstructionOrphans[toId][attrname]) _this3._underConstructionOrphans[toId][attrname] = [];\n\n            _this3._underConstructionOrphans[toId][attrname].push(feature);\n          }\n        });\n      });\n    }\n  }]);\n\n  return Parser;\n}();\n\nexports.default = Parser;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.escape = escape;\nexports.escapeColumn = escapeColumn;\nexports.formatAttributes = formatAttributes;\nexports.formatComment = formatComment;\nexports.formatDirective = formatDirective;\nexports.formatFeature = formatFeature;\nexports.formatItem = formatItem;\nexports.formatSequence = formatSequence;\nexports.parseAttributes = parseAttributes;\nexports.parseDirective = parseDirective;\nexports.parseFeature = parseFeature;\nexports.unescape = unescape;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/** @module util */\n// Forks @gmod/gff-js and adapts it to parse and format GTF.\nvar fieldNames = ['seq_name', 'source', 'featureType', 'start', 'end', 'score', 'strand', 'frame', 'attributes']; // TODO: check about enconding/escaping in gtf 9th column\n\n/**\n * Unescape a string/text value used in a GTF attribute.\n * Textual attributes should be surrounded by double quotes\n * source info:\n * https://mblab.wustl.edu/GTF22.html\n * https://en.wikipedia.org/wiki/Gene_transfer_format\n *\n * @param {String} s\n * @returns {String}\n */\n\nfunction unescape(s) {\n  if (s === null) {\n    return null;\n  }\n\n  return String(s).replace(/%([0-9A-Fa-f]{2})/g, function (_, seq) {\n    return String.fromCharCode(parseInt(seq, 16));\n  });\n}\n/**\n * Escape a value for use in a GTF attribute value.\n *\n * @param {String} s\n * @returns {String}\n */\n\n\nfunction _escape(regex, s) {\n  return String(s).replace(regex, function (ch) {\n    var hex = ch.charCodeAt(0).toString(16).toUpperCase(); // lol, apparently there's no native function for fixed-width hex output\n\n    if (hex.length < 2) hex = \"0\".concat(hex);\n    return \"%\".concat(hex);\n  });\n}\n\nfunction escape(s) {\n  // eslint-disable-next-line no-control-regex\n  return _escape(/[\\n;\\r\\t=%&,\\x00-\\x1f\\x7f-\\xff]/g, s);\n}\n/**\n * Escape a value for use in a GTF column value.\n *\n * @param {String} s\n * @returns {String}\n */\n\n\nfunction escapeColumn(s) {\n  // eslint-disable-next-line no-control-regex\n  return _escape(/[\\n\\r\\t%\\x00-\\x1f\\x7f-\\xff]/g, s);\n}\n/**\n * Parse the 9th column (attributes) of a GTF feature line.\n *\n * @param {String} attrString\n * @returns {Object}\n */\n\n\nfunction parseAttributes(attrString) {\n  if (!(attrString && attrString.length) || attrString === '.') return {};\n  var attrs = {};\n  attrString.replace(/\\r?\\n$/, '').slice(0, -1) // need to remove the last semicolon in the attributes\n  .split(';').forEach(function (attribute) {\n    var _arec;\n\n    if (!attribute) return;\n    var attr = attribute.trim().split(' ');\n    if (!(attr[1] && attr[1].length)) return;\n    attr[0] = attr[0].trim();\n    var arec = attrs[attr[0].trim()];\n\n    if (!arec) {\n      arec = [];\n      attrs[attr[0]] = arec;\n    } // arec.push(unescape(attr[1].trim()))\n\n\n    (_arec = arec).push.apply(_arec, _toConsumableArray(attr[1].split(',').map(function (s) {\n      return s.trim();\n    }).map(unescape)));\n  });\n  return attrs;\n}\n/**\n * Parse a GTF feature line.\n *\n * @param {String} line\n * returns the parsed line in an object\n */\n\n\nfunction parseFeature(line) {\n  // assummed that there are no comments at the end of a line\n  // split the line into columns and replace '.' with null in each column\n  var f = line.split('\\t').map(function (a) {\n    return a === '.' ? null : a;\n  }); // unescape only the seq_name, source, and feature columns\n\n  f[0] = unescape(f[0]);\n  f[1] = unescape(f[1]);\n  f[2] = unescape(f[2]);\n  f[8] = parseAttributes(f[8]);\n  var parsed = {};\n\n  for (var i = 0; i < fieldNames.length; i += 1) {\n    parsed[fieldNames[i]] = f[i] === '.' ? null : f[i];\n  }\n\n  if (parsed.start !== null) parsed.start = parseInt(parsed.start, 10);\n  if (parsed.end !== null) parsed.end = parseInt(parsed.end, 10);\n  if (parsed.score !== null) parsed.score = parseFloat(parsed.score, 10);\n  if (parsed.strand != null) parsed.strand = parsed.strand;\n  return parsed;\n}\n/**\n * Parse a GTF directive/comment line.\n *\n * @param {String} line\n * @returns {Object} the information in the directive\n */\n\n\nfunction parseDirective(line) {\n  var match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line); // const match = /^\\s*\\#\\#\\s*(\\S+)\\s*(.*)/.exec(line)\n\n  if (!match) return null; // let [, name, contents] = match\n\n  var name = match[1];\n  var contents = match[2];\n  var parsed = {\n    directive: name\n  };\n\n  if (contents.length) {\n    contents = contents.replace(/\\r?\\n$/, '');\n    parsed.value = contents;\n  } // do a little additional parsing for sequence-region and genome-build directives\n\n\n  if (name === 'sequence-region') {\n    var _contents$split = contents.split(/\\s+/, 3),\n        _contents$split2 = _slicedToArray(_contents$split, 3),\n        seqId = _contents$split2[0],\n        contentStart = _contents$split2[1],\n        contentEnd = _contents$split2[2];\n\n    parsed.seq_id = seqId;\n    parsed.start = contentStart && contentStart.replace(/\\D/g, '');\n    parsed.end = contentEnd && contentEnd.replace(/\\D/g, '');\n  } else if (name === 'genome-build') {\n    var _contents$split3 = contents.split(/\\s+/, 2),\n        _contents$split4 = _slicedToArray(_contents$split3, 2),\n        source = _contents$split4[0],\n        buildname = _contents$split4[1];\n\n    parsed.source = source;\n    parsed.buildname = buildname;\n  }\n\n  return parsed;\n}\n/**\n * Format an attributes object into a string suitable for the 9th column of GTF.\n *\n * @param {Object} attrs\n */\n\n\nfunction formatAttributes(attrs) {\n  var attrOrder = [];\n  Object.keys(attrs).forEach(function (tag) {\n    var val = attrs[tag];\n    var valstring; // eslint-disable-next-line no-prototype-builtins\n\n    if (val.hasOwnProperty('toString')) {\n      valstring = escape(val.toString());\n    } else if (Array.isArray(val.values)) {\n      valstring = val.values.map(escape).join(',');\n    } else if (Array.isArray(val)) {\n      valstring = val.map(escape).join(',');\n    } else {\n      valstring = escape(val);\n    }\n\n    attrOrder.push(\"\".concat(escape(tag), \" \").concat(valstring));\n  });\n  return attrOrder.length ? attrOrder.join('; ').concat(';') : '.';\n}\n\nvar translateStrand = ['-', '.', '+'];\n\nfunction _formatSingleFeature(f, seenFeature) {\n  var attrString = f.attributes === null || f.attributes === undefined ? '.' : formatAttributes(f.attributes);\n  var fields = [];\n\n  for (var i = 0; i < 8; i += 1) {\n    var val = f[fieldNames[i]]; // deserialize strand\n\n    if (i === 6) {\n      fields[i] = val === null || val === undefined ? '.' : translateStrand[val + 1] || val;\n    } else {\n      fields[i] = val === null || val === undefined ? '.' : escapeColumn(String(val));\n    }\n  }\n\n  fields[8] = attrString;\n  var formattedString = \"\".concat(fields.join('\\t'), \"\\n\"); // if we have already output this exact feature, skip it\n\n  if (seenFeature[formattedString]) {\n    return '';\n  } // eslint-disable-next-line no-param-reassign\n\n\n  seenFeature[formattedString] = true;\n  return formattedString;\n}\n\nfunction _formatFeature(feature, seenFeature) {\n  if (Array.isArray(feature)) {\n    return feature.map(function (f) {\n      return _formatFeature(f, seenFeature);\n    }).join('');\n  }\n\n  var strings = [_formatSingleFeature(feature, seenFeature)];\n  ['child_features', 'derived_features'].forEach(function (multiSlot) {\n    if (feature[multiSlot]) {\n      strings.push.apply(strings, _toConsumableArray(feature[multiSlot].map(function (f) {\n        return _formatFeature(f, seenFeature);\n      })));\n    }\n  });\n  return strings.join('');\n}\n/**\n * Format a feature object or array of\n * feature objects into one or more lines of GTF.\n *\n * @param {Object|Array[Object]} featureOrFeatures\n */\n\n\nfunction formatFeature(featureOrFeatures) {\n  var seen = {};\n  return _formatFeature(featureOrFeatures, seen);\n}\n/**\n * Format a directive into a line of GTF.\n *\n * @param {Object} directive\n * @returns {String}\n */\n\n\nfunction formatDirective(directive) {\n  var str = \"##\".concat(directive.directive);\n  if (directive.value) str += \" \".concat(directive.value);\n  str += '\\n';\n  return str;\n}\n/**\n * Format a comment into a GTF comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param {Object} comment\n * @returns {String}\n */\n\n\nfunction formatComment(comment) {\n  return \"# \".concat(comment.comment, \"\\n\");\n}\n/**\n * Format a sequence object as FASTA\n *\n * @param {Object} seq\n * @returns {String} formatted single FASTA sequence\n */\n\n\nfunction formatSequence(seq) {\n  return \">\".concat(seq.id).concat(seq.description ? \" \".concat(seq.description) : '', \"\\n\").concat(seq.sequence, \"\\n\");\n}\n/**\n * Format a directive, comment, or feature,\n * or array of such items, into one or more lines of GTF.\n *\n * @param {Object|Array} itemOrItems\n */\n\n\nfunction formatItem(itemOrItems) {\n  function formatSingleItem(item) {\n    if (item[0] || item.attributes) {\n      return formatFeature(item);\n    }\n\n    if (item.directive) {\n      return formatDirective(item);\n    }\n\n    if (item.sequence) {\n      return formatSequence(item);\n    }\n\n    if (item.comment) {\n      return formatComment(item);\n    }\n\n    return '# (invalid item found during format)\\n';\n  }\n\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.map(function (item) {\n      return formatSingleItem(item);\n    });\n  }\n\n  return formatSingleItem(itemOrItems);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n","module.exports = require('./lib/_stream_writable.js');\n","module.exports = require('./lib/_stream_duplex.js');\n","module.exports = require('./readable').Transform\n","module.exports = require('./readable').PassThrough\n"],"sourceRoot":""}