{"version":3,"file":"static/js/8538.89727371.chunk.js","mappings":"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","sources":["../../../node_modules/@flatten-js/interval-tree/dist/main.esm.js"],"sourcesContent":["/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\n/**\r\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\r\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\r\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\r\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\r\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\r\n * This interface is described in typescript definition file *index.d.ts*\r\n *\r\n * Axis aligned rectangle is an example of such interval.\r\n * We may look at rectangle as an interval between its low left and top right corners.\r\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\r\n * of Interval interface implementation\r\n * @type {Interval}\r\n */\r\nconst Interval = class Interval {\r\n    /**\r\n     * Accept two comparable values and creates new instance of interval\r\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\r\n     * @param low\r\n     * @param high\r\n     */\r\n    constructor(low, high) {\r\n        this.low = low;\r\n        this.high = high;\r\n    }\r\n\r\n    /**\r\n     * Clone interval\r\n     * @returns {Interval}\r\n     */\r\n    clone() {\r\n        return new Interval(this.low, this.high);\r\n    }\r\n\r\n    /**\r\n     * Propery max returns clone of this interval\r\n     * @returns {Interval}\r\n     */\r\n    get max() {\r\n        return this.clone();   // this.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval less than other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    less_than(other_interval) {\r\n        return this.low < other_interval.low ||\r\n            this.low == other_interval.low && this.high < other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true is this interval equals to other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    equal_to(other_interval) {\r\n        return this.low == other_interval.low && this.high == other_interval.high;\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval intersects other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    intersect(other_interval) {\r\n        return !this.not_intersect(other_interval);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if this interval does not intersect other interval\r\n     * @param other_interval\r\n     * @returns {boolean}\r\n     */\r\n    not_intersect(other_interval) {\r\n        return (this.high < other_interval.low || other_interval.high < this.low);\r\n    }\r\n\r\n    /**\r\n     * Returns new interval merged with other interval\r\n     * @param {Interval} interval - Other interval to merge with\r\n     * @returns {Interval}\r\n     */\r\n    merge(other_interval) {\r\n        return new Interval(\r\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\r\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Returns how key should return\r\n     */\r\n    output() {\r\n        return [this.low, this.high];\r\n    }\r\n\r\n    /**\r\n     * Function returns maximum between two comparable values\r\n     * @param interval1\r\n     * @param interval2\r\n     * @returns {Interval}\r\n     */\r\n    static comparable_max(interval1, interval2) {\r\n        return interval1.merge(interval2);\r\n    }\r\n\r\n    /**\r\n     * Predicate returns true if first value less than second value\r\n     * @param val1\r\n     * @param val2\r\n     * @returns {boolean}\r\n     */\r\n    static comparable_less_than(val1, val2 ) {\r\n        return val1 < val2;\r\n    }\r\n};\n\n/**\r\n * Created by Alex Bol on 3/28/2017.\r\n */\r\n\r\n// module.exports = {\r\n//     RB_TREE_COLOR_RED: 0,\r\n//     RB_TREE_COLOR_BLACK: 1\r\n// };\r\n\r\nconst RB_TREE_COLOR_RED = 0;\r\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\r\n * Created by Alex Bol on 4/1/2017.\r\n */\r\n\r\nclass Node {\r\n    constructor(key = undefined, value = undefined,\r\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\r\n        this.left = left;                     // reference to left child node\r\n        this.right = right;                   // reference to right child node\r\n        this.parent = parent;                 // reference to parent node\r\n        this.color = color;\r\n\r\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\r\n\r\n        /* If not, this should by an array of two numbers */\r\n        if (key && key instanceof Array && key.length == 2) {\r\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\r\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\r\n            }\r\n        }\r\n\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n    }\r\n\r\n    isNil() {\r\n        return (this.item.key === undefined && this.item.value === undefined &&\r\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\r\n    }\r\n\r\n    less_than(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.less_than(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_less_than = this.item.value && other_node.item.value && this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n                this.item.value < other_node.item.value;\r\n            return this.item.key.less_than(other_node.item.key) ||\r\n                this.item.key.equal_to((other_node.item.key)) && value_less_than;\r\n        }\r\n\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     let item_less_than = this.item.value.less_than ? this.item.value.less_than(other_node.item.value) :\r\n        //         this.item.value < other_node.item.value;\r\n        //     return this.item.key.less_than(other_node.item.key) ||\r\n        //         this.item.key.equal_to((other_node.item.key)) && item_less_than;\r\n        // }\r\n        // else {\r\n        //     return this.item.key.less_than(other_node.item.key);\r\n        // }\r\n    }\r\n\r\n    equal_to(other_node) {\r\n        // if tree stores only keys\r\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\r\n            return this.item.key.equal_to(other_node.item.key);\r\n        }\r\n        else {    // if tree stores keys and values\r\n            let value_equal = this.item.value && other_node.item.value && this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n                this.item.value == other_node.item.value;\r\n            return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n        }\r\n\r\n        // let value_equal = true;\r\n        // if (this.item.value && other_node.item.value) {\r\n        //     value_equal = this.item.value.equal_to ? this.item.value.equal_to(other_node.item.value) :\r\n        //         this.item.value == other_node.item.value;\r\n        // }\r\n        // return this.item.key.equal_to(other_node.item.key) && value_equal;\r\n    }\r\n\r\n    intersect(other_node) {\r\n        return this.item.key.intersect(other_node.item.key);\r\n    }\r\n\r\n    copy_data(other_node) {\r\n        this.item.key = other_node.item.key;\r\n        this.item.value = other_node.item.value;\r\n    }\r\n\r\n    update_max() {\r\n        // use key (Interval) max property instead of key.high\r\n        this.max = this.item.key ? this.item.key.max : undefined;\r\n        if (this.right && this.right.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.right.max);\r\n        }\r\n        if (this.left && this.left.max) {\r\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\r\n            this.max = comparable_max(this.max, this.left.max);\r\n        }\r\n    }\r\n\r\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\r\n    not_intersect_left_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\r\n        return comparable_less_than(high, search_node.item.key.low);\r\n    }\r\n\r\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\r\n    not_intersect_right_subtree(search_node) {\r\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\r\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\r\n        return comparable_less_than(search_node.item.key.high, low);\r\n    }\r\n}\n\n/**\r\n * Created by Alex Bol on 3/31/2017.\r\n */\r\n\r\n// const nil_node = new Node();\r\n\r\n/**\r\n * Implementation of interval binary search tree <br/>\r\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\r\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\r\n * @type {IntervalTree}\r\n */\r\nclass IntervalTree {\r\n    /**\r\n     * Construct new empty instance of IntervalTree\r\n     */\r\n    constructor() {\r\n        this.root = null;\r\n        this.nil_node = new Node();\r\n    }\r\n\r\n    /**\r\n     * Returns number of items stored in the interval tree\r\n     * @returns {number}\r\n     */\r\n    get size() {\r\n        let count = 0;\r\n        this.tree_walk(this.root, () => count++);\r\n        return count;\r\n    }\r\n\r\n    /**\r\n     * Returns array of sorted keys in the ascending order\r\n     * @returns {Array}\r\n     */\r\n    get keys() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(\r\n            node.item.key.output ? node.item.key.output() : node.item.key\r\n        ));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Return array of values in the ascending keys order\r\n     * @returns {Array}\r\n     */\r\n    get values() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns array of items (<key,value> pairs) in the ascended keys order\r\n     * @returns {Array}\r\n     */\r\n    get items() {\r\n        let res = [];\r\n        this.tree_walk(this.root, (node) => res.push({\r\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\r\n            value: node.item.value\r\n        }));\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * Returns true if tree is empty\r\n     * @returns {boolean}\r\n     */\r\n    isEmpty() {\r\n        return (this.root == null || this.root == this.nil_node);\r\n    }\r\n\r\n    /**\r\n     * Clear tree\r\n     */\r\n    clear() {\r\n        this.root = null;\r\n    }\r\n\r\n    /**\r\n     * Insert new item into interval tree\r\n     * @param {Interval} key - interval object or array of two numbers [low, high]\r\n     * @param {any} value - value representing any object (optional)\r\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\r\n     */\r\n    insert(key, value = key) {\r\n        if (key === undefined) return;\r\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\r\n        this.tree_insert(insert_node);\r\n        this.recalc_max(insert_node);\r\n        return insert_node;\r\n    }\r\n\r\n    /**\r\n     * Returns true if item {key,value} exist in the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object to be checked\r\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\r\n     */\r\n    exist(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        return this.tree_search(this.root, search_node) ? true : false;\r\n    }\r\n\r\n    /**\r\n     * Remove entry {key, value} from the tree\r\n     * @param {Interval} key - interval correspondent to keys stored in the tree\r\n     * @param {any} value - value object\r\n     * @returns {boolean} true if item {key, value} deleted, false if not found\r\n     */\r\n    remove(key, value = key) {\r\n        let search_node = new Node(key, value);\r\n        let delete_node = this.tree_search(this.root, search_node);\r\n        if (delete_node) {\r\n            this.tree_delete(delete_node);\r\n        }\r\n        return delete_node;\r\n    }\r\n\r\n    /**\r\n     * Returns array of entry values which keys intersect with given interval <br/>\r\n     * If no values stored in the tree, returns array of keys which intersect given interval\r\n     * @param {Interval} interval - search interval, or tuple [low, high]\r\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\r\n     * @returns {Array}\r\n     */\r\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\r\n        let search_node = new Node(interval);\r\n        let resp_nodes = [];\r\n        this.tree_search_interval(this.root, search_node, resp_nodes);\r\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\r\n    }\r\n\r\n    /**\r\n     * Returns true if intersection between given and any interval stored in the tree found\r\n     * @param {Interval} interval - search interval or tuple [low, high]\r\n     * @returns {boolean}\r\n     */\r\n    intersect_any(interval) {\r\n        let search_node = new Node(interval);\r\n        let found = this.tree_find_any_interval(this.root, search_node);\r\n        return found;\r\n    }\r\n\r\n    /**\r\n     * Tree visitor. For each node implement a callback function. <br/>\r\n     * Method calls a callback function with two parameters (key, value)\r\n     * @param visitor(key,value) - function to be called for each tree item\r\n     */\r\n    forEach(visitor) {\r\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\r\n    }\r\n\r\n    /** Value Mapper. Walk through every node and map node value to another value\r\n    * @param callback(value,key) - function to be called for each tree item\r\n    */\r\n    map(callback) {\r\n        const tree = new IntervalTree();\r\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\r\n        return tree;\r\n    }\r\n\r\n    recalc_max(node) {\r\n        let node_current = node;\r\n        while (node_current.parent != null) {\r\n            node_current.parent.update_max();\r\n            node_current = node_current.parent;\r\n        }\r\n    }\r\n\r\n    tree_insert(insert_node) {\r\n        let current_node = this.root;\r\n        let parent_node = null;\r\n\r\n        if (this.root == null || this.root == this.nil_node) {\r\n            this.root = insert_node;\r\n        }\r\n        else {\r\n            while (current_node != this.nil_node) {\r\n                parent_node = current_node;\r\n                if (insert_node.less_than(current_node)) {\r\n                    current_node = current_node.left;\r\n                }\r\n                else {\r\n                    current_node = current_node.right;\r\n                }\r\n            }\r\n\r\n            insert_node.parent = parent_node;\r\n\r\n            if (insert_node.less_than(parent_node)) {\r\n                parent_node.left = insert_node;\r\n            }\r\n            else {\r\n                parent_node.right = insert_node;\r\n            }\r\n        }\r\n\r\n        this.insert_fixup(insert_node);\r\n    }\r\n\r\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\r\n// Go upwords to the root and re-color until violation will be resolved\r\n    insert_fixup(insert_node) {\r\n        let current_node;\r\n        let uncle_node;\r\n\r\n        current_node = insert_node;\r\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\r\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\r\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {                                                    // Case 2 & 3. Uncle is black\r\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\r\n                        // This case is transformed into Case 3.\r\n                        current_node = current_node.parent;\r\n                        this.rotate_left(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\r\n                    // Re-color father and grandfather, rotate grandfather right\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_right(current_node.parent.parent);\r\n                }\r\n            }\r\n            else {                                                         // parent is right child of grandfather\r\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\r\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\r\n                    // re-color father and uncle into black\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    current_node = current_node.parent.parent;\r\n                }\r\n                else {\r\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\r\n                        // Transform into case 6\r\n                        current_node = current_node.parent;\r\n                        this.rotate_right(current_node);\r\n                    }\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\r\n                    // Re-color father and grandfather, rotate grandfather left\r\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\r\n                    this.rotate_left(current_node.parent.parent);\r\n                }\r\n            }\r\n        }\r\n\r\n        this.root.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_delete(delete_node) {\r\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\r\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\r\n\r\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\r\n            cut_node = delete_node;\r\n        }\r\n        else {                                                    // delete_node has 2 children\r\n            cut_node = this.tree_successor(delete_node);\r\n        }\r\n\r\n        // fix_node if single child of cut_node\r\n        if (cut_node.left != this.nil_node) {\r\n            fix_node = cut_node.left;\r\n        }\r\n        else {\r\n            fix_node = cut_node.right;\r\n        }\r\n\r\n        // remove cut_node from parent\r\n        /*if (fix_node != this.nil_node) {*/\r\n            fix_node.parent = cut_node.parent;\r\n        /*}*/\r\n\r\n        if (cut_node == this.root) {\r\n            this.root = fix_node;\r\n        }\r\n        else {\r\n            if (cut_node == cut_node.parent.left) {\r\n                cut_node.parent.left = fix_node;\r\n            }\r\n            else {\r\n                cut_node.parent.right = fix_node;\r\n            }\r\n            cut_node.parent.update_max();        // update max property of the parent\r\n        }\r\n\r\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\r\n\r\n        // COPY DATA !!!\r\n        // Delete_node becomes cut_node, it means that we cannot hold reference\r\n        // to node in outer structure and we will have to delete by key, additional search need\r\n        if (cut_node != delete_node) {\r\n            delete_node.copy_data(cut_node);\r\n            delete_node.update_max();           // update max property of the cut node at the new place\r\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\r\n        }\r\n\r\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\r\n            this.delete_fixup(fix_node);\r\n        }\r\n    }\r\n\r\n    delete_fixup(fix_node) {\r\n        let current_node = fix_node;\r\n        let brother_node;\r\n\r\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\r\n            if (current_node == current_node.parent.left) {          // fix node is left child\r\n                brother_node = current_node.parent.right;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_left(current_node.parent);\r\n                    brother_node = current_node.parent.right;                      // update brother\r\n                }\r\n                // Derive to cases 2..4: brother is black\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\r\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\r\n                    current_node = current_node.parent;                  // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\r\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\r\n                        this.rotate_right(brother_node);\r\n                        brother_node = current_node.parent.right;                     // update brother\r\n                        // Derive to case 4: left nephew black, right nephew red\r\n                    }\r\n                    // case 4: left nephew black, right nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_left(current_node.parent);\r\n                    current_node = this.root;                         // exit from loop\r\n                }\r\n            }\r\n            else {                                             // fix node is right child\r\n                brother_node = current_node.parent.left;\r\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\r\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\r\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\r\n                    this.rotate_right(current_node.parent);\r\n                    brother_node = current_node.parent.left;                        // update brother\r\n                }\r\n                // Go to cases 2..4\r\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\r\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\r\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\r\n                    current_node = current_node.parent;                              // continue iteration\r\n                }\r\n                else {\r\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\r\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\r\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\r\n                        this.rotate_left(brother_node);\r\n                        brother_node = current_node.parent.left;                        // update brother\r\n                        // Derive to case 4: right nephew black, left nephew red\r\n                    }\r\n                    // case 4: right nephew black, left nephew red\r\n                    brother_node.color = current_node.parent.color;\r\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\r\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\r\n                    this.rotate_right(current_node.parent);\r\n                    current_node = this.root;                               // force exit from loop\r\n                }\r\n            }\r\n        }\r\n\r\n        current_node.color = RB_TREE_COLOR_BLACK;\r\n    }\r\n\r\n    tree_search(node, search_node) {\r\n        if (node == null || node == this.nil_node)\r\n            return undefined;\r\n\r\n        if (search_node.equal_to(node)) {\r\n            return node;\r\n        }\r\n        if (search_node.less_than(node)) {\r\n            return this.tree_search(node.left, search_node);\r\n        }\r\n        else {\r\n            return this.tree_search(node.right, search_node);\r\n        }\r\n    }\r\n\r\n    // Original search_interval method; container res support push() insertion\r\n    // Search all intervals intersecting given one\r\n    tree_search_interval(node, search_node, res) {\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                this.tree_search_interval(node.left, search_node, res);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (node.intersect(search_node)) {\r\n                res.push(node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                this.tree_search_interval(node.right, search_node, res);\r\n            }\r\n        }\r\n    }\r\n\r\n    tree_find_any_interval(node, search_node) {\r\n        let found = false;\r\n        if (node != null && node != this.nil_node) {\r\n            // if (node->left != this.nil_node && node->left->max >= low) {\r\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.left, search_node);\r\n            }\r\n            // if (low <= node->high && node->low <= high) {\r\n            if (!found) {\r\n                found = node.intersect(search_node);\r\n            }\r\n            // if (node->right != this.nil_node && node->low <= high) {\r\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\r\n                found = this.tree_find_any_interval(node.right, search_node);\r\n            }\r\n        }\r\n        return found;\r\n    }\r\n\r\n    local_minimum(node) {\r\n        let node_min = node;\r\n        while (node_min.left != null && node_min.left != this.nil_node) {\r\n            node_min = node_min.left;\r\n        }\r\n        return node_min;\r\n    }\r\n\r\n    // not in use\r\n    local_maximum(node) {\r\n        let node_max = node;\r\n        while (node_max.right != null && node_max.right != this.nil_node) {\r\n            node_max = node_max.right;\r\n        }\r\n        return node_max;\r\n    }\r\n\r\n    tree_successor(node) {\r\n        let node_successor;\r\n        let current_node;\r\n        let parent_node;\r\n\r\n        if (node.right != this.nil_node) {\r\n            node_successor = this.local_minimum(node.right);\r\n        }\r\n        else {\r\n            current_node = node;\r\n            parent_node = node.parent;\r\n            while (parent_node != null && parent_node.right == current_node) {\r\n                current_node = parent_node;\r\n                parent_node = parent_node.parent;\r\n            }\r\n            node_successor = parent_node;\r\n        }\r\n        return node_successor;\r\n    }\r\n\r\n    //           |            right-rotate(T,y)       |\r\n    //           y            ---------------.       x\r\n    //          / \\                                  / \\\r\n    //         x   c          left-rotate(T,x)      a   y\r\n    //        / \\             <---------------         / \\\r\n    //       a   b                                    b   c\r\n\r\n    rotate_left(x) {\r\n        let y = x.right;\r\n\r\n        x.right = y.left;           // b goes to x.right\r\n\r\n        if (y.left != this.nil_node) {\r\n            y.left.parent = x;     // x becomes parent of b\r\n        }\r\n        y.parent = x.parent;       // move parent\r\n\r\n        if (x == this.root) {\r\n            this.root = y;           // y becomes root\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (x == x.parent.left) {\r\n                x.parent.left = y;\r\n            }\r\n            else {\r\n                x.parent.right = y;\r\n            }\r\n        }\r\n        y.left = x;                 // x becomes left child of y\r\n        x.parent = y;               // and y becomes parent of x\r\n\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n\r\n        y = x.parent;\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n    }\r\n\r\n    rotate_right(y) {\r\n        let x = y.left;\r\n\r\n        y.left = x.right;           // b goes to y.left\r\n\r\n        if (x.right != this.nil_node) {\r\n            x.right.parent = y;        // y becomes parent of b\r\n        }\r\n        x.parent = y.parent;          // move parent\r\n\r\n        if (y == this.root) {        // x becomes root\r\n            this.root = x;\r\n        }\r\n        else {                        // y becomes child of x.parent\r\n            if (y == y.parent.left) {\r\n                y.parent.left = x;\r\n            }\r\n            else {\r\n                y.parent.right = x;\r\n            }\r\n        }\r\n        x.right = y;                 // y becomes right child of x\r\n        y.parent = x;               // and x becomes parent of y\r\n\r\n        if (y != null && y != this.nil_node) {\r\n            y.update_max();\r\n        }\r\n\r\n        x = y.parent;\r\n        if (x != null && x != this.nil_node) {\r\n            x.update_max();\r\n        }\r\n    }\r\n\r\n    tree_walk(node, action) {\r\n        if (node != null && node != this.nil_node) {\r\n            this.tree_walk(node.left, action);\r\n            // arr.push(node.toArray());\r\n            action(node);\r\n            this.tree_walk(node.right, action);\r\n        }\r\n    }\r\n\r\n    /* Return true if all red nodes have exactly two black child nodes */\r\n    testRedBlackProperty() {\r\n        let res = true;\r\n        this.tree_walk(this.root, function (node) {\r\n            if (node.color == RB_TREE_COLOR_RED) {\r\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\r\n                    res = false;\r\n                }\r\n            }\r\n        });\r\n        return res;\r\n    }\r\n\r\n    /* Throw error if not every path from root to bottom has same black height */\r\n    testBlackHeightProperty(node) {\r\n        let height = 0;\r\n        let heightLeft = 0;\r\n        let heightRight = 0;\r\n        if (node.color == RB_TREE_COLOR_BLACK) {\r\n            height++;\r\n        }\r\n        if (node.left != this.nil_node) {\r\n            heightLeft = this.testBlackHeightProperty(node.left);\r\n        }\r\n        else {\r\n            heightLeft = 1;\r\n        }\r\n        if (node.right != this.nil_node) {\r\n            heightRight = this.testBlackHeightProperty(node.right);\r\n        }\r\n        else {\r\n            heightRight = 1;\r\n        }\r\n        if (heightLeft != heightRight) {\r\n            throw new Error('Red-black height property violated');\r\n        }\r\n        height += heightLeft;\r\n        return height;\r\n    };\r\n}\n\nexport default IntervalTree;\nexport { Node, Interval };\n"],"names":["Interval","low","high","this","clone","other_interval","not_intersect","undefined","Math","min","max","interval1","interval2","merge","val1","val2","RB_TREE_COLOR_RED","RB_TREE_COLOR_BLACK","Node","key","value","left","right","parent","color","item","Array","length","Number","isNaN","other_node","less_than","value_less_than","equal_to","value_equal","intersect","comparable_max","constructor","search_node","comparable_less_than","IntervalTree","root","nil_node","count","tree_walk","res","node","push","output","insert_node","tree_insert","recalc_max","tree_search","delete_node","tree_delete","interval","outputMapperFn","resp_nodes","tree_search_interval","map","tree_find_any_interval","visitor","callback","tree","insert","node_current","update_max","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","tree_successor","copy_data","delete_fixup","brother_node","not_intersect_left_subtree","not_intersect_right_subtree","found","node_min","node_max","node_successor","local_minimum","x","y","action","height","heightLeft","testBlackHeightProperty","Error"],"sourceRoot":""}