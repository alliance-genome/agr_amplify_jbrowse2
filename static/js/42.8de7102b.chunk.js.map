{"version":3,"sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/VcfImport.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"names":["vcfCoreColumns","name","type","vcfRecordToRow","vcfParser","line","lineNumber","vcfVariant","parseLine","vcfFeature","VcfFeature","variant","parser","id","data","split","map","d","length","push","String","extendedData","toJSON","cells","text","columnNumber","parseVcfBuffer","buffer","options","hasColumnNameLine","columnNameLineNumber","isValidRefName","splitVcfFileHeaderAndBody","bufferToString","header","body","rows","VCF","forEach","test","rowSet","isLoaded","columnDisplayOrder","columns","i","dataType","samples","oi","unshift","isDerived","derivationFunctionText","hasColumnNames","assemblyName","selectedAssemblyName","wholeFile","prevChar","headerEndIndex","c","substr","TextDecoder","fatal","decode","parseWith","a","then","module","default","csv","noheader","output","fromString","guessColumnType","parsedLoc","guessedType","parseLocString","error","refName","start","dataToSpreadsheetSnapshot","maxCols","row","rowNumber","columnNames","undefined","splice","colNamesRow","cell","parseCsvBuffer","parseTsvBuffer","delimiter"],"mappings":"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","file":"static/js/42.8de7102b.chunk.js","sourcesContent":["import VCF from '@gmod/vcf'\nimport { VcfFeature } from '@jbrowse/plugin-variants'\nimport {\n  bufferToString,\n  Row,\n  RowSet,\n  Column,\n  ParseOptions,\n} from './ImportUtils'\n\nconst vcfCoreColumns: { name: string; type: string }[] = [\n  { name: 'CHROM', type: 'Text' }, // 0\n  { name: 'POS', type: 'Number' }, // 1\n  { name: 'ID', type: 'Text' }, // 2\n  { name: 'REF', type: 'Text' }, // 3\n  { name: 'ALT', type: 'Text' }, // 4\n  { name: 'QUAL', type: 'Number' }, // 5\n  { name: 'FILTER', type: 'Text' }, // 6\n  { name: 'INFO', type: 'Text' }, // 7\n  { name: 'FORMAT', type: 'Text' }, // 8\n]\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction vcfRecordToRow(vcfParser: any, line: string, lineNumber: number): Row {\n  const vcfVariant = vcfParser.parseLine(line)\n  const vcfFeature = new VcfFeature({\n    variant: vcfVariant,\n    parser: vcfParser,\n    id: `vcf-${lineNumber}`,\n  })\n\n  const data = line.split('\\t').map(d => (d === '.' ? '' : d))\n  // no format column, add blank\n  if (data.length === 8) {\n    data.push('')\n  }\n  const row: Row = {\n    id: String(lineNumber + 1),\n    extendedData: { vcfFeature: vcfFeature.toJSON() },\n    cells: data.map((text, columnNumber) => {\n      return {\n        columnNumber,\n        text,\n      }\n    }),\n  }\n  return row\n}\n\nexport function parseVcfBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 0,\n    isValidRefName: () => false,\n  },\n) {\n  let { header, body } = splitVcfFileHeaderAndBody(bufferToString(buffer))\n  const rows: Row[] = []\n  const vcfParser = new VCF({ header })\n  header = '' // garbage collect\n  body.split('\\n').forEach((line: string, lineNumber) => {\n    if (/\\S/.test(line)) {\n      rows.push(vcfRecordToRow(vcfParser, line, lineNumber))\n    }\n  })\n  body = '' // garbage collect\n\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows,\n  }\n\n  const columnDisplayOrder: number[] = []\n  const columns: Column[] = []\n  for (let i = 0; i < vcfCoreColumns.length; i += 1) {\n    columnDisplayOrder.push(i)\n    columns[i] = {\n      name: vcfCoreColumns[i].name,\n      dataType: { type: vcfCoreColumns[i].type },\n    }\n  }\n  for (let i = 0; i < vcfParser.samples.length; i += 1) {\n    const oi = vcfCoreColumns.length + i\n    columnDisplayOrder.push(oi)\n    columns[oi] = { name: vcfParser.samples[i], dataType: { type: 'Text' } }\n  }\n\n  columnDisplayOrder.push(columnDisplayOrder.length)\n  columns.unshift({\n    name: 'Location',\n    dataType: { type: 'LocString' },\n    isDerived: true,\n    derivationFunctionText: `jexl:{text:row.extendedData.vcfFeature.refName+':'\\n\n    +row.extendedData.vcfFeature.start+'..'+row.extendedData.vcfFeature.end, extendedData:\\n\n    {refName:row.extendedData.vcfFeature.refName,start:row.extendedData.vcfFeature.start,end:row.extendedData.vcfFeature.end}}`,\n  })\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: true,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport function splitVcfFileHeaderAndBody(wholeFile: string) {\n  // split into header and the rest of the file\n  let headerEndIndex = 0\n  let prevChar\n  for (; headerEndIndex < wholeFile.length; headerEndIndex += 1) {\n    const c = wholeFile[headerEndIndex]\n    if (prevChar === '\\n' && c !== '#') {\n      break\n    }\n    prevChar = c\n  }\n\n  return {\n    header: wholeFile.substr(0, headerEndIndex),\n    body: wholeFile.substr(headerEndIndex),\n  }\n}\n","import { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf-8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc && parsedLoc.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (options.hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (options.hasColumnNameLine && options.columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(\n      options.columnNameLineNumber - 1,\n      1,\n    )\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(\n      rowSet,\n      columnNumber,\n      options.isValidRefName,\n    )\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      rowSet.rows.forEach(row => {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, options.isValidRefName)\n      })\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!options.hasColumnNameLine,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"sourceRoot":""}