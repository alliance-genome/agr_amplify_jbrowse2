{"version":3,"file":"static/js/4782.26fa3eb1.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/nclist/src/util.ts","../../../node_modules/@gmod/nclist/src/nclist.ts","../../../node_modules/@gmod/nclist/src/array_representation.ts","../../../node_modules/@gmod/nclist/src/lazy_array.ts","../../../node_modules/@gmod/nclist/src/feature_store.ts","../../../node_modules/@gmod/nclist/src/index.ts","../../../node_modules/@babel/runtime/helpers/esm/OverloadYield.js","../../../node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js","../../../node_modules/@babel/runtime/helpers/esm/asyncIterator.js","../../../node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js"],"sourcesContent":["//@ts-nocheck\nexport async function readJSON(url, readFile, options = {}) {\n  const { defaultContent = {} } = options\n  let str\n  try {\n    str = await readFile(url, { encoding: 'utf8' })\n    return JSON.parse(str)\n  } catch (error) {\n    if (error.code === 'ENOENT' || error.status === 404) {\n      return defaultContent\n    }\n    throw error\n  }\n}\n\nexport function foo() {}\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport { readJSON } from './util'\n\nexport default class NCList {\n  constructor({ readFile, cacheSize = 100 }) {\n    this.topList = []\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.readChunkItems.bind(this),\n    })\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function`)\n    }\n  }\n\n  importExisting(nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {\n    this.topList = nclist\n    this.attrs = attrs\n    this.start = attrs.makeFastGetter('Start')\n    this.end = attrs.makeFastGetter('End')\n    this.lazyClass = lazyClass\n    this.baseURL = baseURL\n    this.lazyUrlTemplate = lazyUrlTemplate\n  }\n\n  binarySearch(arr, item, getter) {\n    let low = -1\n    let high = arr.length\n    let mid\n\n    while (high - low > 1) {\n      mid = (low + high) >>> 1\n      if (getter(arr[mid]) >= item) {\n        high = mid\n      } else {\n        low = mid\n      }\n    }\n\n    // if we're iterating rightward, return the high index;\n    // if leftward, the low index\n    if (getter === this.end) {\n      return high\n    }\n    return low\n  }\n\n  readChunkItems(chunkNum) {\n    const url = nodeUrl.resolve(\n      this.baseURL,\n      this.lazyUrlTemplate.replace(/\\{Chunk\\}/gi, chunkNum),\n    )\n    return readJSON(url, this.readFile, { defaultContent: [] })\n  }\n\n  async *iterateSublist(arr, from, to, inc, searchGet, testGet, path) {\n    const getChunk = this.attrs.makeGetter('Chunk')\n    const getSublist = this.attrs.makeGetter('Sublist')\n\n    const pendingPromises = []\n    for (\n      let i = this.binarySearch(arr, from, searchGet);\n      i < arr.length && i >= 0 && inc * testGet(arr[i]) < inc * to;\n      i += inc\n    ) {\n      if (arr[i][0] === this.lazyClass) {\n        // this is a lazily-loaded chunk of the nclist\n        const chunkNum = getChunk(arr[i])\n        const chunkItemsP = this.chunkCache\n          .get(chunkNum, chunkNum)\n          .then(item => [item, chunkNum])\n        pendingPromises.push(chunkItemsP)\n      } else {\n        // this is just a regular feature\n        yield [arr[i], path.concat(i)]\n      }\n\n      // if this node has a contained sublist, process that too\n      const sublist = getSublist(arr[i])\n      if (sublist) {\n        yield* this.iterateSublist(\n          sublist,\n          from,\n          to,\n          inc,\n          searchGet,\n          testGet,\n          path.concat(i),\n        )\n      }\n    }\n\n    for (let i = 0; i < pendingPromises.length; i += 1) {\n      const [item, chunkNum] = await pendingPromises[i]\n      if (item) {\n        yield* this.iterateSublist(item, from, to, inc, searchGet, testGet, [\n          ...path,\n          chunkNum,\n        ])\n      }\n    }\n  }\n\n  async *iterate(from, to) {\n    // calls the given function once for each of the\n    // intervals that overlap the given interval\n    // if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n    // inc: iterate leftward or rightward\n    const inc = from > to ? -1 : 1\n    // searchGet: search on start or end\n    const searchGet = from > to ? this.start : this.end\n    // testGet: test on start or end\n    const testGet = from > to ? this.end : this.start\n\n    if (this.topList.length > 0) {\n      yield* this.iterateSublist(\n        this.topList,\n        from,\n        to,\n        inc,\n        searchGet,\n        testGet,\n        [0],\n      )\n    }\n  }\n\n  async histogram(from, to, numBins) {\n    // calls callback with a histogram of the feature density\n    // in the given interval\n\n    const result = new Array(numBins)\n    result.fill(0)\n    const binWidth = (to - from) / numBins\n    for await (const feat of this.iterate(from, to)) {\n      const firstBin = Math.max(0, ((this.start(feat) - from) / binWidth) | 0)\n      const lastBin = Math.min(\n        numBins,\n        ((this.end(feat) - from) / binWidth) | 0,\n      )\n      for (let bin = firstBin; bin <= lastBin; bin += 1) {\n        result[bin] += 1\n      }\n    }\n    return result\n  }\n}\n","//@ts-nocheck\n/**\n * @class ArrayRepr\n *\n * Class for operating on indexed array representations of objects.\n *\n * For example, if we have a lot of objects with similar attrbutes, e.g.:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: -1},\n *         {start: 5, end: 6, strand: 1},\n *         ...\n *     ]\n * </pre>\n *\n * @description\n * we can represent them more compactly (e.g., in JSON) something like this:\n *\n * <pre class=\"code\">\n *     class = [\"start\", \"end\", \"strand\"]\n *     [\n *         [1, 2, -1],\n *         [5, 6, 1],\n *         ...\n *     ]\n * </pre>\n *\n * If we want to represent a few different kinds of objects in our big list,\n * we can have multiple \"class\" arrays, and tag each object to identify\n * which \"class\" array describes it.\n *\n * For example, if we have a lot of instances of a few types of objects,\n * like this:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: 1, id: 1},\n *         {start: 5, end: 6, strand: 1, id: 2},\n *         ...\n *         {start: 10, end: 20, chunk: 1},\n *         {start: 30, end: 40, chunk: 2},\n *         ...\n *     ]\n * </pre>\n *\n * We could use the first array position to indicate the \"class\" for the\n * object, like this:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2],\n *         ...\n *         [1, 10, 20, 1],\n *         [1, 30, 40, 1]\n *     ]\n * </pre>\n *\n * Also, if we occasionally want to add an ad-hoc attribute, we could just\n * stick an optional dictionary onto the end:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2, {foo: 1}]\n *     ]\n * </pre>\n *\n * Given that individual objects are being represented by arrays, generic\n * code needs some way to differentiate arrays that are meant to be objects\n * from arrays that are actually meant to be arrays.\n * So for each class, we include a dict with <attribute name>: true mappings\n * for each attribute that is meant to be an array.\n *\n * Also, in cases where some attribute values are the same for all objects\n * in a particular set, it may be convenient to define a \"prototype\"\n * with default values for all objects in the set\n *\n * In the end, we get something like this:\n *\n * <pre class=\"code\">\n *     classes=[\n *         {'attributes': ['Start', 'End', 'Subfeatures'],\n *          'proto': {'Chrom': 'chr1'},\n *          'isArrayAttr': {Subfeatures: true}}\n *         ]\n * </pre>\n *\n * That's what this class facilitates.\n */\nclass ArrayRepr {\n  constructor(classes) {\n    this.classes = classes\n    this.fields = []\n    for (let cl = 0; cl < classes.length; cl += 1) {\n      this.fields[cl] = {}\n      for (let f = 0; f < classes[cl].attributes.length; f += 1) {\n        this.fields[cl][classes[cl].attributes[f]] = f + 1\n      }\n      if (classes[cl].proto === undefined) {\n        classes[cl].proto = {}\n      }\n      if (classes[cl].isArrayAttr === undefined) {\n        classes[cl].isArrayAttr = {}\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  attrIndices(attr) {\n    return this.classes.map(\n      x =>\n        x.attributes.indexOf(attr) + 1 ||\n        x.attributes.indexOf(attr.toLowerCase()) + 1 ||\n        undefined,\n    )\n  }\n\n  get(obj, attr) {\n    if (attr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][attr]]\n    }\n\n    // try lowercase\n    const lcattr = attr.toLowerCase()\n    if (lcattr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][lcattr]]\n    }\n\n    const adhocIndex = this.classes[obj[0]].attributes.length + 1\n    if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n      if (attr in this.classes[obj[0]].proto) {\n        return this.classes[obj[0]].proto[attr]\n      }\n      return undefined\n    }\n    return obj[adhocIndex][attr]\n  }\n\n  makeSetter(attr) {\n    return (obj, val) => {\n      this.set(obj, attr, val)\n    }\n  }\n\n  makeGetter(attr) {\n    return obj => {\n      return this.get(obj, attr)\n    }\n  }\n\n  makeFastGetter(attr) {\n    // can be used only if attr is guaranteed to be in\n    // the \"classes\" array for this object\n    const indices = this.attrIndices(attr)\n    return function get(obj) {\n      if (indices[obj[0]] !== undefined) {\n        return obj[indices[obj[0]]]\n      }\n      return undefined\n    }\n  }\n\n  // construct(self, obj, klass) {\n  //   const result = new Array(self.classes[klass].length)\n  //   Object.keys(obj).forEach(attr => {\n  //     this.set(result, attr, obj[attr])\n  //   })\n  //   return result\n  // }\n\n  /**\n   * Returns fast pre-compiled getter and setter functions for use with\n   * Arrays that use this representation.\n   * When the returned <code>get</code> and <code>set</code> functions are\n   * added as methods to an Array that contains data in this\n   * representation, they provide fast access by name to the data.\n   *\n   * @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n   *\n   * @example\n   * var accessors = attrs.accessors();\n   * var feature = get_feature_from_someplace();\n   * feature.get = accessors.get;\n   * // print out the feature start and end\n   * console.log( feature.get('start') + ',' + feature.get('end') );\n   */\n  accessors() {\n    if (!this._accessors) {\n      this._accessors = this._makeAccessors()\n    }\n    return this._accessors\n  }\n\n  /**\n   * @private\n   */\n  _makeAccessors() {\n    const indices = {}\n\n    const accessors = {\n      get(field) {\n        const f = this.get.field_accessors[field.toLowerCase()]\n        if (f) {\n          return f.call(this)\n        }\n        return undefined\n      },\n      set(field, val) {\n        const f = this.set.field_accessors[field]\n        if (f) {\n          return f.call(this, val)\n        }\n        return undefined\n      },\n      tags() {\n        return tags[this[0]] || []\n      },\n    }\n    accessors.get.field_accessors = {}\n    accessors.set.field_accessors = {}\n\n    // make a data structure as: { attr_name: [offset,offset,offset], }\n    // that will be convenient for finding the location of the attr\n    // for a given class like: indexForAttr{attrname}[classnum]\n    this.classes.forEach((cdef, classnum) => {\n      ;(cdef.attributes || []).forEach((attrname, offset) => {\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n\n        attrname = attrname.toLowerCase()\n\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n      })\n    })\n\n    // lowercase all the class attributes\n    const tags = this.classes.map(c => c.attributes)\n\n    // use that to make precalculated get and set accessors for each field\n    Object.keys(indices).forEach(attrname => {\n      const attrIndices = indices[attrname]\n      // get\n      accessors.get.field_accessors[attrname] = !attrIndices\n        ? function get() {\n            return undefined\n          }\n        : function get() {\n            return this[attrIndices[this[0]]]\n          }\n\n      // // set\n      // accessors.set.field_accessors[attrname] = !attrIndices\n      //   ? () => undefined\n      //   : v => {\n      //       this[attrIndices[this[0]]] = v\n      //       return v\n      //     }\n    })\n\n    return accessors\n  }\n}\nexport default ArrayRepr\n\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport { readJSON } from './util'\n\n/**\n * For a JSON array that gets too large to load in one go, this class\n * helps break it up into chunks and provides an\n * async API for using the information in the array.\n */\nexport default class LazyArray {\n  constructor(\n    { urlTemplate, chunkSize, length, cacheSize = 100, readFile },\n    baseUrl,\n  ) {\n    this.urlTemplate = urlTemplate\n    this.chunkSize = chunkSize\n    this.length = length\n    this.baseUrl = baseUrl === undefined ? '' : baseUrl\n    this.readFile = readFile\n    if (!readFile) {\n      throw new Error('must provide readFile callback')\n    }\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.getChunk.bind(this),\n    })\n  }\n\n  /**\n   * call the callback on one element of the array\n   * @param i index\n   * @param callback callback, gets called with (i, value, param)\n   * @param param (optional) callback will get this as its last parameter\n   */\n  index(i, callback, param) {\n    this.range(i, i, callback, undefined, param)\n  }\n\n  /**\n   * async generator for the elements in the range [start,end]\n   *\n   * @param start index of first element to call the callback on\n   * @param end index of last element to call the callback on\n   */\n  async *range(start, end) {\n    start = Math.max(0, start)\n    end = Math.min(end, this.length - 1)\n\n    const firstChunk = Math.floor(start / this.chunkSize)\n    const lastChunk = Math.floor(end / this.chunkSize)\n\n    const chunkreadFiles = []\n    for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n      chunkreadFiles.push(this.chunkCache.get(chunk, chunk))\n    }\n    for (let i = 0; i < chunkreadFiles.length; i += 1) {\n      const [chunkNumber, chunkData] = await chunkreadFiles[i]\n      yield* this.filterChunkData(start, end, chunkNumber, chunkData)\n    }\n  }\n\n  async getChunk(chunkNumber) {\n    let url = this.urlTemplate.replace(/\\{Chunk\\}/gi, chunkNumber)\n    if (this.baseUrl) {\n      url = nodeUrl.resolve(this.baseUrl, url)\n    }\n    const data = await readJSON(url, this.readFile)\n    return [chunkNumber, data]\n  }\n\n  *filterChunkData(queryStart, queryEnd, chunkNumber, chunkData) {\n    // index (in the overall lazy array) of the first position in this chunk\n    const firstIndex = chunkNumber * this.chunkSize\n    const chunkStart = Math.max(0, queryStart - firstIndex)\n    const chunkEnd = Math.min(queryEnd - firstIndex, this.chunkSize - 1)\n    for (let i = chunkStart; i <= chunkEnd; i += 1) {\n      yield [i + firstIndex, chunkData[i]]\n    }\n  }\n}\n","//@ts-nocheck\nimport nodeUrl from 'url'\nimport QuickLRU from 'quick-lru'\nimport AbortablePromiseCache from 'abortable-promise-cache'\n\nimport GenericNCList from './nclist'\nimport ArrayRepr from './array_representation'\nimport LazyArray from './lazy_array'\nimport { readJSON } from './util'\n\nfunction idfunc() {\n  return this._uniqueID\n}\nfunction parentfunc() {\n  return this._parent\n}\nfunction childrenfunc() {\n  return this.get('subfeatures')\n}\n\n/**\n * Sequence feature store using nested containment\n * lists held in JSON files that are lazily read.\n *\n * @param {object} args constructor args\n * @param {string} args.baseUrl base URL for resolving relative URLs\n * @param {string} args.urlTemplate Template string for\n *  the root file of each reference sequence. The reference sequence\n *  name will be interpolated into this string where `{refseq}` appears.\n * @param {function} args.readFile function to use for reading remote from URLs.\n */\nexport default class NCListStore {\n  constructor({ baseUrl, urlTemplate, readFile, cacheSize = 10 }) {\n    this.baseUrl = baseUrl\n    this.urlTemplates = { root: urlTemplate }\n\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function argument`)\n    }\n\n    this.dataRootCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.fetchDataRoot.bind(this),\n    })\n  }\n\n  makeNCList() {\n    return new GenericNCList({ readFile: this.readFile })\n  }\n\n  loadNCList(refData, trackInfo, listUrl) {\n    refData.nclist.importExisting(\n      trackInfo.intervals.nclist,\n      refData.attrs,\n      listUrl,\n      trackInfo.intervals.urlTemplate,\n      trackInfo.intervals.lazyClass,\n    )\n  }\n\n  getDataRoot(refName) {\n    return this.dataRootCache.get(refName, refName)\n  }\n\n  fetchDataRoot(refName) {\n    const url = nodeUrl.resolve(\n      this.baseUrl,\n      this.urlTemplates.root.replace(/{\\s*refseq\\s*}/g, refName),\n    )\n\n    // fetch the trackdata\n    return readJSON(url, this.readFile).then(trackInfo =>\n      // trackInfo = JSON.parse( trackInfo );\n      this.parseTrackInfo(trackInfo, url),\n    )\n  }\n\n  parseTrackInfo(trackInfo, url) {\n    const refData = {\n      nclist: this.makeNCList(),\n      stats: {\n        featureCount: trackInfo.featureCount || 0,\n      },\n    }\n\n    if (trackInfo.intervals) {\n      refData.attrs = new ArrayRepr(trackInfo.intervals.classes)\n      this.loadNCList(refData, trackInfo, url)\n    }\n\n    const { histograms } = trackInfo\n    if (histograms && histograms.meta) {\n      for (let i = 0; i < histograms.meta.length; i += 1) {\n        histograms.meta[i].lazyArray = new LazyArray(\n          { ...histograms.meta[i].arrayParams, readFile: this.readFile },\n          url,\n        )\n      }\n      refData._histograms = histograms\n    }\n\n    // parse any strings in the histogram data that look like numbers\n    if (refData._histograms) {\n      Object.keys(refData._histograms).forEach(key => {\n        const entries = refData._histograms[key]\n        entries.forEach(entry => {\n          Object.keys(entry).forEach(key2 => {\n            if (\n              typeof entry[key2] === 'string' &&\n              String(Number(entry[key2])) === entry[key2]\n            ) {\n              entry[key2] = Number(entry[key2])\n            }\n          })\n        })\n      })\n    }\n\n    return refData\n  }\n\n  async getRegionStats(query) {\n    const data = await this.getDataRoot(query.ref)\n    return data.stats\n  }\n\n  /**\n   * fetch binned counts of feature coverage in the given region.\n   *\n   * @param {object} query\n   * @param {string} query.refName reference sequence name\n   * @param {number} query.start region start\n   * @param {number} query.end region end\n   * @param {number} query.numBins number of bins desired in the feature counts\n   * @param {number} query.basesPerBin number of bp desired in each feature counting bin\n   * @returns {object} as:\n   *    `{ bins: hist, stats: statEntry }`\n   */\n  async getRegionFeatureDensities({\n    refName,\n    start,\n    end,\n    numBins,\n    basesPerBin,\n  }) {\n    const data = await this.getDataRoot(refName)\n    if (numBins) {\n      basesPerBin = (end - start) / numBins\n    } else if (basesPerBin) {\n      numBins = Math.ceil((end - start) / basesPerBin)\n    } else {\n      throw new TypeError(\n        'numBins or basesPerBin arg required for getRegionFeatureDensities',\n      )\n    }\n\n    // pick the relevant entry in our pre-calculated stats\n    const stats = data._histograms.stats || []\n    const statEntry = stats.find(entry => entry.basesPerBin >= basesPerBin)\n\n    // The histogramMeta array describes multiple levels of histogram detail,\n    // going from the finest (smallest number of bases per bin) to the\n    // coarsest (largest number of bases per bin).\n    // We want to use coarsest histogramMeta that's at least as fine as the\n    // one we're currently rendering.\n    // TODO: take into account that the histogramMeta chosen here might not\n    // fit neatly into the current histogram (e.g., if the current histogram\n    // is at 50,000 bases/bin, and we have server histograms at 20,000\n    // and 2,000 bases/bin, then we should choose the 2,000 histogramMeta\n    // rather than the 20,000)\n    let histogramMeta = data._histograms.meta[0]\n    for (let i = 0; i < data._histograms.meta.length; i += 1) {\n      if (basesPerBin >= data._histograms.meta[i].basesPerBin) {\n        histogramMeta = data._histograms.meta[i]\n      }\n    }\n\n    // number of bins in the server-supplied histogram for each current bin\n    let binRatio = basesPerBin / histogramMeta.basesPerBin\n\n    // if the server-supplied histogram fits neatly into our requested\n    if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {\n      // console.log('server-supplied',query);\n      // we can use the server-supplied counts\n      const firstServerBin = Math.floor(start / histogramMeta.basesPerBin)\n      binRatio = Math.round(binRatio)\n      const histogram = []\n      for (let bin = 0; bin < numBins; bin += 1) {\n        histogram[bin] = 0\n      }\n\n      for await (const [i, val] of histogramMeta.lazyArray.range(\n        firstServerBin,\n        firstServerBin + binRatio * numBins - 1,\n      )) {\n        // this will count features that span the boundaries of\n        // the original histogram multiple times, so it's not\n        // perfectly quantitative.  Hopefully it's still useful, though.\n        histogram[Math.floor((i - firstServerBin) / binRatio)] += val\n      }\n      return { bins: histogram, stats: statEntry }\n    }\n    // console.log('make own',query);\n    // make our own counts\n    const hist = await data.nclist.histogram(start, end, numBins)\n    return { bins: hist, stats: statEntry }\n  }\n\n  /**\n   * Fetch features in a given region. This method is an asynchronous generator\n   * yielding feature objects.\n   *\n   * @param {object} args\n   * @param {string} args.refName reference sequence name\n   * @param {number} args.start start of region. 0-based half-open.\n   * @param {number} args.end end of region. 0-based half-open.\n   * @yields {object}\n   */\n  async *getFeatures({ refName, start, end }) {\n    const data = await this.getDataRoot(refName)\n    const accessors = data.attrs && data.attrs.accessors()\n    for await (const [feature, path] of data.nclist.iterate(start, end)) {\n      // the unique ID is a stringification of the path in the\n      // NCList where the feature lives; it's unique across the\n      // top-level NCList (the top-level NCList covers a\n      // track/chromosome combination)\n\n      // only need to decorate a feature once\n      if (!feature.decorated) {\n        const uniqueID = path.join(',')\n        this.decorateFeature(accessors, feature, `${refName},${uniqueID}`)\n      }\n      yield feature\n    }\n  }\n\n  // helper method to recursively add .get and .tags methods to a feature and its\n  // subfeatures\n  decorateFeature(accessors, feature, id, parent) {\n    feature.get = accessors.get\n    feature.tags = accessors.tags\n    feature._uniqueID = id\n    feature.id = idfunc\n    feature._parent = parent\n    feature.parent = parentfunc\n    feature.children = childrenfunc\n    ;(feature.get('subfeatures') || []).forEach((f, i) => {\n      this.decorateFeature(accessors, f, `${id}-${i}`, feature)\n    })\n    feature.decorated = true\n  }\n}\n","//@ts-nocheck\nimport NCListStore from './feature_store'\n\nexport default NCListStore\n","export default function _OverloadYield(value, kind) {\n  this.v = value, this.k = kind;\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function _asyncGeneratorDelegate(inner) {\n  var iter = {},\n    waiting = !1;\n  function pump(key, value) {\n    return waiting = !0, value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    }), {\n      done: !1,\n      value: new OverloadYield(value, 1)\n    };\n  }\n  return iter[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  }, iter.next = function (value) {\n    return waiting ? (waiting = !1, value) : pump(\"next\", value);\n  }, \"function\" == typeof inner[\"throw\"] && (iter[\"throw\"] = function (value) {\n    if (waiting) throw waiting = !1, value;\n    return pump(\"throw\", value);\n  }), \"function\" == typeof inner[\"return\"] && (iter[\"return\"] = function (value) {\n    return waiting ? (waiting = !1, value) : pump(\"return\", value);\n  }), iter;\n}","export default function _asyncIterator(iterable) {\n  var method,\n    async,\n    sync,\n    retry = 2;\n  for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {\n    if (async && null != (method = iterable[async])) return method.call(iterable);\n    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));\n    async = \"@@asyncIterator\", sync = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return {\n        value: value,\n        done: done\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) {\n    this.s = s, this.n = s.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(value) {\n      var ret = this.s[\"return\"];\n      return void 0 === ret ? Promise.resolve({\n        value: value,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(value) {\n      var thr = this.s[\"return\"];\n      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(s);\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function _awaitAsyncGenerator(value) {\n  return new OverloadYield(value, 0);\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function AsyncGenerator(gen) {\n  var front, back;\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg),\n        value = result.value,\n        overloaded = value instanceof OverloadYield;\n      Promise.resolve(overloaded ? value.v : value).then(function (arg) {\n        if (overloaded) {\n          var nextKey = \"return\" === key ? \"return\" : \"next\";\n          if (!value.k || arg.done) return resume(nextKey, arg);\n          arg = gen[nextKey](arg).value;\n        }\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        front.reject(value);\n        break;\n      default:\n        front.resolve({\n          value: value,\n          done: !1\n        });\n    }\n    (front = front.next) ? resume(front.key, front.arg) : back = null;\n  }\n  this._invoke = function (key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n      back ? back = back.next = request : (front = back = request, resume(key, arg));\n    });\n  }, \"function\" != typeof gen[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n}, AsyncGenerator.prototype[\"throw\"] = function (arg) {\n  return this._invoke(\"throw\", arg);\n}, AsyncGenerator.prototype[\"return\"] = function (arg) {\n  return this._invoke(\"return\", arg);\n};","import AsyncGenerator from \"./AsyncGenerator.js\";\nexport default function _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}"],"names":["readJSON","url","readFile","options","defaultContent","encoding","str","JSON","parse","code","status","NCList","cacheSize","this","topList","chunkCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","readChunkItems","bind","Error","nclist","attrs","baseURL","lazyUrlTemplate","lazyClass","start","makeFastGetter","end","arr","item","getter","mid","low","high","length","chunkNum","nodeUrl","replace","from","to","inc","searchGet","testGet","path","getChunk","makeGetter","getSublist","pendingPromises","i","chunkItemsP","get","then","push","concat","sublist","iterateSublist","binarySearch","numBins","result","Array","binWidth","iterate","feat","firstBin","Math","max","lastBin","min","bin","classes","fields","cl","f","attributes","undefined","proto","isArrayAttr","attr","map","x","indexOf","toLowerCase","obj","lcattr","adhocIndex","val","set","indices","attrIndices","_accessors","_makeAccessors","accessors","field","field_accessors","call","tags","forEach","cdef","classnum","attrname","offset","c","Object","keys","LazyArray","baseUrl","urlTemplate","chunkSize","callback","param","range","firstChunk","floor","lastChunk","chunkreadFiles","chunk","chunkNumber","chunkData","filterChunkData","data","queryStart","queryEnd","firstIndex","chunkStart","chunkEnd","idfunc","_uniqueID","parentfunc","_parent","childrenfunc","NCListStore","urlTemplates","root","dataRootCache","fetchDataRoot","GenericNCList","refData","trackInfo","listUrl","importExisting","intervals","refName","parseTrackInfo","makeNCList","stats","featureCount","ArrayRepr","loadNCList","histograms","meta","lazyArray","arrayParams","_histograms","key","entry","key2","String","Number","query","getDataRoot","ref","basesPerBin","ceil","TypeError","statEntry","find","histogramMeta","binRatio","abs","round","firstServerBin","histogram","bins","hist","feature","decorated","uniqueID","join","decorateFeature","id","parent","children","_OverloadYield","value","kind","v","k","_asyncGeneratorDelegate","inner","iter","waiting","pump","Promise","resolve","done","Symbol","iterator","next","_asyncIterator","iterable","method","async","sync","retry","asyncIterator","AsyncFromSyncIterator","s","AsyncFromSyncIteratorContinuation","r","reject","n","prototype","apply","arguments","ret","thr","_awaitAsyncGenerator","AsyncGenerator","gen","front","back","resume","arg","overloaded","OverloadYield","nextKey","settle","err","type","_invoke","request","_wrapAsyncGenerator","fn"],"sourceRoot":""}