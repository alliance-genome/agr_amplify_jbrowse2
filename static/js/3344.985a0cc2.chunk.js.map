{"version":3,"file":"static/js/3344.985a0cc2.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","../../../plugins/alignments/src/BamAdapter/BamAdapter.ts","../../../plugins/alignments/src/HtsgetBamAdapter/HtsgetBamAdapter.ts"],"sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\nimport { BamRecord } from '@gmod/bam'\n\n// locals\nimport { getClip, getMismatches } from '../MismatchParser'\nimport BamAdapter from './BamAdapter'\n\nexport default class BamSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(\n    private record: BamRecord,\n    private adapter: BamAdapter,\n    private ref?: string,\n  ) {}\n\n  _get_name() {\n    return this.record.get('name')\n  }\n\n  _get_type(): string {\n    return 'match'\n  }\n\n  _get_score(): number {\n    return this.record.get('mq')\n  }\n\n  _get_flags(): string {\n    return this.record.flags\n  }\n\n  _get_strand(): number {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_next_ref() {\n    return this.record.isPaired()\n      ? this.adapter.refIdToName(this.record._next_refid())\n      : undefined\n  }\n\n  _get_next_pos() {\n    return this.record.isPaired() ? this.record._next_pos() : undefined\n  }\n\n  _get_next_segment_position() {\n    return this.record.isPaired()\n      ? `${this.adapter.refIdToName(this.record._next_refid())}:${\n          this.record._next_pos() + 1\n        }`\n      : undefined\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  qualRaw() {\n    return this.record.qualRaw()\n  }\n\n  set() {}\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      BamSlightlyLazyFeature.prototype,\n    )\n\n    return [\n      ...new Set(\n        properties\n          .filter(\n            prop =>\n              prop.startsWith('_get_') &&\n              prop !== '_get_mismatches' &&\n              prop !== '_get_tags',\n          )\n          .map(methodName => methodName.replace('_get_', ''))\n          .concat(this.record._tags()),\n      ),\n    ]\n  }\n\n  id() {\n    return `${this.adapter.id}-${this.record.id()}`\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(field: string): any {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) {\n      // @ts-ignore\n      return this[methodName]()\n    }\n    return this.record.get(field)\n  }\n\n  _get_refName() {\n    return this.adapter.refIdToName(this.record.seq_id())\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  pairedFeature() {\n    return false\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...Object.fromEntries(\n        this.tags()\n          .map(t => [t, this.get(t)])\n          .filter(elt => elt[1] !== undefined),\n      ),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_mismatches() {\n    return getMismatches(\n      this.get('CIGAR'),\n      this.get('MD'),\n      this.get('seq'),\n      this.ref,\n      this.qualRaw(),\n    )\n  }\n\n  _get_clipPos() {\n    const cigar = this.get('CIGAR') || ''\n    return getClip(cigar, this.get('strand'))\n  }\n}\n","import { BamFile } from '@gmod/bam'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { bytesForRegions, updateStatus, Feature } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\n\n// locals\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature'\nimport { firstValueFrom } from 'rxjs'\n\ninterface Header {\n  idToName: string[]\n  nameToId: Record<string, number>\n}\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  private samHeader?: Header\n\n  private setupP?: Promise<Header>\n  private configureP?: Promise<{\n    bam: BamFile\n    sequenceAdapter?: BaseFeatureDataAdapter\n  }>\n\n  // derived classes may not use the same configuration so a custom\n  // configure method allows derived classes to override this behavior\n  protected async configurePre() {\n    const bamLocation = this.getConf('bamLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n    const pm = this.pluginManager\n    const csi = indexType === 'CSI'\n    const bam = new BamFile({\n      bamFilehandle: openLocation(bamLocation, pm),\n      csiFilehandle: csi ? openLocation(location, pm) : undefined,\n      baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n\n      // chunkSizeLimit and fetchSizeLimit are more troublesome than\n      // helpful, and have given overly large values on the ultra long\n      // nanopore reads even with 500MB limits, so disabled with infinity\n      chunkSizeLimit: Infinity,\n      fetchSizeLimit: Infinity,\n      yieldThreadTime: Infinity,\n    })\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const { dataAdapter } = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n      }\n    } else {\n      return { bam }\n    }\n  }\n\n  protected async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch(e => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    return bam.getHeaderText(opts)\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const { bam } = await this.configure()\n    this.samHeader = await updateStatus(\n      'Downloading index',\n      statusCallback,\n      async () => {\n        const samHeader = await bam.getHeader(opts)\n\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref ref ID numbers and names\n        const idToName: string[] = []\n        const nameToId: Record<string, number> = {}\n        samHeader\n          .filter(l => l.tag === 'SQ')\n          .forEach((sqLine, refId) => {\n            sqLine.data.forEach(item => {\n              if (item.tag === 'SN') {\n                // this is the ref name\n                const refName = item.value\n                nameToId[refName] = refId\n                idToName[refId] = refName\n              }\n            })\n          })\n\n        return { idToName, nameToId }\n      },\n    )\n    return this.samHeader\n  }\n\n  async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  private async seqFetch(refName: string, start: number, end: number) {\n    const { sequenceAdapter } = await this.configure()\n    const refSeqStore = sequenceAdapter\n    if (!refSeqStore) {\n      return undefined\n    }\n    if (!refName) {\n      return undefined\n    }\n\n    const features = refSeqStore.getFeatures({\n      refName,\n      start,\n      end,\n      assemblyName: '',\n    })\n\n    const seqChunks = await firstValueFrom(features.pipe(toArray()))\n\n    let sequence = ''\n    seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .forEach(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        sequence += chunkSeq.substr(trimStart, trimLength)\n      })\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: {\n        flagInclude: number\n        flagExclude: number\n        tagFilter: { tag: string; value: unknown }\n        readName: string\n      }\n    },\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { signal, filterBy, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = await this.configure()\n      await this.setup(opts)\n      statusCallback('Downloading alignments')\n      const records = await bam.getRecordsForRange(refName, start, end, opts)\n\n      const {\n        flagInclude = 0,\n        flagExclude = 0,\n        tagFilter,\n        readName,\n      } = filterBy || {}\n\n      for (const record of records) {\n        let ref: string | undefined\n        if (!record.get('MD')) {\n          ref = await this.seqFetch(\n            originalRefName || refName,\n            record.get('start'),\n            record.get('end'),\n          )\n        }\n\n        const flags = record.flags\n        if (\n          !((flags & flagInclude) === flagInclude && !(flags & flagExclude))\n        ) {\n          continue\n        }\n\n        if (tagFilter) {\n          const val = record.get(tagFilter.tag)\n          if (!(val === '*' ? val !== undefined : val === tagFilter.value)) {\n            continue\n          }\n        }\n\n        if (readName && record.get('name') !== readName) {\n          continue\n        }\n\n        observer.next(new BamSlightlyLazyFeature(record, this, ref))\n      }\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  async estimateRegionsStats(regions: Region[], opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    // this is a method to avoid calling on htsget adapters\n    // @ts-ignore\n    if (bam.index.filehandle !== '?') {\n      const bytes = await bytesForRegions(regions, bam)\n      const fetchSizeLimit = this.getConf('fetchSizeLimit')\n      return { bytes, fetchSizeLimit }\n    } else {\n      return super.estimateRegionsStats(regions, opts)\n    }\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // depends on setup being called before the BAM constructor\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n}\n","import { BamFile, HtsgetFile } from '@gmod/bam'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport BamAdapter from '../BamAdapter/BamAdapter'\n\nexport default class HtsgetBamAdapter extends BamAdapter {\n  protected async configurePre() {\n    const htsgetBase = this.getConf('htsgetBase')\n    const htsgetTrackId = this.getConf('htsgetTrackId')\n    const bam = new HtsgetFile({\n      baseUrl: htsgetBase,\n      trackId: htsgetTrackId,\n    }) as unknown as BamFile\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const adapter = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: adapter.dataAdapter as BaseFeatureDataAdapter,\n      }\n    }\n    return { bam }\n  }\n}\n"],"names":["BamSlightlyLazyFeature","record","adapter","ref","this","get","flags","isReverseComplemented","isPaired","getPairOrientation","undefined","refIdToName","_next_refid","_next_pos","getReadBases","qualRaw","properties","Object","getOwnPropertyNames","prototype","Set","filter","prop","startsWith","map","methodName","replace","concat","_tags","id","field","seq_id","fromEntries","tags","t","elt","uniqueId","getMismatches","cigar","getClip","BamAdapter","samHeader","setupP","configureP","bamLocation","getConf","location","indexType","pm","pluginManager","csi","bam","BamFile","bamFilehandle","openLocation","csiFilehandle","baiFilehandle","chunkSizeLimit","Infinity","fetchSizeLimit","yieldThreadTime","adapterConfig","getSubAdapter","dataAdapter","sequenceAdapter","configurePre","catch","e","opts","configure","getHeaderText","statusCallback","updateStatus","getHeader","idToName","nameToId","l","tag","forEach","sqLine","refId","data","item","refName","value","setupPre","setup","start","end","refSeqStore","features","getFeatures","assemblyName","firstValueFrom","pipe","toArray","seqChunks","sequence","sort","a","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","chunkSeq","substr","length","Error","toLocaleString","region","originalRefName","signal","filterBy","ObservableCreate","observer","getRecordsForRange","records","flagInclude","flagExclude","tagFilter","readName","seqFetch","val","next","complete","regions","index","filehandle","bytesForRegions","bytes","BaseFeatureDataAdapter","HtsgetBamAdapter","htsgetBase","htsgetTrackId","HtsgetFile","baseUrl","trackId"],"sourceRoot":""}