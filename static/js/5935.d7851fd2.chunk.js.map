{"version":3,"file":"static/js/5935.d7851fd2.chunk.js","mappings":"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","sources":["../../../node_modules/@flatten-js/interval-tree/dist/main.esm.js","../../../node_modules/@gmod/bgzf-filehandle/src/unzip-pako.ts","../../../node_modules/@gmod/bgzf-filehandle/src/gziIndex.ts","../../../node_modules/@gmod/bgzf-filehandle/src/bgzFilehandle.ts"],"sourcesContent":["/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low == other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low == other_interval.low && this.high == other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ? other_interval.low : Math.min(this.low, other_interval.low),\n            this.high === undefined ? other_interval.high : Math.max(this.high, other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length == 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                this.item.key = new Interval(Math.min(key[0], key[1]), Math.max(key[0], key[1]));\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value == other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root == this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return this.tree_search(this.root, search_node) ? true : false;\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        let found = this.tree_find_any_interval(this.root, search_node);\n        return found;\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /**\n     * Value Mapper. Walk through every node and map node value to another value\n     * @param callback(value,key) - function to be called for each tree item\n     */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    /**\n     * @param {Interval} interval - optional if the iterator is intended to start from the beginning\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Iterator}\n     */\n    *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let node;\n        if (interval) {\n            node = this.tree_search_nearest_forward(this.root, new Node(interval));\n        } else if (this.root) {\n            node = this.local_minimum(this.root);\n        }\n        while (node) {\n            yield outputMapperFn(node.item.value, node.item.key);\n            node = this.tree_successor(node);\n        }\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root == this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node != this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node != this.root && current_node.parent.color == RB_TREE_COLOR_RED) {\n            if (current_node.parent == current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node == current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color == RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node == current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left == this.nil_node || delete_node.right == this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left != this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node == this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node == cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node != delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color == RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node != this.root && current_node.parent != null && current_node.color == RB_TREE_COLOR_BLACK) {\n            if (current_node == current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color == RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color == RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color == RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color == RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node == this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    tree_search_nearest_forward(node, search_node) {\n        let best;\n        let curr = node;\n        while (curr && curr != this.nil_node) {\n            if (curr.less_than(search_node)) {\n                if (curr.intersect(search_node)) {\n                    best = curr;\n                    curr = curr.left;\n                } else {\n                    curr = curr.right;\n                }\n            } else {\n                if (!best || curr.less_than(best)) best = curr;\n                curr = curr.left;\n            }\n        }\n        return best || null;\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node != this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left != this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (!found && node.right != this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left != this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right != this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right != this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right == current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left != this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x == this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x == x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right != this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y == this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y == y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y != null && y != this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x != this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node != this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color == RB_TREE_COLOR_RED) {\n                if (!(node.left.color == RB_TREE_COLOR_BLACK && node.right.color == RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color == RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left != this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right != this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft != heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    }\n}\n\nexport { Interval, Node, IntervalTree as default };\n","import { Buffer } from 'buffer'\n//@ts-ignore\nimport { Z_SYNC_FLUSH, Inflate } from 'pako'\n\ninterface VirtualOffset {\n  blockPosition: number\n  dataPosition: number\n}\ninterface Chunk {\n  minv: VirtualOffset\n  maxv: VirtualOffset\n}\n\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than\n// one bgzf block, so export an unzip function that uses pako directly\n// if we are running in a browser.\nasync function unzip(inputData: Buffer) {\n  try {\n    let strm\n    let pos = 0\n    let i = 0\n    const chunks = []\n    let totalSize = 0\n    let inflator\n    do {\n      const remainingInput = inputData.subarray(pos)\n      inflator = new Inflate()\n      //@ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      pos += strm.next_in\n      chunks[i] = inflator.result as Uint8Array\n      totalSize += chunks[i].length\n      i += 1\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    return Buffer.from(result)\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to pakounzip, except it does extra counting\n// to return the positions of compressed and decompressed\n// data offsets\nasync function unzipChunk(inputData: Buffer) {\n  try {\n    let strm\n    let cpos = 0\n    let dpos = 0\n    const blocks = []\n    const cpositions = []\n    const dpositions = []\n    do {\n      const remainingInput = inputData.slice(cpos)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = Buffer.from(inflator.result)\n      blocks.push(buffer)\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n\n      cpos += strm.next_in\n      dpos += buffer.length\n    } while (strm.avail_in)\n\n    const buffer = Buffer.concat(blocks)\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to unzipChunk above but slices (0,minv.dataPosition) and\n// (maxv.dataPosition,end) off\nasync function unzipChunkSlice(inputData: Buffer, chunk: Chunk) {\n  try {\n    let strm\n    const { minv, maxv } = chunk\n    let cpos = minv.blockPosition\n    let dpos = minv.dataPosition\n    const chunks = []\n    const cpositions = []\n    const dpositions = []\n\n    let totalSize = 0\n    let i = 0\n    do {\n      const remainingInput = inputData.subarray(cpos - minv.blockPosition)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = inflator.result\n      chunks.push(buffer as Uint8Array)\n      let len = buffer.length\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n      if (chunks.length === 1 && minv.dataPosition) {\n        // this is the first chunk, trim it\n        chunks[0] = chunks[0].subarray(minv.dataPosition)\n        len = chunks[0].length\n      }\n      const origCpos = cpos\n      cpos += strm.next_in\n      dpos += len\n\n      if (origCpos >= maxv.blockPosition) {\n        // this is the last chunk, trim it and stop decompressing\n        // note if it is the same block is minv it subtracts that already\n        // trimmed part of the slice length\n\n        chunks[i] = chunks[i].subarray(\n          0,\n          maxv.blockPosition === minv.blockPosition\n            ? maxv.dataPosition - minv.dataPosition + 1\n            : maxv.dataPosition + 1,\n        )\n\n        cpositions.push(cpos)\n        dpositions.push(dpos)\n        totalSize += chunks[i].length\n        break\n      }\n      totalSize += chunks[i].length\n      i++\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    const buffer = Buffer.from(result)\n\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\nfunction nodeUnzip() {\n  throw new Error('nodeUnzip not implemented.')\n}\n\nexport { unzip, unzipChunk, unzipChunkSlice, unzip as pakoUnzip, nodeUnzip }\n","import Long from 'long'\nimport { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// const COMPRESSED_POSITION = 0\nconst UNCOMPRESSED_POSITION = 1\n\nexport default class GziIndex {\n  filehandle: GenericFilehandle\n\n  index?: any\n\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n  }\n\n  _readLongWithOverflow(buf: Buffer, offset = 0, unsigned = true) {\n    //@ts-ignore\n    const long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned)\n    if (\n      long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n      long.lessThan(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new TypeError('integer overflow')\n    }\n\n    return long.toNumber()\n  }\n\n  _getIndex() {\n    if (!this.index) {\n      this.index = this._readIndex()\n    }\n    return this.index\n  }\n\n  async _readIndex() {\n    let buf = Buffer.allocUnsafe(8)\n    await this.filehandle.read(buf, 0, 8, 0)\n    const numEntries = this._readLongWithOverflow(buf, 0, true)\n    if (!numEntries) {\n      return [[0, 0]]\n    }\n\n    const entries = new Array(numEntries + 1)\n    entries[0] = [0, 0]\n\n    // TODO rewrite this to make an index-index that stays in memory\n    const bufSize = 8 * 2 * numEntries\n    if (bufSize > Number.MAX_SAFE_INTEGER) {\n      throw new TypeError('integer overflow')\n    }\n    buf = Buffer.allocUnsafe(bufSize)\n    await this.filehandle.read(buf, 0, bufSize, 8)\n    for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n      const compressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16,\n      )\n      const uncompressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16 + 8,\n      )\n      entries[entryNumber + 1] = [compressedPosition, uncompressedPosition]\n    }\n\n    return entries\n  }\n\n  async getLastBlock() {\n    const entries = await this._getIndex()\n    if (!entries.length) {\n      return undefined\n    }\n    return entries[entries.length - 1]\n  }\n\n  async getRelevantBlocksForRead(length: number, position: number) {\n    const endPosition = position + length\n    if (length === 0) {\n      return []\n    }\n    const entries = await this._getIndex()\n    const relevant = []\n\n    // binary search to find the block that the\n    // read starts in and extend forward from that\n    const compare = (entry: any, nextEntry: any) => {\n      const uncompressedPosition = entry[UNCOMPRESSED_POSITION]\n      const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity\n      // block overlaps read start\n      if (\n        uncompressedPosition <= position &&\n        nextUncompressedPosition > position\n      ) {\n        return 0\n        // block is before read start\n      }\n      if (uncompressedPosition < position) {\n        return -1\n      }\n      // block is after read start\n      return 1\n    }\n\n    let lowerBound = 0\n    let upperBound = entries.length - 1\n    let searchPosition = Math.floor(entries.length / 2)\n\n    let comparison = compare(\n      entries[searchPosition],\n      entries[searchPosition + 1],\n    )\n    while (comparison !== 0) {\n      if (comparison > 0) {\n        upperBound = searchPosition - 1\n      } else if (comparison < 0) {\n        lowerBound = searchPosition + 1\n      }\n      searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound\n      comparison = compare(entries[searchPosition], entries[searchPosition + 1])\n    }\n\n    // here's where we read forward\n    relevant.push(entries[searchPosition])\n    let i = searchPosition + 1\n    for (; i < entries.length; i += 1) {\n      relevant.push(entries[i])\n      if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n        break\n      }\n    }\n    if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n      relevant.push([])\n    }\n    return relevant\n  }\n}\n","import { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// locals\nimport { unzip } from './unzip'\nimport GziIndex from './gziIndex'\n\nexport default class BgzFilehandle {\n  filehandle: GenericFilehandle\n  gzi: GziIndex\n\n  constructor({\n    filehandle,\n    path,\n    gziFilehandle,\n    gziPath,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n    gziFilehandle?: GenericFilehandle\n    gziPath?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n\n    if (!gziFilehandle && !gziPath && !path) {\n      throw new TypeError('either gziFilehandle or gziPath must be defined')\n    }\n\n    this.gzi = new GziIndex({\n      filehandle: gziFilehandle,\n      path: !gziFilehandle && !gziPath && path ? gziPath : `${path}.gzi`,\n    })\n  }\n\n  async stat() {\n    const compressedStat = await this.filehandle.stat()\n    return Object.assign(compressedStat, {\n      size: await this.getUncompressedFileSize(),\n      blocks: undefined,\n      blksize: undefined,\n    })\n  }\n\n  async getUncompressedFileSize() {\n    // read the last block's ISIZE (see gzip RFC),\n    // and add it to its uncompressedPosition\n    const [, uncompressedPosition] = await this.gzi.getLastBlock()\n\n    const { size } = await this.filehandle.stat()\n\n    const buf = Buffer.allocUnsafe(4)\n    // note: there should be a 28-byte EOF marker (an empty block) at\n    // the end of the file, so we skip backward past that\n    const { bytesRead } = await this.filehandle.read(buf, 0, 4, size - 28 - 4)\n    if (bytesRead !== 4) {\n      throw new Error('read error')\n    }\n    const lastBlockUncompressedSize = buf.readUInt32LE(0)\n    return uncompressedPosition + lastBlockUncompressedSize\n  }\n\n  async _readAndUncompressBlock(\n    blockBuffer: Buffer,\n    [compressedPosition]: [number],\n    [nextCompressedPosition]: [number],\n  ) {\n    let next = nextCompressedPosition\n    if (!next) {\n      next = (await this.filehandle.stat()).size\n    }\n\n    // read the compressed data into the block buffer\n    const blockCompressedLength = next - compressedPosition\n\n    await this.filehandle.read(\n      blockBuffer,\n      0,\n      blockCompressedLength,\n      compressedPosition,\n    )\n\n    // uncompress it\n    const unzippedBuffer = await unzip(\n      blockBuffer.slice(0, blockCompressedLength),\n    )\n\n    return unzippedBuffer as Buffer\n  }\n\n  async read(buf: Buffer, offset: number, length: number, position: number) {\n    // get the block positions for this read\n    const blockPositions = await this.gzi.getRelevantBlocksForRead(\n      length,\n      position,\n    )\n    const blockBuffer = Buffer.allocUnsafe(32768 * 2)\n    // uncompress the blocks and read from them one at a time to keep memory usage down\n    let destinationOffset = offset\n    let bytesRead = 0\n    for (\n      let blockNum = 0;\n      blockNum < blockPositions.length - 1;\n      blockNum += 1\n    ) {\n      // eslint-disable-next-line no-await-in-loop\n      const uncompressedBuffer = await this._readAndUncompressBlock(\n        blockBuffer,\n        blockPositions[blockNum],\n        blockPositions[blockNum + 1],\n      )\n      const [, uncompressedPosition] = blockPositions[blockNum]\n      const sourceOffset =\n        uncompressedPosition >= position ? 0 : position - uncompressedPosition\n      const sourceEnd =\n        Math.min(\n          position + length,\n          uncompressedPosition + uncompressedBuffer.length,\n        ) - uncompressedPosition\n      if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n        uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd)\n        destinationOffset += sourceEnd - sourceOffset\n        bytesRead += sourceEnd - sourceOffset\n      }\n    }\n\n    return { bytesRead, buffer: buf }\n  }\n}\n"],"names":["Interval","constructor","low","high","this","clone","max","less_than","other_interval","equal_to","intersect","not_intersect","merge","undefined","Math","min","output","comparable_max","interval1","interval2","comparable_less_than","val1","val2","Node","key","value","left","right","parent","color","item","Array","length","Number","isNaN","isNil","_value_less_than","other_node","_value_equal","copy_data","update_max","not_intersect_left_subtree","search_node","not_intersect_right_subtree","IntervalTree","root","nil_node","size","count","tree_walk","keys","res","node","push","values","items","isEmpty","clear","insert","insert_node","tree_insert","recalc_max","exist","tree_search","remove","delete_node","tree_delete","search","interval","outputMapperFn","resp_nodes","tree_search_interval","map","intersect_any","tree_find_any_interval","forEach","visitor","callback","tree","iterate","tree_search_nearest_forward","local_minimum","tree_successor","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","delete_fixup","brother_node","best","curr","found","node_min","local_maximum","node_max","node_successor","x","y","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","heightRight","Error","async","unzip","inputData","strm","pos","i","chunks","inflator","totalSize","remainingInput","subarray","Inflate","Z_SYNC_FLUSH","err","msg","next_in","result","avail_in","Uint8Array","offset","set","Buffer","from","e","match","unzipChunkSlice","chunk","minv","maxv","cpos","blockPosition","dpos","dataPosition","cpositions","dpositions","buffer","len","origCpos","GziIndex","filehandle","path","TypeError","_readLongWithOverflow","buf","unsigned","long","slice","greaterThan","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","_getIndex","index","_readIndex","allocUnsafe","read","numEntries","entries","bufSize","entryNumber","compressedPosition","uncompressedPosition","getLastBlock","getRelevantBlocksForRead","position","endPosition","relevant","compare","entry","nextEntry","nextUncompressedPosition","Infinity","lowerBound","upperBound","searchPosition","floor","comparison","ceil","BgzFilehandle","gziFilehandle","gziPath","gzi","stat","compressedStat","Object","assign","getUncompressedFileSize","blocks","blksize","bytesRead","readUInt32LE","_readAndUncompressBlock","blockBuffer","nextCompressedPosition","next","blockCompressedLength","blockPositions","destinationOffset","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","copy"],"sourceRoot":""}