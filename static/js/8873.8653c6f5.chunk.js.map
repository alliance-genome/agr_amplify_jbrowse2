{"version":3,"file":"static/js/8873.8653c6f5.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  FileLocation,\n  NoAssemblyRegion,\n  Region,\n} from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { bytesForRegions } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport VcfParser from '@gmod/vcf'\nimport { Observer } from 'rxjs'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport VcfFeature from './VcfFeature'\nimport { GenericFilehandle } from 'generic-filehandle'\n\nexport default class extends BaseFeatureDataAdapter {\n  private configured?: Promise<{\n    filehandle: GenericFilehandle\n    vcf: TabixIndexedFile\n    parser: VcfParser\n  }>\n\n  private async configurePre() {\n    const vcfGzLocation = readConfObject(this.config, 'vcfGzLocation')\n    const location = readConfObject(this.config, ['index', 'location'])\n    const indexType = readConfObject(this.config, ['index', 'indexType'])\n\n    const filehandle = openLocation(\n      vcfGzLocation as FileLocation,\n      this.pluginManager,\n    )\n    const isCSI = indexType === 'CSI'\n    const vcf = new TabixIndexedFile({\n      filehandle,\n      csiFilehandle: isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      tbiFilehandle: !isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n      chunkSizeLimit: 1000000000,\n    })\n\n    const header = await vcf.getHeader()\n    return {\n      filehandle,\n      vcf,\n      parser: new VcfParser({ header }),\n    }\n  }\n\n  protected async configure() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch(e => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure()\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    const { vcf } = await this.configure()\n    return vcf.getHeader()\n  }\n\n  async getMetadata() {\n    const { parser } = await this.configure()\n    return parser.getMetadata()\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { vcf, parser } = await this.configure()\n      await vcf.getLines(refName, start, end, {\n        lineCallback: (line: string, fileOffset: number) => {\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(line),\n              parser,\n              id: `${this.id}-vcf-${fileOffset}`,\n            }),\n          )\n        },\n        ...opts,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  /**\n   * Checks if the data source has data for the given reference sequence,\n   * and then gets the features in the region if it does\n   *\n   * Currently this just calls getFeatureInRegion for each region. Adapters that\n   * are frequently called on multiple regions simultaneously may want to\n   * implement a more efficient custom version of this method.\n   *\n   * Also includes a bit of extra logging to warn when fetching a large portion\n   * of a VCF\n   * @param regions - Regions\n   * @param opts - Feature adapter options\n   * @returns Observable of Feature objects in the regions\n   */\n  public getFeaturesInMultipleRegions(\n    regions: Region[],\n    opts: BaseOptions = {},\n  ) {\n    // TODO: restore commented version below once TSDX supports Rollup v2\n    // xref: https://github.com/rollup/rollup/blob/master/CHANGELOG.md#bug-fixes-45\n    const superGetFeaturesInMultipleRegions = super.getFeaturesInMultipleRegions\n    return ObservableCreate<Feature>(async (observer: Observer<Feature>) => {\n      const { vcf } = await this.configure()\n\n      // @ts-ignore\n      const bytes = await bytesForRegions(regions, vcf.index)\n      const { filehandle } = await this.configure()\n      const stat = await filehandle.stat()\n      let pct = Math.round((bytes / stat.size) * 100)\n      if (pct > 100) {\n        // this is just a bad estimate, make 100% if it goes over\n        pct = 100\n      }\n      if (pct > 60) {\n        console.warn(\n          `getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`,\n        )\n      }\n      superGetFeaturesInMultipleRegions\n        .call(this, regions, opts)\n        .subscribe(observer)\n      // super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer)\n    })\n  }\n\n  public freeResources(/* { region } */): void {}\n}\n"],"names":["configured","vcfGzLocation","readConfObject","this","config","location","indexType","filehandle","openLocation","pluginManager","isCSI","vcf","TabixIndexedFile","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","chunkSizeLimit","getHeader","header","parser","VcfParser","configurePre","catch","e","opts","configure","getReferenceSequenceNames","getMetadata","query","ObservableCreate","observer","refName","start","end","getLines","lineCallback","line","fileOffset","next","VcfFeature","variant","parseLine","id","complete","signal","regions","superGetFeaturesInMultipleRegions","bytesForRegions","index","bytes","stat","pct","Math","round","size","console","warn","call","subscribe","BaseFeatureDataAdapter"],"sourceRoot":""}