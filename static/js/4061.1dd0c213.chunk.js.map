{"version":3,"file":"static/js/4061.1dd0c213.chunk.js","mappings":"kGAAA,SAASA,EAAmBC,EAAKC,EAASC,EAAQC,EAAOC,EAAQC,EAAKC,GACpE,IACE,IAAIC,EAAOP,EAAIK,GAAKC,GAChBE,EAAQD,EAAKC,MACjB,MAAOC,GAEP,YADAP,EAAOO,GAILF,EAAKG,KACPT,EAAQO,GAERG,QAAQV,QAAQO,GAAOI,KAAKT,EAAOC,GAwBvCS,EAAOC,QApBP,SAA2BC,GACzB,OAAO,WACL,IAAIC,EAAOC,KACPC,EAAOC,UACX,OAAO,IAAIR,SAAQ,SAAUV,EAASC,GACpC,IAAIF,EAAMe,EAAGK,MAAMJ,EAAME,GAEzB,SAASf,EAAMK,GACbT,EAAmBC,EAAKC,EAASC,EAAQC,EAAOC,EAAQ,OAAQI,GAGlE,SAASJ,EAAOiB,GACdtB,EAAmBC,EAAKC,EAASC,EAAQC,EAAOC,EAAQ,QAASiB,GAGnElB,OAAMmB,QAKwBT,EAAOC,QAAQS,YAAa,EAAMV,EAAOC,QAAiB,QAAID,EAAOC,S,sBCpCzG,IAAIU,EAAiB,EAAQ,OAE7B,SAASC,EAAQC,EAAQC,GACvB,IAAIC,EAAOC,OAAOD,KAAKF,GAEvB,GAAIG,OAAOC,sBAAuB,CAChC,IAAIC,EAAUF,OAAOC,sBAAsBJ,GAC3CC,IAAmBI,EAAUA,EAAQC,QAAO,SAAUC,GACpD,OAAOJ,OAAOK,yBAAyBR,EAAQO,GAAKE,eACjDP,EAAKQ,KAAKhB,MAAMQ,EAAMG,GAG7B,OAAOH,EAgBTf,EAAOC,QAbP,SAAwBuB,GACtB,IAAK,IAAIC,EAAI,EAAGA,EAAInB,UAAUoB,OAAQD,IAAK,CACzC,IAAIE,EAAS,MAAQrB,UAAUmB,GAAKnB,UAAUmB,GAAK,GACnDA,EAAI,EAAIb,EAAQI,OAAOW,IAAS,GAAIC,SAAQ,SAAUpC,GACpDmB,EAAea,EAAQhC,EAAKmC,EAAOnC,OAChCwB,OAAOa,0BAA4Bb,OAAOc,iBAAiBN,EAAQR,OAAOa,0BAA0BF,IAAWf,EAAQI,OAAOW,IAASC,SAAQ,SAAUpC,GAC5JwB,OAAOL,eAAea,EAAQhC,EAAKwB,OAAOK,yBAAyBM,EAAQnC,OAI/E,OAAOgC,GAGwBxB,EAAOC,QAAQS,YAAa,EAAMV,EAAOC,QAAiB,QAAID,EAAOC,S,sBC5BtG,IAAI8B,EAA+B,EAAQ,OAqB3C/B,EAAOC,QAnBP,SAAkC0B,EAAQK,GACxC,GAAc,MAAVL,EAAgB,MAAO,GAC3B,IACInC,EAAKiC,EADLD,EAASO,EAA6BJ,EAAQK,GAGlD,GAAIhB,OAAOC,sBAAuB,CAChC,IAAIgB,EAAmBjB,OAAOC,sBAAsBU,GAEpD,IAAKF,EAAI,EAAGA,EAAIQ,EAAiBP,OAAQD,IACvCjC,EAAMyC,EAAiBR,GACnBO,EAASE,QAAQ1C,IAAQ,GACxBwB,OAAOmB,UAAUC,qBAAqBC,KAAKV,EAAQnC,KACxDgC,EAAOhC,GAAOmC,EAAOnC,IAIzB,OAAOgC,GAGkCxB,EAAOC,QAAQS,YAAa,EAAMV,EAAOC,QAAiB,QAAID,EAAOC,S,kBCNhHD,EAAOC,QAfP,SAAuC0B,EAAQK,GAC7C,GAAc,MAAVL,EAAgB,MAAO,GAC3B,IAEInC,EAAKiC,EAFLD,EAAS,GACTc,EAAatB,OAAOD,KAAKY,GAG7B,IAAKF,EAAI,EAAGA,EAAIa,EAAWZ,OAAQD,IACjCjC,EAAM8C,EAAWb,GACbO,EAASE,QAAQ1C,IAAQ,IAC7BgC,EAAOhC,GAAOmC,EAAOnC,IAGvB,OAAOgC,GAGuCxB,EAAOC,QAAQS,YAAa,EAAMV,EAAOC,QAAiB,QAAID,EAAOC,S,6ECdrHe,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,I,IAEhD4C,EAAAA,WAOF,WAAYC,EAAMC,EAAMC,GAA8B,IAAzBC,EAAyB,4DAAXlC,EAAW,UAClDL,KAAKoC,KAAOA,EACZpC,KAAKqC,KAAOA,EACZrC,KAAKsC,IAAMA,EACXtC,KAAKwC,aAAeD,E,wCAExB,WACI,gBAAUvC,KAAKoC,KAAf,aAAwBpC,KAAKqC,KAA7B,iBAA0CrC,KAAKsC,IAA/C,yBAAmEtC,KAAKuC,cAAxE,O,sBAEJ,WACI,OAAOvC,KAAKyC,mB,uBAEhB,SAAUC,GACN,OAAQ1C,KAAKoC,KAAKO,UAAUD,EAAEN,OAC1BpC,KAAKqC,KAAKM,UAAUD,EAAEL,OACtBrC,KAAKsC,IAAMI,EAAEJ,M,yBAErB,WACI,YAA0BjC,IAAtBL,KAAKwC,aACExC,KAAKwC,aAETxC,KAAKqC,KAAKO,cAAV,MAAsC5C,KAAKoC,KAAKQ,kB,EA5BzDT,GA+BNtC,EAAAA,QAAkBsC,G,0MCjCdU,EAAmB7C,MAAQA,KAAK6C,kBAAqBjC,OAAOkC,OAAU,SAASC,EAAGC,EAAGC,EAAGC,QAC7E7C,IAAP6C,IAAkBA,EAAKD,GAC3BrC,OAAOL,eAAewC,EAAGG,EAAI,CAAEhC,YAAY,EAAMiC,IAAK,WAAa,OAAOH,EAAEC,OAC1E,SAASF,EAAGC,EAAGC,EAAGC,QACT7C,IAAP6C,IAAkBA,EAAKD,GAC3BF,EAAEG,GAAMF,EAAEC,KAEVG,EAAsBpD,MAAQA,KAAKoD,qBAAwBxC,OAAOkC,OAAU,SAASC,EAAGM,GACxFzC,OAAOL,eAAewC,EAAG,UAAW,CAAE7B,YAAY,EAAM3B,MAAO8D,KAC9D,SAASN,EAAGM,GACbN,EAAC,QAAcM,IAEfC,EAAgBtD,MAAQA,KAAKsD,cAAiB,SAAUC,GACxD,GAAIA,GAAOA,EAAIjD,WAAY,OAAOiD,EAClC,IAAIC,EAAS,GACb,GAAW,MAAPD,EAAa,IAAK,IAAIN,KAAKM,EAAe,YAANN,GAAmBrC,OAAOmB,UAAU0B,eAAexB,KAAKsB,EAAKN,IAAIJ,EAAgBW,EAAQD,EAAKN,GAEtI,OADAG,EAAmBI,EAAQD,GACpBC,GAEPE,EAAmB1D,MAAQA,KAAK0D,iBAAoB,SAAUH,GAC9D,OAAQA,GAAOA,EAAIjD,WAAciD,EAAM,CAAE,QAAWA,IAExD3C,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtD,IAAMoE,EAASD,EAAgBE,EAAQ,QACjCC,EAAoBD,EAAQ,OAC5BE,EAAkBR,EAAaM,EAAQ,QACvCG,EAAUL,EAAgBE,EAAQ,QAClCI,EAASJ,EAAQ,MACjBK,EAAcP,EAAgBE,EAAQ,QACtCM,EAAa,SACbC,EAAa,SAInB,SAASC,EAAOC,EAAKC,GACjB,OAAOC,KAAKC,MAAMH,EAAM,KAAH,IAAG,EAAKC,I,IAE3BG,EAAAA,SAAAA,G,kBACF,WAAYxE,GAAM,wBACd,cAAMA,IACDyE,aAAe,EACpB,EAAKC,MAAQ,EACb,EAAKC,SAAW,EAJF,E,8DAMlB,WAAgBC,GAAhB,8FAAyBC,EAAzB,+BAAgC,GAAhC,SAC4B9E,KAAK+E,MAAMD,GADvC,UACUE,EADV,iDAGgB,GAHhB,UAKUC,EAAQD,EAAUE,YAAYL,GACxBG,EAAUG,QAAQF,GANlC,2CAQgB,GARhB,aAUYG,EAAUJ,EAAUG,QAAQF,GAA5BG,OAVZ,0CAYeA,EAAMC,WAZrB,kCAcY,GAdZ,iD,wGAgBA,kFACU,IAAIC,MAAM,uCADpB,2C,gFAIA,SAAaC,EAAOC,EAAQC,GACxB,GAAIA,EAAY,GACZ,MAAO,CACHC,YAAa,GACbR,YAAa,IAGrB,IAAMS,EAAcJ,EAAMK,YAAYJ,GAChCK,EAA+B,MAAdF,EAAwB,uBAAyB,iBAClEG,EAAS,CAAE,EAAG,UAAW,EAAG,MAAO,EAAG,OAAsB,GAAdH,GACpD,IAAKG,EACD,MAAM,IAAIR,MAAJ,4CAA+CK,IAEzD,IAAMI,EAAgB,CAClBC,IAAKT,EAAMK,YAAYJ,EAAS,GAChCS,MAAOV,EAAMK,YAAYJ,EAAS,GAClCU,IAAKX,EAAMK,YAAYJ,EAAS,KAE9BW,EAAYZ,EAAMK,YAAYJ,EAAS,IACvCY,EAAWD,EAAYE,OAAOC,aAAaH,GAAa,GACxDI,EAAYhB,EAAMK,YAAYJ,EAAS,IACvCgB,EAAoBjB,EAAMK,YAAYJ,EAAS,IACrD,EAAqCxF,KAAKyG,gBAAgBlB,EAAMmB,MAAMlB,EAAS,GAAIA,EAAS,GAAKgB,IACjG,MAAO,CACHd,YAFJ,EAAQA,YAGJR,YAHJ,EAAqBA,YAIjBqB,UAAAA,EACAH,SAAAA,EACAL,cAAAA,EACAD,OAAAA,EACAD,eAAAA,K,6BAGR,SAAgBc,GAKZ,IAJA,IAAIC,EAAY,EACZC,EAAgB,EACdnB,EAAc,GACdR,EAAc,GACX7D,EAAI,EAAGA,EAAIsF,EAAWrF,OAAQD,GAAK,EACxC,IAAKsF,EAAWtF,GAAI,CAChB,GAAIwF,EAAgBxF,EAAG,CACnB,IAAIwD,EAAU8B,EAAWG,SAAS,OAAQD,EAAexF,GACzDwD,EAAU7E,KAAK+G,aAAalC,GAC5Ba,EAAYkB,GAAa/B,EACzBK,EAAYL,GAAW+B,EAE3BC,EAAgBxF,EAAI,EACpBuF,GAAa,EAGrB,MAAO,CAAE1B,YAAAA,EAAaQ,YAAAA,K,+CAG1B,8HAAaZ,EAAb,+BAAoB,GAApB,KAC4BjB,EAAkBmD,MAD9C,SAC4DhH,KAAKiH,WAAWC,SAASpC,GADrF,6DACUS,EADV,QAIc4B,aAAa,KAAOjD,EAJlC,iBAKQkD,EAAa,EALrB,2BAOa7B,EAAM4B,aAAa,KAAOhD,EAPvC,iBAQQiD,EAAa,EARrB,8BAWc,IAAI9B,MAAM,kBAXxB,eAcItF,KAAK4E,SAAWW,EAAMK,YAAY,GAClC5F,KAAK2E,MAAQY,EAAMK,YAAY,GAC/B5F,KAAK0E,eAAiB,GAAyB,GAAlB1E,KAAK2E,MAAQ,IAAW,GAAK,EACpD0C,EAjBV,SAiByB,EAAMrH,KAAK4E,SAAwB,EAAb5E,KAAK2E,OAC1Cc,EAAYF,EAAMK,YAAY,IAChC0B,EAAM,CACN5B,YAAa,GACbR,YAAa,IAEbO,IACA6B,EAAMtH,KAAKuH,aAAahC,EAAO,GAAIE,IAEjC+B,EAAWjC,EAAMK,YAAY,GAAKH,GAGpCgC,EAAa,GAAKhC,EAAY,EAC5BN,EAAU,IAAIuC,MAAMF,GAAUG,KAAK,GAAGC,KAAI,WAE5C,IAAMC,EAAWtC,EAAMK,YAAY6B,GACnCA,GAAc,EAGd,IAFA,IACIrC,EADE0C,EAAW,GAERC,EAAI,EAAGA,EAAIF,EAAUE,GAAK,EAAG,CAClC,IAAMzF,EAAMiD,EAAM4B,aAAaM,GAC/B,GAAInF,EAAM,EAAKoC,aAGXU,EAAQ,EAAK4C,eAAezC,EAAOkC,EAAa,GAChDA,GAAc,OAEb,CACD,IAAMQ,GAAU,EAAInE,EAAgBoE,WAAW3C,EAAOkC,EAAa,GACnEU,EAAgB,EAAKC,eAAeD,EAAeF,GACnD,IAAMI,EAAa9C,EAAMK,YAAY6B,EAAa,IAClDA,GAAc,GAEd,IADA,IAAMa,EAAS,IAAIZ,MAAMW,GAChBpF,EAAI,EAAGA,EAAIoF,EAAYpF,GAAK,EAAG,CACpC,IAAMsF,GAAI,EAAIzE,EAAgBoE,WAAW3C,EAAOkC,GAC1CpE,GAAI,EAAIS,EAAgBoE,WAAW3C,EAAOkC,EAAa,GAC7DA,GAAc,GAEda,EAAOrF,GAAK,IAAIc,EAAQyE,QAAQD,EAAGlF,EAAGf,GAE1CwF,EAASxF,GAAOgG,GAGxB,MAAO,CAAER,SAAAA,EAAU1C,MAAAA,MA5D3B,yBA+DWkC,GA/DX,IAgEQmB,KAAK,EACLjB,SAAAA,EACAkB,aAAc,MACdP,cAAAA,EACAf,WAAAA,EACAjC,QAAAA,EACAR,MAAO3E,KAAK2E,MACZD,aAAc1E,KAAK0E,aACnB2C,aAAAA,KAxER,iD,kFA2EA,SAAe9B,EAAOC,GAElB,MAAO,CAAEH,WADS,EAAIrB,EAAO2E,cAAchF,EAAO6E,QAAQI,YAAYlB,MAAM3F,UAAU2E,MAAMzE,KAAKsD,EAAOC,EAAS,GAAIA,EAAS,KAAK,O,uDAGvI,WAAqBX,EAASgE,EAAKC,GAAnC,kHAAwChE,EAAxC,+BAA+C,GACvC+D,EAAM,IACNA,EAAM,GAFd,SAI4B7I,KAAK+E,MAAMD,GAJvC,UAIUE,EAJV,gDAMe,IANf,UAQUC,EAAQD,EAAUE,YAAYL,GAC9BkE,EAAK/D,EAAUG,QAAQF,GATjC,0CAWe,IAXf,QAcU+D,EAAkBhJ,KAAKiJ,SAASJ,EAAKC,GACrCR,EAAS,GAfnB,IAiB+BU,GAjB/B,IAiBI,2BACI,IADwC,eAAhC/C,EAAgC,KAAzBC,EAAyB,KAC/B5D,EAAM2D,EAAO3D,GAAO4D,EAAK5D,IAC9B,GAAIyG,EAAGjB,SAASxF,GAEZ,IADM4G,EAAYH,EAAGjB,SAASxF,GACrB6G,EAAI,EAAGA,EAAID,EAAU5H,SAAU6H,EACpCb,EAAOnH,KAAK,IAAI4C,EAAQyE,QAAQU,EAAUC,GAAG/G,KAAM8G,EAAUC,GAAG9G,KAAMC,IAtB1F,wDA2BW,EAAI0B,EAAOoF,gBAAgBd,EAAQ,IAAIxE,EAAgB0E,QAAQ,EAAG,KA3B7E,iD,iFAgCA,SAASa,EAAKnD,IACVmD,GAAO,GACG,IACNA,EAAM,GAENnD,EAAM,KAAH,IAAG,EAAK,MACXA,EAAM,KAAH,IAAG,EAAK,KAEfA,GAAO,EAKP,IAJA,IA9Ma5B,EA8MTgF,EAAI,EACJC,EAAI,EACJC,EAAIxJ,KAAK4E,SAAwB,EAAb5E,KAAK2E,MACvB8E,EAAO,GACNH,GAAKtJ,KAAK2E,MAAO6E,GAAK,EAAGD,IAlNnBjF,EAkNsC,EAAJgF,EAAH,EAjNnC,KAAH,IAAG,EAAKhF,IAiNyCgF,GAAK,EAAG,CAC3D,IAAM5G,EAAI6G,EAAInF,EAAOiF,EAAKG,GACpBE,EAAIH,EAAInF,EAAO8B,EAAKsD,GAC1B,GAAIE,EAAIhH,EAAI+G,EAAKnI,OAAStB,KAAK0E,aAC3B,MAAM,IAAIY,MAAJ,gBAAmB+D,EAAnB,YAA0BnD,EAA1B,2DAAgFlG,KAAK4E,SAArF,mBAAwG5E,KAAK2E,MAA7G,6DAEV8E,EAAKtI,KAAK,CAACuB,EAAGgH,IAElB,OAAOD,M,EApNThF,CAAYR,EAAYuE,SAuN9B3I,EAAAA,QAAkB4E,G,mCC5PlB,IAAIf,EAAmB1D,MAAQA,KAAK0D,iBAAoB,SAAUH,GAC9D,OAAQA,GAAOA,EAAIjD,WAAciD,EAAM,CAAE,QAAWA,IAExD3C,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtDM,EAAQ4E,IAAM5E,EAAQ8J,IAAM9J,EAAQ+J,sBAAmB,EACvD,IAAMC,EAAqBnG,EAAgBE,EAAQ,QACnD/D,EAAQ+J,iBAAmBC,EAAmBrB,QAC9C,IAAMsB,EAAQpG,EAAgBE,EAAQ,QACtC/D,EAAQ8J,IAAMG,EAAMtB,QACpB,IAAMuB,EAAQrG,EAAgBE,EAAQ,QACtC/D,EAAQ4E,IAAMsF,EAAMvB,S,4ICVhB9E,EAAmB1D,MAAQA,KAAK0D,iBAAoB,SAAUH,GAC9D,OAAQA,GAAOA,EAAIjD,WAAciD,EAAM,CAAE,QAAWA,IAExD3C,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtD,IAAMyK,EAA4BtG,EAAgBE,EAAQ,QACpDqG,EAAcvG,EAAgBE,EAAQ,QACtCsG,EAAAA,WAKF,cAAuD,IAAzCjD,EAAyC,EAAzCA,WAAyC,IAA7BkD,cAAAA,OAA6B,MAAb,SAACC,GAAD,OAAOA,GAAM,YACnDpK,KAAKiH,WAAaA,EAClBjH,KAAK+G,aAAeoD,E,gEAExB,yGAAkBrF,EAAlB,+BAAyB,GAAzB,SAEuC9E,KAAK+E,MAAMD,GAFlD,yBAEYK,QAAYkF,EAFxB,yBAGWA,GAHX,gD,kFAKA,SAAeC,EAAYC,GACvB,OAAID,EACOA,EAAW3H,UAAU4H,GAAiB,EACvCA,EACAD,EAGCC,I,8CAGf,4GAAYzF,EAAZ,+BAAmB,GACV9E,KAAKwK,cACNxK,KAAKwK,YAAc,IAAIR,EAA0BxB,QAAQ,CACrDiC,MAAO,IAAIR,EAAYzB,QAAQ,CAAEkC,QAAS,IAC1C/C,KAAM,kBAAM,EAAKgD,OAAO7F,OAJpC,kBAOW9E,KAAKwK,YAAYrH,IAAI,QAAS,UAAM9C,IAP/C,gD,wGASA,WAAgBuK,GAAhB,wFAAuB9F,EAAvB,+BAA8B,GAA9B,SACqB9E,KAAK+E,MAAMD,GADhC,eAC+C8F,EAD/C,YACuCzF,QADvC,gCACyD,GADzD,uCAC6D2C,UAD7D,gD,2DAjCEoC,GAqCNrK,EAAAA,QAAkBqK,G,6HC3CdxG,EAAmB1D,MAAQA,KAAK0D,iBAAoB,SAAUH,GAC9D,OAAQA,GAAOA,EAAIjD,WAAciD,EAAM,CAAE,QAAWA,IAExD3C,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtD,IAAMyK,EAA4BtG,EAAgBE,EAAQ,QACpDqG,EAAcvG,EAAgBE,EAAQ,QACtCiH,EAAuBjH,EAAQ,MAC/BC,EAAoBD,EAAQ,OAC5BI,EAASJ,EAAQ,MACjBkG,EAAQpG,EAAgBE,EAAQ,QAChCmG,EAAQrG,EAAgBE,EAAQ,QACtC,SAASkH,EAAQC,GACb,OAAO,IAAIrL,SAAQ,SAAAV,GACfgM,WAAWhM,EAAS+L,M,IAGtBnB,EAAAA,WAgBF,cAAoK,IAAtJqB,EAAsJ,EAAtJA,KAAMhE,EAAgJ,EAAhJA,WAAYiE,EAAoI,EAApIA,QAASC,EAA2H,EAA3HA,cAAeC,EAA4G,EAA5GA,QAASC,EAAmG,EAAnGA,cAAmG,IAApFC,eAAAA,OAAoF,MAAnE,IAAmE,MAAzDnB,cAAAA,OAAyD,MAAzC,SAAAC,GAAC,OAAIA,GAAoC,MAAjCmB,eAAAA,OAAiC,MAAhB,EAAI,KAAJ,IAAI,EAAK,IAAO,EAChK,GADgK,UAC5JtE,EACAjH,KAAKiH,WAAaA,MAEjB,KAAIgE,EAIL,MAAM,IAAIO,UAAU,0CAHpBxL,KAAKiH,WAAa,IAAI4D,EAAqBY,UAAUR,GAKzD,GAAIE,EACAnL,KAAK0L,MAAQ,IAAI5B,EAAMtB,QAAQ,CAC3BvB,WAAYkE,EACZhB,cAAAA,SAGH,GAAIkB,EACLrL,KAAK0L,MAAQ,IAAI3B,EAAMvB,QAAQ,CAC3BvB,WAAYoE,EACZlB,cAAAA,SAGH,GAAIe,EACLlL,KAAK0L,MAAQ,IAAI5B,EAAMtB,QAAQ,CAC3BvB,WAAY,IAAI4D,EAAqBY,UAAUP,GAC/Cf,cAAAA,SAGH,GAAIiB,EACLpL,KAAK0L,MAAQ,IAAI3B,EAAMvB,QAAQ,CAC3BvB,WAAY,IAAI4D,EAAqBY,UAAUL,GAC/CjB,cAAAA,QAGH,KAAIc,EAOL,MAAM,IAAIO,UAAU,yEANpBxL,KAAK0L,MAAQ,IAAI5B,EAAMtB,QAAQ,CAC3BvB,WAAY,IAAI4D,EAAqBY,UAAzB,UAAsCR,EAAtC,SACZd,cAAAA,IAMRnK,KAAKsL,eAAiBA,EACtBtL,KAAK+G,aAAeoD,EACpBnK,KAAK2L,WAAa,IAAI3B,EAA0BxB,QAAQ,CACpDiC,MAAO,IAAIR,EAAYzB,QAAQ,CAC3BkC,QAASnG,KAAKC,MAAM+G,EAAiB,SAEzC5D,KAAM3H,KAAK4L,UAAUC,KAAK7L,Q,6DAUlC,WAAe6E,EAASoB,EAAOC,EAAKpB,GAApC,oHAEQgH,EAAU,GAEM,qBAAThH,EAJf,sBAKc,IAAI0G,UAAU,kCAL5B,UAOwB,oBAAT1G,EACPiH,EAAWjH,GAGXgH,EAAUhH,EACViH,EAAWjH,EAAKkH,mBAEJ3L,IAAZwE,EAdR,sBAec,IAAI2G,UAAU,0CAf5B,UAiBSO,EAjBT,sBAkBc,IAAIP,UAAU,kCAlB5B,wBAoB2BxL,KAAK0L,MAAMO,YAAYH,GApBlD,WAoBUI,EApBV,QAqBI,EAAIlI,EAAOmI,kBAAkBC,GACxBnG,IACDA,EAAQ,GAEPC,IACDA,EAAMgG,EAAS7E,cAEbpB,GAASC,EA5BnB,uBA6Bc,IAAIsF,UAAU,8EA7B5B,WA+BQvF,IAAUC,EA/BlB,oEAkCyBlG,KAAK0L,MAAMW,eAAexH,EAASoB,EAAOC,EAAK4F,GAlCxE,QAkCUxD,EAlCV,QAmCI,EAAItE,EAAOmI,kBAAkBC,GAGpB/K,EAAI,EAtCjB,aAsCoBA,EAAIiH,EAAOhH,QAtC/B,uBAuCcgL,EAAOhE,EAAOjH,GAAGkB,eACZvC,KAAKsL,gBAxCxB,uBAyCkB,IAAIhG,MAAJ,oCAAuCgH,EAAKC,iBAA5C,4CAAgGvM,KAAKsL,eAAeiB,iBAApH,MAzClB,QAsCuClL,GAAK,EAtC5C,wBA6CQmL,EAAOC,KAAKC,MACPC,EAAW,EA9CxB,aA8C2BA,EAAWrE,EAAOhH,QA9C7C,wBA+CYsL,OA/CZ,EAgDczD,EAAIb,EAAOqE,GAhDzB,UAiDyD3M,KAAK2L,WAAWxI,IAAIgG,EAAErC,WAAYqC,EAAGiD,GAjD9F,iBAiDgBS,EAjDhB,EAiDgBA,OAAQC,EAjDxB,EAiDwBA,WAAYC,EAjDpC,EAiDoCA,YACtBC,GAAgC,qBAAhBC,YAChB,IAAIA,YAAY,SAASC,OAAOL,GAChCA,EAAO/F,YAAYqG,MAAM,OACzBC,OACN,EAAIpJ,EAAOmI,kBAAkBC,GACzBiB,EAAalE,EAAE/G,KAAKkL,aACpBC,OAxDZ,EAyDiBlM,EAAI,EAzDrB,aAyDwBA,EAAI2L,EAAM1L,QAzDlC,iBA2DY,IADMkM,EAAOR,EAAM3L,GACdkM,EAAM,EAAGF,GAAcN,EAAWQ,GAAMA,GAAO,GA3DhE,KA6DkDvN,KAAKyN,UAAUvB,EAAUrH,EAASoB,EAAOC,EAAKsH,GAA5EE,EA7DpB,EA6DoBA,gBAAiBC,EA7DrC,EA6DqCA,gBAEOtN,IAA5BuM,QACoBvM,IAApBqN,GACAd,EAA0Bc,GAjE1C,uBAkEsB,IAAIpI,MAAJ,gDAAmDsH,EAAnD,cAAgFc,EAAhF,2CAlEtB,WAoEYd,EAA0Bc,GACtBC,EArEhB,iBAsEgB5B,EAASyB,EAAKI,OASd,IAAAd,EAAWS,IAAmBF,EAAaN,EAAWQ,KA/EtE,kCAiFyClN,IAApBqN,GAAiCA,GAAmBxH,GAjFzE,sDAuFYmH,GAAcG,EAAKlM,OAAS,IAExBkL,EAAOC,KAAKC,MAAQ,KAzFpC,wBA0FgBF,EAAOC,KAAKC,OACZ,EAAI1I,EAAOmI,kBAAkBC,GA3F7C,UA4FsBtB,EAAQ,GA5F9B,QAyD0CzJ,GAAK,EAzD/C,wBA8CqDsL,GAAY,EA9CjE,iE,iHAiGA,qGAAkB7H,EAAlB,+BAAyB,GAAzB,kBACW9E,KAAK0L,MAAMO,YAAYnH,IADlC,gD,8GAUA,yHAAsBA,EAAtB,+BAA6B,GAA7B,SAC4D9E,KAAKiM,YAAYnH,GAD7E,uBACYqD,EADZ,EACYA,cAAe/B,EAD3B,EAC2BA,SAAUsC,EADrC,EACqCA,cACjC,EAAI1E,EAAOmI,kBAAkBrH,EAAKsH,QAC5ByB,EAAW1F,GAAiBA,EAAcvF,cAC1CuF,EAAcvF,cAAgB8F,EAC9BA,EALV,UAQsB1I,KAAK8N,YAAY,EAAGD,EAAU/I,GARpD,eAQQS,EARR,QASI,EAAIvB,EAAOmI,kBAAkBrH,EAAKsH,QATtC,qBAWsB,EAAIvI,EAAkBmD,OAAOzB,GAXnD,QAWQA,EAXR,gEAcQwI,QAAQvO,MAAR,MACM,IAAI8F,MAAJ,oCAEuB,KAAE0I,KAFzB,yBAE8CH,EAF9C,oBAfd,YAoBQzH,EApBR,iBAsBY6H,GAAe,EACbC,EAAc,KAAKC,WAAW,GAC9BC,EAAWhI,EAAS+H,WAAW,GAC5B9M,EAAI,EAzBrB,aAyBwBA,EAAIkE,EAAMjE,QAzBlC,oBA0BgBD,IAAM4M,EAAc,GAAK1I,EAAMlE,KAAO+M,EA1BtD,qDA6BgB7I,EAAMlE,KAAO6M,IACbD,EAAc5M,GA9B9B,QAyB0CA,GAAK,EAzB/C,wBAiCQkE,EAAQA,EAAMmB,MAAM,EAAGuH,EAAc,GAjC7C,iCAmCW1I,GAnCX,2D,wGA2CA,uGAAgBT,EAAhB,+BAAuB,GAAvB,SACwB9E,KAAKqO,gBAAgBvJ,GAD7C,cACUS,EADV,QAEI,EAAIvB,EAAOmI,kBAAkBrH,EAAKsH,QAFtC,kBAGW7G,EAAMuB,SAAS,SAH1B,gD,wHAaA,uGAAgChC,EAAhC,+BAAuC,GAAvC,SAC2B9E,KAAKiM,YAAYnH,GAD5C,cACUoH,EADV,yBAEWA,EAASxG,aAFpB,gD,6EAcA,WAAgE4I,EAAeC,EAAaC,EAAWhB,GAAM,IAAjGzH,EAAiG,EAAjGA,cAAeK,EAAkF,EAAlFA,SAAUP,EAAwE,EAAxEA,eAAgBC,EAAwD,EAAxDA,OAEjD,GAAI0H,EAAKiB,OAAO,KAAOrI,EACnB,MAAO,CAAEuH,UAAU,GAGvB,IAAM3H,EAAoBD,EAApBC,IAAKC,EAAeF,EAAfE,MAAOC,EAAQH,EAARG,IACbF,IACDA,EAAM,GAELC,IACDA,EAAQ,GAEPC,IACDA,EAAM,GAEK,QAAXJ,IACAI,EAAM,GAUV,IARA,IAAMwI,EAAYnK,KAAKuE,IAAI9C,EAAKC,EAAOC,GAInCyI,EAAsB,EACtBC,EAAqB,EACrBC,EAAS,GACTnB,GAAmBoB,EAAAA,EACdzN,EAAI,EAAGA,EAAImM,EAAKlM,OAAS,EAAGD,GAAK,EACtC,GAAgB,OAAZmM,EAAKnM,IAAeA,IAAMmM,EAAKlM,OAAQ,CACvC,GAAIqN,IAAwB3I,GACxB,GAAIhG,KAAK+G,aAAayG,EAAK9G,MAAMkI,EAAoBvN,MACjDiN,EACA,MAAO,CAAEX,UAAU,QAGtB,GAAIgB,IAAwB1I,EAAO,CAMpC,GALAyH,EAAkBqB,SAASvB,EAAK9G,MAAMkI,EAAoBvN,GAAI,IAEvC,mBAAnBwE,IACA6H,GAAmB,GAEnBA,GAAmBc,EACnB,MAAO,CAAEd,gBAAAA,EAAiBC,UAAU,GAExC,IAAY,IAARzH,GAAaA,IAAQD,IAEjByH,EAAkB,GAAKa,EACvB,MAAO,CAAEb,gBAAAA,EAAiBC,UAAU,QAI3C,GAAe,QAAX7H,GAA4C,IAAxB6I,EACzBE,EAASrB,EAAK9G,MAAMkI,EAAoBvN,QAEvC,GAAIsN,IAAwBzI,EAAK,CASlC,IANe,QAAXJ,EACgB9F,KAAKgP,WAAWtB,EAAiBmB,EAAQrB,EAAK9G,MAAMkI,EAAoBvN,IAGxE0N,SAASvB,EAAK9G,MAAMkI,EAAoBvN,GAAI,MAE3CkN,EACjB,MAAO,CAAEZ,UAAU,GAK3B,GAFAiB,EAAqBvN,EAAI,GACzBsN,GAAuB,GACGD,EACtB,MAIZ,MAAO,CAAEhB,gBAAAA,EAAiBC,UAAU,K,wBAExC,SAAWD,EAAiBmB,EAAQvP,GAChC,IAAI2P,EAAgBvB,EAAkBmB,EAAOvN,OAMvC4N,GAAwC,IAAhC5P,EAAKwC,QAAQ,cAC3B,GAAgB,MAAZxC,EAAK,IAAe4P,GAcnB,GAAIA,EACL,OAAOxB,EAAkB,OAbzB,IADA,IAAIyB,EAAW,IACNpH,EAAI,EAAGA,EAAIzI,EAAKgC,OAAQyG,GAAK,EAAG,CACrC,GAAiB,MAAboH,GAA6C,SAAzB7P,EAAKoH,MAAMqB,EAAGA,EAAI,GAAe,CACrD,IAAIqH,EAAW9P,EAAKwC,QAAQ,IAAKiG,IACf,IAAdqH,IACAA,EAAW9P,EAAKgC,QAEpB2N,EAAgBF,SAASzP,EAAKoH,MAAMqB,EAAI,EAAGqH,GAAW,IACtD,MAEJD,EAAW7P,EAAKyI,GAMxB,OAAOkH,I,kDAOX,WAAgBpK,GAAhB,wFAAyBC,EAAzB,+BAAgC,GAAhC,kBACW9E,KAAK0L,MAAMrG,UAAUR,EAASC,IADzC,gD,2GAGA,WAAkBuK,EAAUC,GAA5B,8FAA4CxK,EAA5C,+BAAmD,GAAnD,SACwC9E,KAAKiH,WAAWsI,KAAKC,EAAOC,MAAMH,GAAiB,EAAGA,EAAgBD,EAAUvK,GADxH,uBACY4K,EADZ,EACYA,UAAW7C,EADvB,EACuBA,OADvB,kBAEW6C,EAAYJ,EAAiBzC,EAAOnG,MAAM,EAAGgJ,GAAa7C,GAFrE,gD,2GAUA,WAAgB8C,GAAhB,0FAAuB7K,EAAvB,+BAA8B,GAA9B,SAGiC9E,KAAK8N,YAAY6B,EAAMvN,KAAKQ,cAAe+M,EAAMpN,cAAeuC,GAHjG,cAGU8K,EAHV,mCAKe,EAAI/L,EAAkBgM,iBAAiBD,EAAgBD,IALtE,sCAQc,IAAIrK,MAAJ,oCAAuCqK,EAAM7I,WAA7C,mBARd,yD,2DArXE8C,GAiYN/J,EAAAA,QAAkB+J,G,uLCjZd/G,EAAmB7C,MAAQA,KAAK6C,kBAAqBjC,OAAOkC,OAAU,SAASC,EAAGC,EAAGC,EAAGC,QAC7E7C,IAAP6C,IAAkBA,EAAKD,GAC3BrC,OAAOL,eAAewC,EAAGG,EAAI,CAAEhC,YAAY,EAAMiC,IAAK,WAAa,OAAOH,EAAEC,OAC1E,SAASF,EAAGC,EAAGC,EAAGC,QACT7C,IAAP6C,IAAkBA,EAAKD,GAC3BF,EAAEG,GAAMF,EAAEC,KAEVG,EAAsBpD,MAAQA,KAAKoD,qBAAwBxC,OAAOkC,OAAU,SAASC,EAAGM,GACxFzC,OAAOL,eAAewC,EAAG,UAAW,CAAE7B,YAAY,EAAM3B,MAAO8D,KAC9D,SAASN,EAAGM,GACbN,EAAC,QAAcM,IAEfC,EAAgBtD,MAAQA,KAAKsD,cAAiB,SAAUC,GACxD,GAAIA,GAAOA,EAAIjD,WAAY,OAAOiD,EAClC,IAAIC,EAAS,GACb,GAAW,MAAPD,EAAa,IAAK,IAAIN,KAAKM,EAAe,YAANN,GAAmBrC,OAAOmB,UAAU0B,eAAexB,KAAKsB,EAAKN,IAAIJ,EAAgBW,EAAQD,EAAKN,GAEtI,OADAG,EAAmBI,EAAQD,GACpBC,GAEPE,EAAmB1D,MAAQA,KAAK0D,iBAAoB,SAAUH,GAC9D,OAAQA,GAAOA,EAAIjD,WAAciD,EAAM,CAAE,QAAWA,IAExD3C,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtD,IAAMoE,EAASD,EAAgBE,EAAQ,QACjCE,EAAkBR,EAAaM,EAAQ,QACvCG,EAAUL,EAAgBE,EAAQ,QAClCC,EAAoBD,EAAQ,OAC5BI,EAASJ,EAAQ,MACjBK,EAAcP,EAAgBE,EAAQ,QACtCkM,EAAY,SAKlB,SAAS7G,EAASI,EAAKnD,GAGnB,MAAO,CACH,CAAC,EAAG,GACJ,CAAC,IAJLmD,GAAO,IAIU,IAAK,IAHtBnD,GAAO,IAG2B,KAC9B,CAAC,GAAKmD,GAAO,IAAK,GAAKnD,GAAO,KAC9B,CAAC,IAAMmD,GAAO,IAAK,IAAMnD,GAAO,KAChC,CAAC,KAAOmD,GAAO,IAAK,KAAOnD,GAAO,KAClC,CAAC,MAAQmD,GAAO,IAAK,MAAQnD,GAAO,M,IAGtC6J,EAAAA,SAAAA,G,sIACF,WAAgBlL,GAAhB,8FAAyBC,EAAzB,+BAAgC,GAAhC,SAC4B9E,KAAK+E,MAAMD,GADvC,UACUE,EADV,iDAGgB,GAHhB,UAKUC,EAAQD,EAAUE,YAAYL,GACxBG,EAAUG,QAAQF,GANlC,2CAQgB,GARhB,aAUYG,EAAUJ,EAAUG,QAAQF,GAA5BG,OAVZ,0CAYeA,EAAMC,WAZrB,kCAcY,GAdZ,iD,sGAkBA,kJAAaP,EAAb,+BAAoB,GAApB,KAC4BjB,EAAkBmD,MAD9C,SAC4DhH,KAAKiH,WAAWC,SAASpC,GADrF,4DACUS,EADV,QAEI,EAAIvB,EAAOmI,kBAAkBrH,EAAKsH,QAE9B7G,EAAM4B,aAAa,KAAO2I,EAJlC,uBAKc,IAAIxK,MAAM,kBALxB,WASUkC,EAAWjC,EAAMK,YAAY,GAC7BD,EAAcJ,EAAMK,YAAY,GAChCC,EAA+B,MAAdF,EAAwB,uBAAyB,iBAMlEG,EALa,CACf,EAAG,UACH,EAAG,MACH,EAAG,OAEiC,GAAdH,GAjB9B,uBAmBc,IAAIL,MAAJ,4CAA+CK,IAnB7D,eAqBUI,EAAgB,CAClBC,IAAKT,EAAMK,YAAY,IACvBK,MAAOV,EAAMK,YAAY,IACzBM,IAAKX,EAAMK,YAAY,KAErBO,EAAYZ,EAAMK,YAAY,IAE9BlB,IAAiB,GAAoB,IADrCC,EAAQ,GACwB,IAAW,GAAK,EAChD0C,EA7BV,SA6ByB,EAAM,GAAa,EAAR1C,GAC1ByB,EAAWD,EAAYE,OAAOC,aAAaH,GAAa,KACxDI,EAAYhB,EAAMK,YAAY,IAE9BY,EAAoBjB,EAAMK,YAAY,IAjChD,EAkCyC5F,KAAKyG,gBAAgBlB,EAAMmB,MAAM,GAAI,GAAKF,IAAvEtB,EAlCZ,EAkCYA,YAAaQ,EAlCzB,EAkCyBA,YAEjB+B,EAAa,GAAKjB,EAEhBrB,EAAU,IAAIuC,MAAMF,GAAUG,KAAK,GAAGC,KAAI,WAE5C,IAAMC,EAAWtC,EAAMK,YAAY6B,GACnCA,GAAc,EAGd,IAFA,IACIrC,EADE0C,EAAW,GAERC,EAAI,EAAGA,EAAIF,EAAUE,GAAK,EAAG,CAClC,IAAMzF,EAAMiD,EAAM4B,aAAaM,GAE/B,GADAA,GAAc,EACVnF,EAAMoC,EAAe,EACrB,MAAM,IAAIY,MAAM,8DAEf,GAAIhD,IAAQoC,EAAe,EAAG,CAC/B,IAAM2D,EAAa9C,EAAMK,YAAY6B,GACrCA,GAAc,EACK,IAAfY,IACAjD,EAAQ,EAAK4C,eAAezC,EAAOkC,IAEvCA,GAAc,GAAKY,MAElB,CACD,IAAMA,EAAa9C,EAAMK,YAAY6B,GACrCA,GAAc,EAEd,IADA,IAAMa,EAAS,IAAIZ,MAAMW,GAChBpF,EAAI,EAAGA,EAAIoF,EAAYpF,GAAK,EAAG,CACpC,IAAMsF,GAAI,EAAIzE,EAAgBoE,WAAW3C,EAAOkC,GAC1CpE,GAAI,EAAIS,EAAgBoE,WAAW3C,EAAOkC,EAAa,GAC7DA,GAAc,GACdU,EAAgB,EAAKC,eAAeD,EAAeI,GACnDD,EAAOrF,GAAK,IAAIc,EAAQyE,QAAQD,EAAGlF,EAAGf,GAE1CwF,EAASxF,GAAOgG,GAIxB,IAAM0H,EAAczK,EAAMK,YAAY6B,GACtCA,GAAc,EAEd,IADA,IAAMwI,EAAc,IAAIvI,MAAMsI,GACrB/M,EAAI,EAAGA,EAAI+M,EAAa/M,GAAK,EAClCgN,EAAYhN,IAAK,EAAIa,EAAgBoE,WAAW3C,EAAOkC,GACvDA,GAAc,EACdU,EAAgB,EAAKC,eAAeD,EAAe8H,EAAYhN,IAEnE,MAAO,CAAE6E,SAAAA,EAAUmI,YAAAA,EAAa7K,MAAAA,MAjFxC,kBAmFW,CACHD,QAAAA,EACAiB,SAAAA,EACA1B,aAAAA,EACA2C,aAAAA,EACAd,UAAAA,EACA4B,cAAAA,EACApC,cAAAA,EACAF,eAAAA,EACAC,OAAAA,EACAJ,YAAAA,EACAR,YAAAA,EACAwD,aAAc,QA/FtB,iD,kFAkGA,SAAenD,EAAOC,GAElB,MAAO,CAAEH,WADS,EAAIrB,EAAO2E,cAAchF,EAAO6E,QAAQI,YAAYrD,EAAMmB,MAAMlB,EAAS,GAAIA,EAAS,KAAK,O,6BAGjH,SAAgBmB,GAKZ,IAJA,IAAIC,EAAY,EACZC,EAAgB,EACdnB,EAAc,GACdR,EAAc,GACX7D,EAAI,EAAGA,EAAIsF,EAAWrF,OAAQD,GAAK,EACxC,IAAKsF,EAAWtF,GAAI,CAChB,GAAIwF,EAAgBxF,EAAG,CACnB,IAAIwD,EAAU8B,EAAWG,SAAS,OAAQD,EAAexF,GACzDwD,EAAU7E,KAAK+G,aAAalC,GAC5Ba,EAAYkB,GAAa/B,EACzBK,EAAYL,GAAW+B,EAE3BC,EAAgBxF,EAAI,EACpBuF,GAAa,EAGrB,MAAO,CAAE1B,YAAAA,EAAaQ,YAAAA,K,uDAE1B,WAAqBb,EAASgE,EAAKC,GAAnC,8HAAwChE,EAAxC,+BAA+C,GACvC+D,EAAM,IACNA,EAAM,GAFd,SAI4B7I,KAAK+E,MAAMD,GAJvC,UAIUE,EAJV,gDAMe,IANf,UAQUC,EAAQD,EAAUE,YAAYL,GAC9BkE,EAAK/D,EAAUG,QAAQF,GATjC,0CAWe,IAXf,SAasB8D,EAAGkH,YAAY3O,OAC3ByH,EAAGkH,YAAYpH,GA1KN,IA0K+BE,EAAGkH,YAAY3O,OACnDyH,EAAGkH,YAAY3O,OAAS,EACxBuH,GA5KK,IA6KT,IAAI/E,EAAgB0E,QAAQ,EAAG,KAEjCuF,QAAQmC,KAAK,4CAGXlH,EAAkBC,EAASJ,EAAKC,GAChCR,EAAS,GAvBnB,IAyB+BU,GAzB/B,IAyBI,2BACI,IADwC,eAAhC/C,EAAgC,KAAzBC,EAAyB,KAC/B5D,EAAM2D,EAAO3D,GAAO4D,EAAK5D,IAC9B,GAAIyG,EAAGjB,SAASxF,GAEZ,IADM4G,EAAYH,EAAGjB,SAASxF,GACrB6G,EAAI,EAAGA,EAAID,EAAU5H,SAAU6H,EACpCb,EAAOnH,KAAK,IAAI4C,EAAQyE,QAAQU,EAAUC,GAAG/G,KAAM8G,EAAUC,GAAG9G,KAAMC,IA9B1F,8BAyCI,IAJM6N,EAAQpH,EAAGkH,YAAY3O,OACzB8O,EAAS,KACPC,EAAS9L,KAAKsE,IAAIA,GAAO,GAAIsH,EAAQ,GACrCG,EAAS/L,KAAKsE,IAAIC,GAAO,GAAIqH,EAAQ,GAClC9O,EAAIgP,EAAQhP,GAAKiP,IAAUjP,GAC1BkP,EAAKxH,EAAGkH,YAAY5O,OAEjB+O,GAAUG,EAAG5N,UAAUyN,GAAU,KAClCA,EAASG,GA7CzB,0BAiDW,EAAIvM,EAAOoF,gBAAgBd,EAAQ8H,IAjD9C,iD,+DA5IEL,CAAmB9L,EAAYuE,SAgMrC3I,EAAAA,QAAkBkQ,G,mKC9OlBnP,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtDM,EAAQuJ,eAAiBvJ,EAAQ2Q,eAAiB3Q,EAAQ4Q,gBAAkB5Q,EAAQsM,iBAAmBtM,EAAQ8I,kBAAe,EAQ9H9I,EAAQ8I,aAPR,SAAsB+H,GAClB,GAAIA,EAAKC,YAAYC,OAAOC,mBACxBH,EAAKI,SAASF,OAAOG,kBACrB,MAAM,IAAIzL,MAAM,oBAEpB,OAAOoL,EAAKM,Y,IAGVC,EAAAA,SAAAA,G,oFAAAA,C,EAAmB3L,QAazB,SAAS6G,EAAiBC,GACtB,GAAKA,GAGDA,EAAO8E,QAAS,CAEhB,GAA4B,qBAAjBC,aAEP,MAAM,IAAIA,aAAa,UAAW,cAGlC,IAAMzH,EAAI,IAAIuH,EAAW,WAEzB,MADAvH,EAAEsE,KAAO,cACHtE,G,gCAWlB,WAA+B0C,GAA/B,+EACU1M,QAAQV,UADlB,OAEImN,EAAiBC,GAFrB,4C,sBAKA,SAASoE,EAAeY,EAAQC,GAC5B,OAAQA,EAAOjP,KAAKQ,cAAgBwO,EAAO/O,KAAKO,cAAgB,MAC5DyO,EAAOhP,KAAKO,cAAgBwO,EAAOhP,KAAKQ,cAAgB,IAdhE/C,EAAQsM,iBAAmBA,EAW3BtM,EAAQ4Q,gB,SAJuB,G,gCAS/B5Q,EAAQ2Q,eAAiBA,EAwCzB3Q,EAAQuJ,eAvCR,SAAwBd,EAAQ8H,GAC5B,IAAMkB,EAAe,GACjBC,EAAY,KAChB,OAAsB,IAAlBjJ,EAAOhH,OACAgH,GAEXA,EAAOkJ,MAAK,SAAUC,EAAIC,GACtB,IAAMC,EAAMF,EAAGrP,KAAKQ,cAAgB8O,EAAGtP,KAAKQ,cAC5C,OAAY,IAAR+O,EACOA,EAGAF,EAAGrP,KAAKkL,aAAeoE,EAAGtP,KAAKkL,gBAG9ChF,EAAO9G,SAAQ,SAAAmO,KACNS,GAAUT,EAAMtN,KAAKM,UAAUyN,GAAU,KACxB,OAAdmB,GACAD,EAAanQ,KAAKwO,GAClB4B,EAAY5B,GAGRa,EAAee,EAAW5B,GACtBA,EAAMtN,KAAKM,UAAU4O,EAAUlP,MAAQ,IACvCkP,EAAUlP,KAAOsN,EAAMtN,OAI3BiP,EAAanQ,KAAKwO,GAClB4B,EAAY5B,OAQrB2B,K,6EC9FX1Q,OAAOL,eAAeV,EAAS,aAAc,CAAEN,OAAO,IACtDM,EAAQqI,eAAY,E,IACd0J,EAAAA,WACF,WAAYhP,EAAe0K,GAAc,UACrCtN,KAAK4C,cAAgBA,EACrB5C,KAAKsN,aAAeA,E,kCAExB,WACI,gBAAUtN,KAAK4C,cAAf,YAAgC5C,KAAKsN,gB,uBAEzC,SAAU5K,GACN,OAAQ1C,KAAK4C,cAAgBF,EAAEE,eAAiB5C,KAAKsN,aAAe5K,EAAE4K,gB,kBAE1E,WAAoB,IAChB,IAAIzE,EACAxH,EAAI,EAFQ,mBAANpB,EAAM,yBAANA,EAAM,gBAGhB,MAAQ4I,EAAKxH,GAAK,EACdwH,EAAM5I,EAAKoB,GAEf,KAAOA,EAAIpB,EAAKqB,OAAQD,GAAK,EACrBwH,EAAIlG,UAAU1C,EAAKoB,IAAM,IACzBwH,EAAM5I,EAAKoB,IAGnB,OAAOwH,M,EAtBT+I,GAyBN/R,EAAAA,QAAkB+R,EAYlB/R,EAAQqI,UAXR,SAAmB3C,GAAsC,IAA/BC,EAA+B,uDAAtB,EAAGqM,EAAmB,wDACrD,GAAIA,EACA,MAAM,IAAIvM,MAAM,mDAEpB,OAAO,IAAIsM,EAAkC,cAApBrM,EAAMC,EAAS,GAChB,WAApBD,EAAMC,EAAS,GACK,SAApBD,EAAMC,EAAS,GACK,MAApBD,EAAMC,EAAS,GACK,IAApBD,EAAMC,EAAS,GACfD,EAAMC,EAAS,GAAKD,EAAMC,EAAS,IAAM,EAAKD,EAAMC","sources":["../../../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../../../node_modules/@babel/runtime/helpers/objectSpread2.js","../../../node_modules/@babel/runtime/helpers/objectWithoutProperties.js","../../../node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js","../../../node_modules/@gmod/tabix/esm/chunk.js","../../../node_modules/@gmod/tabix/esm/csi.js","../../../node_modules/@gmod/tabix/esm/index.js","../../../node_modules/@gmod/tabix/esm/indexFile.js","../../../node_modules/@gmod/tabix/esm/tabixIndexedFile.js","../../../node_modules/@gmod/tabix/esm/tbi.js","../../../node_modules/@gmod/tabix/esm/util.js","../../../node_modules/@gmod/tabix/esm/virtualOffset.js"],"sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var defineProperty = require(\"./defineProperty.js\");\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nmodule.exports = _objectSpread2, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var objectWithoutPropertiesLoose = require(\"./objectWithoutPropertiesLoose.js\");\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","function _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nmodule.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n// little class representing a chunk in the index\nclass Chunk {\n    /**\n     * @param {VirtualOffset} minv\n     * @param {VirtualOffset} maxv\n     * @param {number} bin\n     * @param {number} [fetchedSize]\n     */\n    constructor(minv, maxv, bin, fetchedSize = undefined) {\n        this.minv = minv;\n        this.maxv = maxv;\n        this.bin = bin;\n        this._fetchedSize = fetchedSize;\n    }\n    toUniqueString() {\n        return `${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`;\n    }\n    toString() {\n        return this.toUniqueString();\n    }\n    compareTo(b) {\n        return (this.minv.compareTo(b.minv) ||\n            this.maxv.compareTo(b.maxv) ||\n            this.bin - b.bin);\n    }\n    fetchedSize() {\n        if (this._fetchedSize !== undefined) {\n            return this._fetchedSize;\n        }\n        return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition;\n    }\n}\nexports.default = Chunk;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst long_1 = __importDefault(require(\"long\"));\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst virtualOffset_1 = __importStar(require(\"./virtualOffset\"));\nconst chunk_1 = __importDefault(require(\"./chunk\"));\nconst util_1 = require(\"./util\");\nconst indexFile_1 = __importDefault(require(\"./indexFile\"));\nconst CSI1_MAGIC = 21582659; // CSI\\1\nconst CSI2_MAGIC = 38359875; // CSI\\2\nfunction lshift(num, bits) {\n    return num * 2 ** bits;\n}\nfunction rshift(num, bits) {\n    return Math.floor(num / 2 ** bits);\n}\nclass CSI extends indexFile_1.default {\n    constructor(args) {\n        super(args);\n        this.maxBinNumber = 0;\n        this.depth = 0;\n        this.minShift = 0;\n    }\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return -1;\n        }\n        const refId = indexData.refNameToId[refName];\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    async indexCov() {\n        throw new Error('CSI indexes do not support indexcov');\n        return [];\n    }\n    parseAuxData(bytes, offset, auxLength) {\n        if (auxLength < 30) {\n            return {\n                refIdToName: [],\n                refNameToId: {},\n            };\n        }\n        const formatFlags = bytes.readInt32LE(offset);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const format = { 0: 'generic', 1: 'SAM', 2: 'VCF' }[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: bytes.readInt32LE(offset + 4),\n            start: bytes.readInt32LE(offset + 8),\n            end: bytes.readInt32LE(offset + 12),\n        };\n        const metaValue = bytes.readInt32LE(offset + 16);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : '';\n        const skipLines = bytes.readInt32LE(offset + 20);\n        const nameSectionLength = bytes.readInt32LE(offset + 24);\n        const { refIdToName, refNameToId } = this._parseNameBytes(bytes.slice(offset + 28, offset + 28 + nameSectionLength));\n        return {\n            refIdToName,\n            refNameToId,\n            skipLines,\n            metaChar,\n            columnNumbers,\n            format,\n            coordinateType,\n        };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    let refName = namesBytes.toString('utf8', currNameStart, i);\n                    refName = this.renameRefSeq(refName);\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return { refNameToId, refIdToName };\n    }\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const bytes = await (0, bgzf_filehandle_1.unzip)((await this.filehandle.readFile(opts)));\n        // check TBI magic numbers\n        let csiVersion;\n        if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n            csiVersion = 1;\n        }\n        else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n            csiVersion = 2;\n        }\n        else {\n            throw new Error('Not a CSI file');\n            // TODO: do we need to support big-endian CSI files?\n        }\n        this.minShift = bytes.readInt32LE(4);\n        this.depth = bytes.readInt32LE(8);\n        this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (this.minShift + this.depth * 3);\n        const auxLength = bytes.readInt32LE(12);\n        let aux = {\n            refIdToName: [],\n            refNameToId: {},\n        };\n        if (auxLength) {\n            aux = this.parseAuxData(bytes, 16, auxLength);\n        }\n        const refCount = bytes.readInt32LE(16 + auxLength);\n        // read the indexes for each reference sequence\n        let firstDataLine;\n        let currOffset = 16 + auxLength + 4;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = bytes.readInt32LE(currOffset);\n            currOffset += 4;\n            const binIndex = {};\n            let stats; // < provided by parsing a pseudo-bin, if present\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = bytes.readUInt32LE(currOffset);\n                if (bin > this.maxBinNumber) {\n                    // this is a fake bin that actually has stats information\n                    // about the reference sequence in it\n                    stats = this.parsePseudoBin(bytes, currOffset + 4);\n                    currOffset += 4 + 8 + 4 + 16 + 16;\n                }\n                else {\n                    const loffset = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 4);\n                    firstDataLine = this._findFirstData(firstDataLine, loffset);\n                    const chunkCount = bytes.readInt32LE(currOffset + 12);\n                    currOffset += 16;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = (0, virtualOffset_1.fromBytes)(bytes, currOffset);\n                        const v = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 8);\n                        currOffset += 16;\n                        // this._findFirstData(data, u)\n                        chunks[k] = new chunk_1.default(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            return { binIndex, stats };\n        });\n        return {\n            ...aux,\n            csi: true,\n            refCount,\n            maxBlockSize: 1 << 16,\n            firstDataLine,\n            csiVersion,\n            indices,\n            depth: this.depth,\n            maxBinNumber: this.maxBinNumber,\n            maxRefLength,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        const lineCount = (0, util_1.longToNumber)(long_1.default.fromBytesLE(Array.prototype.slice.call(bytes, offset + 28, offset + 36), true));\n        return { lineCount };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return [];\n        }\n        const refId = indexData.refNameToId[refName];\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = this.reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (let c = 0; c < binChunks.length; ++c) {\n                        chunks.push(new chunk_1.default(binChunks[c].minv, binChunks[c].maxv, bin));\n                    }\n                }\n            }\n        }\n        return (0, util_1.optimizeChunks)(chunks, new virtualOffset_1.default(0, 0));\n    }\n    /**\n     * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n     */\n    reg2bins(beg, end) {\n        beg -= 1; // < convert to 1-based closed\n        if (beg < 1) {\n            beg = 1;\n        }\n        if (end > 2 ** 50) {\n            end = 2 ** 34;\n        } // 17 GiB ought to be enough for anybody\n        end -= 1;\n        let l = 0;\n        let t = 0;\n        let s = this.minShift + this.depth * 3;\n        const bins = [];\n        for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n            const b = t + rshift(beg, s);\n            const e = t + rshift(end, s);\n            if (e - b + bins.length > this.maxBinNumber) {\n                throw new Error(`query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);\n            }\n            bins.push([b, e]);\n        }\n        return bins;\n    }\n}\nexports.default = CSI;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CSI = exports.TBI = exports.TabixIndexedFile = void 0;\nconst tabixIndexedFile_1 = __importDefault(require(\"./tabixIndexedFile\"));\nexports.TabixIndexedFile = tabixIndexedFile_1.default;\nconst tbi_1 = __importDefault(require(\"./tbi\"));\nexports.TBI = tbi_1.default;\nconst csi_1 = __importDefault(require(\"./csi\"));\nexports.CSI = csi_1.default;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nclass IndexFile {\n    /**\n     * @param {filehandle} filehandle\n     * @param {function} [renameRefSeqs]\n     */\n    constructor({ filehandle, renameRefSeqs = (n) => n, }) {\n        this.filehandle = filehandle;\n        this.renameRefSeq = renameRefSeqs;\n    }\n    async getMetadata(opts = {}) {\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { indices, ...rest } = await this.parse(opts);\n        return rest;\n    }\n    _findFirstData(currentFdl, virtualOffset) {\n        if (currentFdl) {\n            return currentFdl.compareTo(virtualOffset) > 0\n                ? virtualOffset\n                : currentFdl;\n        }\n        else {\n            return virtualOffset;\n        }\n    }\n    async parse(opts = {}) {\n        if (!this._parseCache) {\n            this._parseCache = new abortable_promise_cache_1.default({\n                cache: new quick_lru_1.default({ maxSize: 1 }),\n                fill: () => this._parse(opts),\n            });\n        }\n        return this._parseCache.get('index', null, undefined);\n    }\n    async hasRefSeq(seqId, opts = {}) {\n        return !!((await this.parse(opts)).indices[seqId] || {}).binIndex;\n    }\n}\nexports.default = IndexFile;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortable_promise_cache_1 = __importDefault(require(\"abortable-promise-cache\"));\nconst quick_lru_1 = __importDefault(require(\"quick-lru\"));\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst util_1 = require(\"./util\");\nconst tbi_1 = __importDefault(require(\"./tbi\"));\nconst csi_1 = __importDefault(require(\"./csi\"));\nfunction timeout(time) {\n    return new Promise(resolve => {\n        setTimeout(resolve, time);\n    });\n}\nclass TabixIndexedFile {\n    /**\n     * @param {object} args\n     * @param {string} [args.path]\n     * @param {filehandle} [args.filehandle]\n     * @param {string} [args.tbiPath]\n     * @param {filehandle} [args.tbiFilehandle]\n     * @param {string} [args.csiPath]\n     * @param {filehandle} [args.csiFilehandle]\n     * @param {chunkSizeLimit} default 50MiB\n     * @param {function} [args.renameRefSeqs] optional function with sig `string => string` to transform\n     * reference sequence names for the purpose of indexing and querying. note that the data that is returned is\n     * not altered, just the names of the reference sequences that are used for querying.\n     * @param {number} [args.chunkCacheSize] maximum size in bytes of the chunk cache. default 5MB\n     * @param {number} [args.blockCacheSize] maximum size in bytes of the block cache. default 5MB\n     */\n    constructor({ path, filehandle, tbiPath, tbiFilehandle, csiPath, csiFilehandle, chunkSizeLimit = 50000000, renameRefSeqs = n => n, chunkCacheSize = 5 * 2 ** 20, }) {\n        if (filehandle) {\n            this.filehandle = filehandle;\n        }\n        else if (path) {\n            this.filehandle = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new TypeError('must provide either filehandle or path');\n        }\n        if (tbiFilehandle) {\n            this.index = new tbi_1.default({\n                filehandle: tbiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (csiFilehandle) {\n            this.index = new csi_1.default({\n                filehandle: csiFilehandle,\n                renameRefSeqs,\n            });\n        }\n        else if (tbiPath) {\n            this.index = new tbi_1.default({\n                filehandle: new generic_filehandle_1.LocalFile(tbiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (csiPath) {\n            this.index = new csi_1.default({\n                filehandle: new generic_filehandle_1.LocalFile(csiPath),\n                renameRefSeqs,\n            });\n        }\n        else if (path) {\n            this.index = new tbi_1.default({\n                filehandle: new generic_filehandle_1.LocalFile(`${path}.tbi`),\n                renameRefSeqs,\n            });\n        }\n        else {\n            throw new TypeError('must provide one of tbiFilehandle, tbiPath, csiFilehandle, or csiPath');\n        }\n        this.chunkSizeLimit = chunkSizeLimit;\n        this.renameRefSeq = renameRefSeqs;\n        this.chunkCache = new abortable_promise_cache_1.default({\n            cache: new quick_lru_1.default({\n                maxSize: Math.floor(chunkCacheSize / (1 << 16)),\n            }),\n            fill: this.readChunk.bind(this),\n        });\n    }\n    /**\n     * @param {string} refName name of the reference sequence\n     * @param {number} start start of the region (in 0-based half-open coordinates)\n     * @param {number} end end of the region (in 0-based half-open coordinates)\n     * @param {function|object} lineCallback callback called for each line in the region. can also pass a object param containing obj.lineCallback, obj.signal, etc\n     * @returns {Promise} resolved when the whole read is finished, rejected on error\n     */\n    async getLines(refName, start, end, opts) {\n        let signal;\n        let options = {};\n        let callback;\n        if (typeof opts === 'undefined') {\n            throw new TypeError('line callback must be provided');\n        }\n        if (typeof opts === 'function') {\n            callback = opts;\n        }\n        else {\n            options = opts;\n            callback = opts.lineCallback;\n        }\n        if (refName === undefined) {\n            throw new TypeError('must provide a reference sequence name');\n        }\n        if (!callback) {\n            throw new TypeError('line callback must be provided');\n        }\n        const metadata = await this.index.getMetadata(options);\n        (0, util_1.checkAbortSignal)(signal);\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = metadata.maxRefLength;\n        }\n        if (!(start <= end)) {\n            throw new TypeError('invalid start and end coordinates. start must be less than or equal to end');\n        }\n        if (start === end) {\n            return;\n        }\n        const chunks = await this.index.blocksForRange(refName, start, end, options);\n        (0, util_1.checkAbortSignal)(signal);\n        // check the chunks for any that are over the size limit.  if\n        // any are, don't fetch any of them\n        for (let i = 0; i < chunks.length; i += 1) {\n            const size = chunks[i].fetchedSize();\n            if (size > this.chunkSizeLimit) {\n                throw new Error(`Too much data. Chunk size ${size.toLocaleString()} bytes exceeds chunkSizeLimit of ${this.chunkSizeLimit.toLocaleString()}.`);\n            }\n        }\n        // now go through each chunk and parse and filter the lines out of it\n        let last = Date.now();\n        for (let chunkNum = 0; chunkNum < chunks.length; chunkNum += 1) {\n            let previousStartCoordinate;\n            const c = chunks[chunkNum];\n            const { buffer, cpositions, dpositions } = await this.chunkCache.get(c.toString(), c, signal);\n            const lines = (typeof TextDecoder !== 'undefined'\n                ? new TextDecoder('utf-8').decode(buffer)\n                : buffer.toString()).split('\\n');\n            lines.pop();\n            (0, util_1.checkAbortSignal)(signal);\n            let blockStart = c.minv.dataPosition;\n            let pos;\n            for (let i = 0; i < lines.length; i += 1) {\n                const line = lines[i];\n                for (pos = 0; blockStart >= dpositions[pos]; pos += 1) { }\n                // filter the line for whether it is within the requested range\n                const { startCoordinate, overlaps } = this.checkLine(metadata, refName, start, end, line);\n                // do a small check just to make sure that the lines are really sorted by start coordinate\n                if (previousStartCoordinate !== undefined &&\n                    startCoordinate !== undefined &&\n                    previousStartCoordinate > startCoordinate) {\n                    throw new Error(`Lines not sorted by start coordinate (${previousStartCoordinate} > ${startCoordinate}), this file is not usable with Tabix.`);\n                }\n                previousStartCoordinate = startCoordinate;\n                if (overlaps) {\n                    callback(line.trim(), \n                    // cpositions[pos] refers to actual file offset of a bgzip block boundaries\n                    //\n                    // we multiply by (1 <<8) in order to make sure each block has a \"unique\"\n                    // address space so that data in that block could never overlap\n                    //\n                    // then the blockStart-dpositions is an uncompressed file offset from\n                    // that bgzip block boundary, and since the cpositions are multiplied by\n                    // (1 << 8) these uncompressed offsets get a unique space\n                    cpositions[pos] * (1 << 8) + (blockStart - dpositions[pos]));\n                }\n                else if (startCoordinate !== undefined && startCoordinate >= end) {\n                    // the lines were overlapping the region, but now have stopped, so\n                    // we must be at the end of the relevant data and we can stop\n                    // processing data now\n                    return;\n                }\n                blockStart += line.length + 1;\n                // yield if we have emitted beyond the yield limit\n                if (last - Date.now() > 500) {\n                    last = Date.now();\n                    (0, util_1.checkAbortSignal)(signal);\n                    await timeout(1);\n                }\n            }\n        }\n    }\n    async getMetadata(opts = {}) {\n        return this.index.getMetadata(opts);\n    }\n    /**\n     * get a buffer containing the \"header\" region of\n     * the file, which are the bytes up to the first\n     * non-meta line\n     *\n     * @returns {Promise} for a buffer\n     */\n    async getHeaderBuffer(opts = {}) {\n        const { firstDataLine, metaChar, maxBlockSize } = await this.getMetadata(opts);\n        (0, util_1.checkAbortSignal)(opts.signal);\n        const maxFetch = firstDataLine && firstDataLine.blockPosition\n            ? firstDataLine.blockPosition + maxBlockSize\n            : maxBlockSize;\n        // TODO: what if we don't have a firstDataLine, and the header\n        // actually takes up more than one block? this case is not covered here\n        let bytes = await this._readRegion(0, maxFetch, opts);\n        (0, util_1.checkAbortSignal)(opts.signal);\n        try {\n            bytes = await (0, bgzf_filehandle_1.unzip)(bytes);\n        }\n        catch (e) {\n            console.error(e);\n            throw new Error(\n            //@ts-ignore\n            `error decompressing block ${e.code} at 0 (length ${maxFetch}) ${e}`);\n        }\n        // trim off lines after the last non-meta line\n        if (metaChar) {\n            // trim backward from the end\n            let lastNewline = -1;\n            const newlineByte = '\\n'.charCodeAt(0);\n            const metaByte = metaChar.charCodeAt(0);\n            for (let i = 0; i < bytes.length; i += 1) {\n                if (i === lastNewline + 1 && bytes[i] !== metaByte) {\n                    break;\n                }\n                if (bytes[i] === newlineByte) {\n                    lastNewline = i;\n                }\n            }\n            bytes = bytes.slice(0, lastNewline + 1);\n        }\n        return bytes;\n    }\n    /**\n     * get a string containing the \"header\" region of the\n     * file, is the portion up to the first non-meta line\n     *\n     * @returns {Promise} for a string\n     */\n    async getHeader(opts = {}) {\n        const bytes = await this.getHeaderBuffer(opts);\n        (0, util_1.checkAbortSignal)(opts.signal);\n        return bytes.toString('utf8');\n    }\n    /**\n     * get an array of reference sequence names, in the order in which\n     * they occur in the file.\n     *\n     * reference sequence renaming is not applied to these names.\n     *\n     * @returns {Promise} for an array of string sequence names\n     */\n    async getReferenceSequenceNames(opts = {}) {\n        const metadata = await this.getMetadata(opts);\n        return metadata.refIdToName;\n    }\n    /**\n     * @param {object} metadata metadata object from the parsed index,\n     * containing columnNumbers, metaChar, and format\n     * @param {string} regionRefName\n     * @param {number} regionStart region start coordinate (0-based-half-open)\n     * @param {number} regionEnd region end coordinate (0-based-half-open)\n     * @param {array[string]} line\n     * @returns {object} like `{startCoordinate, overlaps}`. overlaps is boolean,\n     * true if line is a data line that overlaps the given region\n     */\n    checkLine({ columnNumbers, metaChar, coordinateType, format, }, regionRefName, regionStart, regionEnd, line) {\n        // skip meta lines\n        if (line.charAt(0) === metaChar) {\n            return { overlaps: false };\n        }\n        // check ref/start/end using column metadata from index\n        let { ref, start, end } = columnNumbers;\n        if (!ref) {\n            ref = 0;\n        }\n        if (!start) {\n            start = 0;\n        }\n        if (!end) {\n            end = 0;\n        }\n        if (format === 'VCF') {\n            end = 8;\n        }\n        const maxColumn = Math.max(ref, start, end);\n        // this code is kind of complex, but it is fairly fast.\n        // basically, we want to avoid doing a split, because if the lines are really long\n        // that could lead to us allocating a bunch of extra memory, which is slow\n        let currentColumnNumber = 1; // cols are numbered starting at 1 in the index metadata\n        let currentColumnStart = 0;\n        let refSeq = '';\n        let startCoordinate = -Infinity;\n        for (let i = 0; i < line.length + 1; i += 1) {\n            if (line[i] === '\\t' || i === line.length) {\n                if (currentColumnNumber === ref) {\n                    if (this.renameRefSeq(line.slice(currentColumnStart, i)) !==\n                        regionRefName) {\n                        return { overlaps: false };\n                    }\n                }\n                else if (currentColumnNumber === start) {\n                    startCoordinate = parseInt(line.slice(currentColumnStart, i), 10);\n                    // we convert to 0-based-half-open\n                    if (coordinateType === '1-based-closed') {\n                        startCoordinate -= 1;\n                    }\n                    if (startCoordinate >= regionEnd) {\n                        return { startCoordinate, overlaps: false };\n                    }\n                    if (end === 0 || end === start) {\n                        // if we have no end, we assume the feature is 1 bp long\n                        if (startCoordinate + 1 <= regionStart) {\n                            return { startCoordinate, overlaps: false };\n                        }\n                    }\n                }\n                else if (format === 'VCF' && currentColumnNumber === 4) {\n                    refSeq = line.slice(currentColumnStart, i);\n                }\n                else if (currentColumnNumber === end) {\n                    let endCoordinate;\n                    // this will never match if there is no end column\n                    if (format === 'VCF') {\n                        endCoordinate = this._getVcfEnd(startCoordinate, refSeq, line.slice(currentColumnStart, i));\n                    }\n                    else {\n                        endCoordinate = parseInt(line.slice(currentColumnStart, i), 10);\n                    }\n                    if (endCoordinate <= regionStart) {\n                        return { overlaps: false };\n                    }\n                }\n                currentColumnStart = i + 1;\n                currentColumnNumber += 1;\n                if (currentColumnNumber > maxColumn) {\n                    break;\n                }\n            }\n        }\n        return { startCoordinate, overlaps: true };\n    }\n    _getVcfEnd(startCoordinate, refSeq, info) {\n        let endCoordinate = startCoordinate + refSeq.length;\n        // ignore TRA features as they specify CHR2 and END\n        // as being on a different chromosome\n        // if CHR2 is on the same chromosome, still ignore it\n        // because there should be another pairwise feature\n        // at the end of this one\n        const isTRA = info.indexOf('SVTYPE=TRA') !== -1;\n        if (info[0] !== '.' && !isTRA) {\n            let prevChar = ';';\n            for (let j = 0; j < info.length; j += 1) {\n                if (prevChar === ';' && info.slice(j, j + 4) === 'END=') {\n                    let valueEnd = info.indexOf(';', j);\n                    if (valueEnd === -1) {\n                        valueEnd = info.length;\n                    }\n                    endCoordinate = parseInt(info.slice(j + 4, valueEnd), 10);\n                    break;\n                }\n                prevChar = info[j];\n            }\n        }\n        else if (isTRA) {\n            return startCoordinate + 1;\n        }\n        return endCoordinate;\n    }\n    /**\n     * return the approximate number of data lines in the given reference sequence\n     * @param {string} refSeq reference sequence name\n     * @returns {Promise} for number of data lines present on that reference sequence\n     */\n    async lineCount(refName, opts = {}) {\n        return this.index.lineCount(refName, opts);\n    }\n    async _readRegion(position, compressedSize, opts = {}) {\n        const { bytesRead, buffer } = await this.filehandle.read(Buffer.alloc(compressedSize), 0, compressedSize, position, opts);\n        return bytesRead < compressedSize ? buffer.slice(0, bytesRead) : buffer;\n    }\n    /**\n     * read and uncompress the data in a chunk (composed of one or more\n     * contiguous bgzip blocks) of the file\n     * @param {Chunk} chunk\n     * @returns {Promise} for a string chunk of the file\n     */\n    async readChunk(chunk, opts = {}) {\n        // fetch the uncompressed data, uncompress carefully a block at a time,\n        // and stop when done\n        const compressedData = await this._readRegion(chunk.minv.blockPosition, chunk.fetchedSize(), opts);\n        try {\n            return (0, bgzf_filehandle_1.unzipChunkSlice)(compressedData, chunk);\n        }\n        catch (e) {\n            throw new Error(`error decompressing chunk ${chunk.toString()} ${e}`);\n        }\n    }\n}\nexports.default = TabixIndexedFile;\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst long_1 = __importDefault(require(\"long\"));\nconst virtualOffset_1 = __importStar(require(\"./virtualOffset\"));\nconst chunk_1 = __importDefault(require(\"./chunk\"));\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst util_1 = require(\"./util\");\nconst indexFile_1 = __importDefault(require(\"./indexFile\"));\nconst TBI_MAGIC = 21578324; // TBI\\1\nconst TAD_LIDX_SHIFT = 14;\n/**\n * calculate the list of bins that may overlap with region [beg,end) (zero-based half-open)\n */\nfunction reg2bins(beg, end) {\n    beg += 1; // < convert to 1-based closed\n    end -= 1;\n    return [\n        [0, 0],\n        [1 + (beg >> 26), 1 + (end >> 26)],\n        [9 + (beg >> 23), 9 + (end >> 23)],\n        [73 + (beg >> 20), 73 + (end >> 20)],\n        [585 + (beg >> 17), 585 + (end >> 17)],\n        [4681 + (beg >> 14), 4681 + (end >> 14)],\n    ];\n}\nclass TabixIndex extends indexFile_1.default {\n    async lineCount(refName, opts = {}) {\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return -1;\n        }\n        const refId = indexData.refNameToId[refName];\n        const idx = indexData.indices[refId];\n        if (!idx) {\n            return -1;\n        }\n        const { stats } = indexData.indices[refId];\n        if (stats) {\n            return stats.lineCount;\n        }\n        return -1;\n    }\n    // memoize\n    // fetch and parse the index\n    async _parse(opts = {}) {\n        const bytes = await (0, bgzf_filehandle_1.unzip)((await this.filehandle.readFile(opts)));\n        (0, util_1.checkAbortSignal)(opts.signal);\n        // check TBI magic numbers\n        if (bytes.readUInt32LE(0) !== TBI_MAGIC /* \"TBI\\1\" */) {\n            throw new Error('Not a TBI file');\n            // TODO: do we need to support big-endian TBI files?\n        }\n        // number of reference sequences in the index\n        const refCount = bytes.readInt32LE(4);\n        const formatFlags = bytes.readInt32LE(8);\n        const coordinateType = formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed';\n        const formatOpts = {\n            0: 'generic',\n            1: 'SAM',\n            2: 'VCF',\n        };\n        const format = formatOpts[formatFlags & 0xf];\n        if (!format) {\n            throw new Error(`invalid Tabix preset format flags ${formatFlags}`);\n        }\n        const columnNumbers = {\n            ref: bytes.readInt32LE(12),\n            start: bytes.readInt32LE(16),\n            end: bytes.readInt32LE(20),\n        };\n        const metaValue = bytes.readInt32LE(24);\n        const depth = 5;\n        const maxBinNumber = ((1 << ((depth + 1) * 3)) - 1) / 7;\n        const maxRefLength = 2 ** (14 + depth * 3);\n        const metaChar = metaValue ? String.fromCharCode(metaValue) : null;\n        const skipLines = bytes.readInt32LE(28);\n        // read sequence dictionary\n        const nameSectionLength = bytes.readInt32LE(32);\n        const { refNameToId, refIdToName } = this._parseNameBytes(bytes.slice(36, 36 + nameSectionLength));\n        // read the indexes for each reference sequence\n        let currOffset = 36 + nameSectionLength;\n        let firstDataLine;\n        const indices = new Array(refCount).fill(0).map(() => {\n            // the binning index\n            const binCount = bytes.readInt32LE(currOffset);\n            currOffset += 4;\n            const binIndex = {};\n            let stats;\n            for (let j = 0; j < binCount; j += 1) {\n                const bin = bytes.readUInt32LE(currOffset);\n                currOffset += 4;\n                if (bin > maxBinNumber + 1) {\n                    throw new Error('tabix index contains too many bins, please use a CSI index');\n                }\n                else if (bin === maxBinNumber + 1) {\n                    const chunkCount = bytes.readInt32LE(currOffset);\n                    currOffset += 4;\n                    if (chunkCount === 2) {\n                        stats = this.parsePseudoBin(bytes, currOffset);\n                    }\n                    currOffset += 16 * chunkCount;\n                }\n                else {\n                    const chunkCount = bytes.readInt32LE(currOffset);\n                    currOffset += 4;\n                    const chunks = new Array(chunkCount);\n                    for (let k = 0; k < chunkCount; k += 1) {\n                        const u = (0, virtualOffset_1.fromBytes)(bytes, currOffset);\n                        const v = (0, virtualOffset_1.fromBytes)(bytes, currOffset + 8);\n                        currOffset += 16;\n                        firstDataLine = this._findFirstData(firstDataLine, u);\n                        chunks[k] = new chunk_1.default(u, v, bin);\n                    }\n                    binIndex[bin] = chunks;\n                }\n            }\n            // the linear index\n            const linearCount = bytes.readInt32LE(currOffset);\n            currOffset += 4;\n            const linearIndex = new Array(linearCount);\n            for (let k = 0; k < linearCount; k += 1) {\n                linearIndex[k] = (0, virtualOffset_1.fromBytes)(bytes, currOffset);\n                currOffset += 8;\n                firstDataLine = this._findFirstData(firstDataLine, linearIndex[k]);\n            }\n            return { binIndex, linearIndex, stats };\n        });\n        return {\n            indices,\n            metaChar,\n            maxBinNumber,\n            maxRefLength,\n            skipLines,\n            firstDataLine,\n            columnNumbers,\n            coordinateType,\n            format,\n            refIdToName,\n            refNameToId,\n            maxBlockSize: 1 << 16,\n        };\n    }\n    parsePseudoBin(bytes, offset) {\n        const lineCount = (0, util_1.longToNumber)(long_1.default.fromBytesLE(bytes.slice(offset + 16, offset + 24), true));\n        return { lineCount };\n    }\n    _parseNameBytes(namesBytes) {\n        let currRefId = 0;\n        let currNameStart = 0;\n        const refIdToName = [];\n        const refNameToId = {};\n        for (let i = 0; i < namesBytes.length; i += 1) {\n            if (!namesBytes[i]) {\n                if (currNameStart < i) {\n                    let refName = namesBytes.toString('utf8', currNameStart, i);\n                    refName = this.renameRefSeq(refName);\n                    refIdToName[currRefId] = refName;\n                    refNameToId[refName] = currRefId;\n                }\n                currNameStart = i + 1;\n                currRefId += 1;\n            }\n        }\n        return { refNameToId, refIdToName };\n    }\n    async blocksForRange(refName, min, max, opts = {}) {\n        if (min < 0) {\n            min = 0;\n        }\n        const indexData = await this.parse(opts);\n        if (!indexData) {\n            return [];\n        }\n        const refId = indexData.refNameToId[refName];\n        const ba = indexData.indices[refId];\n        if (!ba) {\n            return [];\n        }\n        const minOffset = ba.linearIndex.length\n            ? ba.linearIndex[min >> TAD_LIDX_SHIFT >= ba.linearIndex.length\n                ? ba.linearIndex.length - 1\n                : min >> TAD_LIDX_SHIFT]\n            : new virtualOffset_1.default(0, 0);\n        if (!minOffset) {\n            console.warn('querying outside of possible tabix range');\n        }\n        // const { linearIndex, binIndex } = indexes\n        const overlappingBins = reg2bins(min, max); // List of bin #s that overlap min, max\n        const chunks = [];\n        // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n        for (const [start, end] of overlappingBins) {\n            for (let bin = start; bin <= end; bin++) {\n                if (ba.binIndex[bin]) {\n                    const binChunks = ba.binIndex[bin];\n                    for (let c = 0; c < binChunks.length; ++c) {\n                        chunks.push(new chunk_1.default(binChunks[c].minv, binChunks[c].maxv, bin));\n                    }\n                }\n            }\n        }\n        // Use the linear index to find minimum file position of chunks that could\n        // contain alignments in the region\n        const nintv = ba.linearIndex.length;\n        let lowest = null;\n        const minLin = Math.min(min >> 14, nintv - 1);\n        const maxLin = Math.min(max >> 14, nintv - 1);\n        for (let i = minLin; i <= maxLin; ++i) {\n            const vp = ba.linearIndex[i];\n            if (vp) {\n                if (!lowest || vp.compareTo(lowest) < 0) {\n                    lowest = vp;\n                }\n            }\n        }\n        return (0, util_1.optimizeChunks)(chunks, lowest);\n    }\n}\nexports.default = TabixIndex;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.optimizeChunks = exports.canMergeBlocks = exports.abortBreakPoint = exports.checkAbortSignal = exports.longToNumber = void 0;\nfunction longToNumber(long) {\n    if (long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n        long.lessThan(Number.MIN_SAFE_INTEGER)) {\n        throw new Error('integer overflow');\n    }\n    return long.toNumber();\n}\nexports.longToNumber = longToNumber;\nclass AbortError extends Error {\n}\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nfunction checkAbortSignal(signal) {\n    if (!signal) {\n        return;\n    }\n    if (signal.aborted) {\n        // console.log('bam aborted!')\n        if (typeof DOMException !== 'undefined') {\n            // eslint-disable-next-line  no-undef\n            throw new DOMException('aborted', 'AbortError');\n        }\n        else {\n            const e = new AbortError('aborted');\n            e.code = 'ERR_ABORTED';\n            throw e;\n        }\n    }\n}\nexports.checkAbortSignal = checkAbortSignal;\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nasync function abortBreakPoint(signal) {\n    await Promise.resolve();\n    checkAbortSignal(signal);\n}\nexports.abortBreakPoint = abortBreakPoint;\nfunction canMergeBlocks(chunk1, chunk2) {\n    return (chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n        chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000);\n}\nexports.canMergeBlocks = canMergeBlocks;\nfunction optimizeChunks(chunks, lowest) {\n    const mergedChunks = [];\n    let lastChunk = null;\n    if (chunks.length === 0) {\n        return chunks;\n    }\n    chunks.sort(function (c0, c1) {\n        const dif = c0.minv.blockPosition - c1.minv.blockPosition;\n        if (dif !== 0) {\n            return dif;\n        }\n        else {\n            return c0.minv.dataPosition - c1.minv.dataPosition;\n        }\n    });\n    chunks.forEach(chunk => {\n        if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n            if (lastChunk === null) {\n                mergedChunks.push(chunk);\n                lastChunk = chunk;\n            }\n            else {\n                if (canMergeBlocks(lastChunk, chunk)) {\n                    if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n                        lastChunk.maxv = chunk.maxv;\n                    }\n                }\n                else {\n                    mergedChunks.push(chunk);\n                    lastChunk = chunk;\n                }\n            }\n        }\n        // else {\n        //   console.log(`skipping chunk ${chunk}`)\n        // }\n    });\n    return mergedChunks;\n}\nexports.optimizeChunks = optimizeChunks;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.fromBytes = void 0;\nclass VirtualOffset {\n    constructor(blockPosition, dataPosition) {\n        this.blockPosition = blockPosition; // < offset of the compressed data block\n        this.dataPosition = dataPosition; // < offset into the uncompressed data\n    }\n    toString() {\n        return `${this.blockPosition}:${this.dataPosition}`;\n    }\n    compareTo(b) {\n        return (this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition);\n    }\n    static min(...args) {\n        let min;\n        let i = 0;\n        for (; !min; i += 1) {\n            min = args[i];\n        }\n        for (; i < args.length; i += 1) {\n            if (min.compareTo(args[i]) > 0) {\n                min = args[i];\n            }\n        }\n        return min;\n    }\n}\nexports.default = VirtualOffset;\nfunction fromBytes(bytes, offset = 0, bigendian = false) {\n    if (bigendian) {\n        throw new Error('big-endian virtual file offsets not implemented');\n    }\n    return new VirtualOffset(bytes[offset + 7] * 0x10000000000 +\n        bytes[offset + 6] * 0x100000000 +\n        bytes[offset + 5] * 0x1000000 +\n        bytes[offset + 4] * 0x10000 +\n        bytes[offset + 3] * 0x100 +\n        bytes[offset + 2], (bytes[offset + 1] << 8) | bytes[offset]);\n}\nexports.fromBytes = fromBytes;\n"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","module","exports","fn","self","this","args","arguments","apply","err","undefined","__esModule","defineProperty","ownKeys","object","enumerableOnly","keys","Object","getOwnPropertySymbols","symbols","filter","sym","getOwnPropertyDescriptor","enumerable","push","target","i","length","source","forEach","getOwnPropertyDescriptors","defineProperties","objectWithoutPropertiesLoose","excluded","sourceSymbolKeys","indexOf","prototype","propertyIsEnumerable","call","sourceKeys","Chunk","minv","maxv","bin","fetchedSize","_fetchedSize","toUniqueString","b","compareTo","blockPosition","__createBinding","create","o","m","k","k2","get","__setModuleDefault","v","__importStar","mod","result","hasOwnProperty","__importDefault","long_1","require","bgzf_filehandle_1","virtualOffset_1","chunk_1","util_1","indexFile_1","CSI1_MAGIC","CSI2_MAGIC","rshift","num","bits","Math","floor","CSI","maxBinNumber","depth","minShift","refName","opts","parse","indexData","refId","refNameToId","indices","stats","lineCount","Error","bytes","offset","auxLength","refIdToName","formatFlags","readInt32LE","coordinateType","format","columnNumbers","ref","start","end","metaValue","metaChar","String","fromCharCode","skipLines","nameSectionLength","_parseNameBytes","slice","namesBytes","currRefId","currNameStart","toString","renameRefSeq","unzip","filehandle","readFile","readUInt32LE","csiVersion","maxRefLength","aux","parseAuxData","refCount","currOffset","Array","fill","map","binCount","binIndex","j","parsePseudoBin","loffset","fromBytes","firstDataLine","_findFirstData","chunkCount","chunks","u","default","csi","maxBlockSize","longToNumber","fromBytesLE","min","max","ba","overlappingBins","reg2bins","binChunks","c","optimizeChunks","beg","l","t","s","bins","e","TBI","TabixIndexedFile","tabixIndexedFile_1","tbi_1","csi_1","abortable_promise_cache_1","quick_lru_1","IndexFile","renameRefSeqs","n","rest","currentFdl","virtualOffset","_parseCache","cache","maxSize","_parse","seqId","generic_filehandle_1","timeout","time","setTimeout","path","tbiPath","tbiFilehandle","csiPath","csiFilehandle","chunkSizeLimit","chunkCacheSize","TypeError","LocalFile","index","chunkCache","readChunk","bind","options","callback","lineCallback","getMetadata","metadata","checkAbortSignal","signal","blocksForRange","size","toLocaleString","last","Date","now","chunkNum","previousStartCoordinate","buffer","cpositions","dpositions","lines","TextDecoder","decode","split","pop","blockStart","dataPosition","pos","line","checkLine","startCoordinate","overlaps","trim","maxFetch","_readRegion","console","code","lastNewline","newlineByte","charCodeAt","metaByte","getHeaderBuffer","regionRefName","regionStart","regionEnd","charAt","maxColumn","currentColumnNumber","currentColumnStart","refSeq","Infinity","parseInt","_getVcfEnd","endCoordinate","isTRA","prevChar","valueEnd","position","compressedSize","read","Buffer","alloc","bytesRead","chunk","compressedData","unzipChunkSlice","TBI_MAGIC","TabixIndex","linearCount","linearIndex","warn","nintv","lowest","minLin","maxLin","vp","canMergeBlocks","abortBreakPoint","long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","AbortError","aborted","DOMException","chunk1","chunk2","mergedChunks","lastChunk","sort","c0","c1","dif","VirtualOffset","bigendian"],"sourceRoot":""}