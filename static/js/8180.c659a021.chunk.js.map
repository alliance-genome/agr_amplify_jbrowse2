{"version":3,"file":"static/js/8180.c659a021.chunk.js","mappings":"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","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/STARFusionImport.ts"],"sourcesContent":["import { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName?: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc?.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {},\n) {\n  const {\n    hasColumnNameLine = false,\n    columnNameLineNumber = 1,\n    isValidRefName = () => false,\n    selectedAssemblyName,\n  } = options\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (hasColumnNameLine && columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(columnNameLineNumber - 1, 1)\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(rowSet, columnNumber, isValidRefName)\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      for (const row of rowSet.rows) {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, isValidRefName)\n      }\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!hasColumnNameLine,\n    columns,\n    assemblyName: selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n","import { parseTsvBuffer, ParseOptions } from './ImportUtils'\n\nfunction parseSTARFusionBreakpointString(str: string) {\n  const fields = str.split(':')\n  const refName = fields[0]\n  const pos = Number.parseInt(fields[1], 10)\n  const strand = fields[2] === '-' ? -1 : 1\n  return { refName, pos, strand }\n}\n\nconst numericColumns: Record<string, boolean> = {\n  SpanningFragCount: true,\n  FFPM: true,\n  LeftBreakEntropy: true,\n  RightBreakEntropy: true,\n  JunctionReadCount: true,\n}\n\nexport async function parseSTARFusionBuffer(\n  buffer: Buffer,\n  options: ParseOptions,\n) {\n  const data = await parseTsvBuffer(buffer, {\n    hasColumnNameLine: true,\n    columnNameLineNumber: 1,\n    selectedAssemblyName: options.selectedAssemblyName,\n    isValidRefName: () => false,\n  })\n\n  // remove the # in #FusionName\n  data.columns[0].name = data.columns[0].name.replace('#', '')\n  // set some columns to be numeric\n  data.columns.forEach(col => {\n    if (numericColumns[col.name]) {\n      col.dataType = { type: 'Number' }\n    }\n  })\n\n  // decorate each row with a feature object in its extendedData\n  data.rowSet.rows.forEach((row, rowNumber) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const featureData: Record<string, any> = {}\n    row.cells.forEach(({ text }, columnNumber) => {\n      const column = data.columns[columnNumber]\n      if (column.name === 'LeftBreakpoint' && text) {\n        const { refName, pos, strand } = parseSTARFusionBreakpointString(text)\n        featureData.refName = refName\n        featureData.start = pos\n        featureData.end = pos\n        featureData.strand = strand\n      } else if (column.name === 'RightBreakpoint' && text) {\n        const { refName, pos, strand } = parseSTARFusionBreakpointString(text)\n        featureData.mate = {\n          refName,\n          start: pos,\n          end: pos,\n          strand,\n        }\n      } else if (text && numericColumns[column.name]) {\n        // some other column, numeric\n        featureData[column.name] = parseFloat(text)\n      } else {\n        // some other column, text\n        featureData[column.name] = text\n      }\n    })\n    featureData.uniqueId = `sf-${rowNumber + 1}`\n    row.extendedData = {\n      feature: featureData,\n    }\n  })\n\n  return data\n}\n"],"names":["bufferToString","buffer","TextDecoder","fatal","decode","parseWith","_x","_parseWith","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","options","csv","_args","wrap","_context","prev","next","length","undefined","then","module","default","sent","abrupt","_objectSpread","noheader","output","fromString","stop","guessColumnType","rowSet","columnNumber","isValidRefName","_parsedLoc","parsedLoc","text","rows","cells","guessedType","parseLocString","error","refName","start","test","dataToSpreadsheetSnapshot","_options$hasColumnNam","hasColumnNameLine","_options$columnNameLi","columnNameLineNumber","_options$isValidRefNa","selectedAssemblyName","maxCols","isLoaded","map","row","rowNumber","id","String","columnNames","_rowSet$rows$splice","splice","colNamesRow","_slicedToArray","forEach","cell","columns","columnDisplayOrder","push","_step","_iterator","_createForOfIteratorHelper","s","n","done","value","extendedData","err","e","f","name","dataType","type","hasColumnNames","assemblyName","parseCsvBuffer","_x2","_x3","_parseCsvBuffer","_callee2","_context2","parseTsvBuffer","_x4","_x5","_parseTsvBuffer","_callee3","_context3","delimiter","parseSTARFusionBreakpointString","str","fields","split","pos","Number","parseInt","strand","numericColumns","SpanningFragCount","FFPM","LeftBreakEntropy","RightBreakEntropy","JunctionReadCount","parseSTARFusionBuffer","_parseSTARFusionBuffer","data","replace","col","featureData","_ref","column","_parseSTARFusionBreak","end","_parseSTARFusionBreak2","mate","parseFloat","uniqueId","concat","feature"],"sourceRoot":""}