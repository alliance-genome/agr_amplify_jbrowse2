{"version":3,"sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/STARFusionImport.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"names":["parseSTARFusionBreakpointString","str","fields","split","refName","pos","parseInt","strand","numericColumns","SpanningFragCount","FFPM","LeftBreakEntropy","RightBreakEntropy","JunctionReadCount","parseSTARFusionBuffer","buffer","options","a","parseTsvBuffer","hasColumnNameLine","columnNameLineNumber","selectedAssemblyName","isValidRefName","data","columns","name","replace","forEach","col","dataType","type","rowSet","rows","row","rowNumber","featureData","cells","columnNumber","text","column","start","end","mate","parseFloat","uniqueId","extendedData","feature","bufferToString","TextDecoder","fatal","decode","parseWith","then","module","default","csv","noheader","output","fromString","guessColumnType","parsedLoc","guessedType","parseLocString","error","test","dataToSpreadsheetSnapshot","maxCols","isLoaded","map","id","length","String","columnNames","undefined","splice","colNamesRow","cell","columnDisplayOrder","push","hasColumnNames","assemblyName","parseCsvBuffer","delimiter"],"mappings":"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","file":"static/js/41.0684164d.chunk.js","sourcesContent":["import { parseTsvBuffer, ParseOptions } from './ImportUtils'\n\nfunction parseSTARFusionBreakpointString(str: string) {\n  const fields = str.split(':')\n  const refName = fields[0]\n  const pos = parseInt(fields[1], 10)\n  const strand = fields[2] === '-' ? -1 : 1\n  return { refName, pos, strand }\n}\n\nconst numericColumns: Record<string, boolean> = {\n  SpanningFragCount: true,\n  FFPM: true,\n  LeftBreakEntropy: true,\n  RightBreakEntropy: true,\n  JunctionReadCount: true,\n}\n\nexport async function parseSTARFusionBuffer(\n  buffer: Buffer,\n  options: ParseOptions,\n) {\n  const data = await parseTsvBuffer(buffer, {\n    hasColumnNameLine: true,\n    columnNameLineNumber: 1,\n    selectedAssemblyName: options.selectedAssemblyName,\n    isValidRefName: () => false,\n  })\n\n  // remove the # in #FusionName\n  data.columns[0].name = data.columns[0].name.replace('#', '')\n  // set some columns to be numeric\n  data.columns.forEach(col => {\n    if (numericColumns[col.name]) {\n      col.dataType = { type: 'Number' }\n    }\n  })\n\n  // decorate each row with a feature object in its extendedData\n  data.rowSet.rows.forEach((row, rowNumber) => {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const featureData: Record<string, any> = {}\n    row.cells.forEach(({ text }, columnNumber) => {\n      const column = data.columns[columnNumber]\n      if (column.name === 'LeftBreakpoint' && text) {\n        const { refName, pos, strand } = parseSTARFusionBreakpointString(text)\n        featureData.refName = refName\n        featureData.start = pos\n        featureData.end = pos\n        featureData.strand = strand\n      } else if (column.name === 'RightBreakpoint' && text) {\n        const { refName, pos, strand } = parseSTARFusionBreakpointString(text)\n        featureData.mate = {\n          refName,\n          start: pos,\n          end: pos,\n          strand,\n        }\n      } else if (text && numericColumns[column.name]) {\n        // some other column, numeric\n        featureData[column.name] = parseFloat(text)\n      } else {\n        // some other column, text\n        featureData[column.name] = text\n      }\n    })\n    featureData.uniqueId = `sf-${rowNumber + 1}`\n    row.extendedData = {\n      feature: featureData,\n    }\n  })\n\n  return data\n}\n","import { parseLocString } from '@jbrowse/core/util'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf-8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  extendedData?: any\n  cells: {\n    text: string\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0].cells[columnNumber].text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc && parsedLoc.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (options.hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  if (options.hasColumnNameLine && options.columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(\n      options.columnNameLineNumber - 1,\n      1,\n    )\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(\n      rowSet,\n      columnNumber,\n      options.isValidRefName,\n    )\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      rowSet.rows.forEach(row => {\n        const cell = row.cells[columnNumber]\n        cell.extendedData = parseLocString(cell.text, options.isValidRefName)\n      })\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber],\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!options.hasColumnNameLine,\n    columns,\n    assemblyName: options.selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(\n  buffer: Buffer,\n  options: ParseOptions = {\n    hasColumnNameLine: false,\n    columnNameLineNumber: 1,\n    isValidRefName: () => false,\n  },\n) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"sourceRoot":""}