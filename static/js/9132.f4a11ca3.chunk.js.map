{"version":3,"file":"static/js/9132.f4a11ca3.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/MCScanSimpleAnchorsAdapter/MCScanSimpleAnchorsAdapter.ts","../../../plugins/comparative-adapters/src/util.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { doesIntersect2 } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readFile, parseBed } from '../util'\n\ninterface BareFeature {\n  refName: string\n  start: number\n  end: number\n  score: number\n  name: string\n}\n\ntype Row = [\n  BareFeature,\n  BareFeature,\n  BareFeature,\n  BareFeature,\n  number,\n  number,\n  number,\n]\n\nexport default class MCScanAnchorsAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    assemblyNames: string[]\n    feats: Row[]\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  async setup(opts: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n  async setupPre(opts: BaseOptions) {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    const pm = this.pluginManager\n    const bed1 = openLocation(this.getConf('bed1Location'), pm)\n    const bed2 = openLocation(this.getConf('bed2Location'), pm)\n    const mcscan = openLocation(this.getConf('mcscanSimpleAnchorsLocation'), pm)\n    const [bed1text, bed2text, mcscantext] = await Promise.all(\n      [bed1, bed2, mcscan].map(r => readFile(r, opts)),\n    )\n    const bed1Map = parseBed(bed1text)\n    const bed2Map = parseBed(bed2text)\n    const feats = mcscantext\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && f !== '###')\n      .map((line, index) => {\n        const [n11, n12, n21, n22, score, strand] = line.split('\\t')\n        const r11 = bed1Map.get(n11)\n        const r12 = bed1Map.get(n12)\n        const r21 = bed2Map.get(n21)\n        const r22 = bed2Map.get(n22)\n        if (!r11 || !r12 || !r21 || !r22) {\n          throw new Error(\n            `feature not found, ${n11} ${n12} ${n21} ${n22} ${r11} ${r12} ${r21} ${r22}`,\n          )\n        }\n        return [\n          r11,\n          r12,\n          r21,\n          r22,\n          +score,\n          strand === '-' ? -1 : 1,\n          index,\n        ] as Row\n      })\n\n    return {\n      assemblyNames,\n      feats,\n    }\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseFeatureDataAdapter filters it out)\n    return true\n  }\n\n  async getRefNames() {\n    // we cannot determine this accurately\n    return []\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyNames, feats } = await this.setup(opts)\n\n      // The index of the assembly name in the region list corresponds to\n      // the adapter in the subadapters list\n      const index = assemblyNames.indexOf(region.assemblyName)\n      if (index !== -1) {\n        const flip = index === 0\n        feats.forEach(f => {\n          const [f11, f12, f21, f22, score, strand, rowNum] = f\n          let r1 = {\n            refName: f11.refName,\n            start: Math.min(f11.start, f12.start),\n            end: Math.max(f11.end, f12.end),\n          }\n          let r2 = {\n            refName: f21.refName,\n            start: Math.min(f21.start, f22.start),\n            end: Math.max(f21.end, f22.end),\n          }\n          if (!flip) {\n            ;[r2, r1] = [r1, r2]\n          }\n          if (\n            r1.refName === region.refName &&\n            doesIntersect2(r1.start, r1.end, region.start, region.end)\n          ) {\n            observer.next(\n              new SimpleFeature({\n                ...r1,\n                uniqueId: `${rowNum}`,\n                syntenyId: rowNum,\n                assemblyName: assemblyNames[+!flip],\n                score,\n                strand,\n                mate: {\n                  ...r2,\n                  assemblyName: assemblyNames[+flip],\n                },\n              }),\n            )\n          }\n        })\n      }\n\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  freeResources(/* { region } */): void {}\n}\n","import { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nexport function isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start,\n            end: +end,\n            score: +score,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  const buffer = (await file.readFile(opts)) as Buffer\n  return new TextDecoder('utf8', { fatal: true }).decode(\n    isGzip(buffer) ? await unzip(buffer) : buffer,\n  )\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n"],"names":["MCScanAnchorsAdapter","setupP","opts","this","setupPre","catch","e","undefined","assemblyNames","getConf","pm","pluginManager","bed1","openLocation","bed2","mcscan","Promise","all","map","r","readFile","bed1text","bed2text","mcscantext","bed1Map","parseBed","bed2Map","feats","split","filter","f","line","index","n11","n12","n21","n22","score","strand","r11","get","r12","r21","r22","Error","region","ObservableCreate","observer","setup","indexOf","assemblyName","flip","forEach","f11","f12","f21","f22","rowNum","r1","refName","start","Math","min","end","max","r2","doesIntersect2","next","SimpleFeature","uniqueId","syntenyId","mate","complete","BaseFeatureDataAdapter","capabilities","isGzip","buf","text","Map","startsWith","name","file","buffer","TextDecoder","fatal","unzip","decode","zip","a","b","i"],"sourceRoot":""}