{"version":3,"file":"static/js/298.19dd4814.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  FileLocation,\n  NoAssemblyRegion,\n  Region,\n} from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { bytesForRegions } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport VcfParser from '@gmod/vcf'\nimport { Observer } from 'rxjs'\nimport { GenericFilehandle } from 'generic-filehandle'\n\n// local\nimport VcfFeature from '../VcfFeature'\n\nexport default class extends BaseFeatureDataAdapter {\n  private configured?: Promise<{\n    filehandle: GenericFilehandle\n    vcf: TabixIndexedFile\n    parser: VcfParser\n  }>\n\n  private async configurePre() {\n    const pm = this.pluginManager\n    const vcfGzLocation = this.getConf('vcfGzLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n\n    const filehandle = openLocation(vcfGzLocation as FileLocation, pm)\n    const isCSI = indexType === 'CSI'\n    const vcf = new TabixIndexedFile({\n      filehandle,\n      csiFilehandle: isCSI ? openLocation(location, pm) : undefined,\n      tbiFilehandle: !isCSI ? openLocation(location, pm) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n      chunkSizeLimit: 1000000000,\n    })\n\n    const header = await vcf.getHeader()\n    return {\n      filehandle,\n      vcf,\n      parser: new VcfParser({ header }),\n    }\n  }\n\n  protected async configure() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch(e => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure()\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    const { vcf } = await this.configure()\n    return vcf.getHeader()\n  }\n\n  async getMetadata() {\n    const { parser } = await this.configure()\n    return parser.getMetadata()\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { vcf, parser } = await this.configure()\n      await vcf.getLines(refName, start, end, {\n        lineCallback: (line, fileOffset) => {\n          observer.next(\n            new VcfFeature({\n              variant: parser.parseLine(line),\n              parser,\n              id: `${this.id}-vcf-${fileOffset}`,\n            }),\n          )\n        },\n        ...opts,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  /**\n   * Checks if the data source has data for the given reference sequence,\n   * and then gets the features in the region if it does\n   *\n   * Currently this just calls getFeatureInRegion for each region. Adapters that\n   * are frequently called on multiple regions simultaneously may want to\n   * implement a more efficient custom version of this method.\n   *\n   * Also includes a bit of extra logging to warn when fetching a large portion\n   * of a VCF\n   * @param regions - Regions\n   * @param opts - Feature adapter options\n   * @returns Observable of Feature objects in the regions\n   */\n  public getFeaturesInMultipleRegions(\n    regions: Region[],\n    opts: BaseOptions = {},\n  ) {\n    return ObservableCreate<Feature>(async (observer: Observer<Feature>) => {\n      const { vcf } = await this.configure()\n\n      // @ts-ignore\n      const bytes = await bytesForRegions(regions, vcf.index)\n      const { filehandle } = await this.configure()\n      const stat = await filehandle.stat()\n      let pct = Math.round((bytes / stat.size) * 100)\n      if (pct > 100) {\n        // this is just a bad estimate, make 100% if it goes over\n        pct = 100\n      }\n      if (pct > 60) {\n        console.warn(\n          `getFeaturesInMultipleRegions fetching ${pct}% of VCF file, but whole-file streaming not yet implemented`,\n        )\n      }\n      super.getFeaturesInMultipleRegions(regions, opts).subscribe(observer)\n    })\n  }\n\n  public freeResources(/* { region } */): void {}\n}\n"],"names":["configured","pm","this","pluginManager","vcfGzLocation","getConf","location","indexType","filehandle","openLocation","isCSI","vcf","TabixIndexedFile","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","chunkSizeLimit","getHeader","header","parser","VcfParser","configurePre","catch","e","opts","configure","getReferenceSequenceNames","getMetadata","query","ObservableCreate","observer","refName","start","end","getLines","lineCallback","line","fileOffset","next","VcfFeature","variant","parseLine","id","complete","signal","regions","bytesForRegions","index","bytes","stat","pct","Math","round","size","console","warn","subscribe","BaseFeatureDataAdapter"],"sourceRoot":""}