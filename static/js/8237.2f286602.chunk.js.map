{"version":3,"file":"static/js/8237.2f286602.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/indexedfasta/src/indexedFasta.ts","../../../node_modules/@gmod/indexedfasta/src/bgzipIndexedFasta.ts","../../../node_modules/@gmod/indexedfasta/src/index.ts","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js"],"sourcesContent":["import { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface IndexEntry {\n  offset: number\n  lineBytes: number\n  lineLength: number\n  length: number\n}\n\nfunction _faiOffset(idx: IndexEntry, pos: number) {\n  return (\n    idx.offset +\n    idx.lineBytes * Math.floor(pos / idx.lineLength) +\n    (pos % idx.lineLength)\n  )\n}\n\nasync function readFAI(fai: GenericFilehandle, opts?: BaseOpts) {\n  const text = await fai.readFile(opts)\n  if (!(text && text.length)) {\n    throw new Error('No data read from FASTA index (FAI) file')\n  }\n\n  let idCounter = 0\n  let currSeq: { name: string; id: number } | undefined\n  const data = text\n    .toString('utf8')\n    .split(/\\r?\\n/)\n    .filter(line => /\\S/.test(line))\n    .map(line => line.split('\\t'))\n    .filter(row => row[0] !== '')\n    .map(row => {\n      if (!currSeq || currSeq.name !== row[0]) {\n        currSeq = { name: row[0], id: idCounter }\n        idCounter += 1\n      }\n\n      return {\n        id: currSeq.id,\n        name: row[0],\n        length: +row[1],\n        start: 0,\n        end: +row[1],\n        offset: +row[2],\n        lineLength: +row[3],\n        lineBytes: +row[4],\n      }\n    })\n\n  return {\n    name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n    id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n  }\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  chunkSizeLimit: number\n  indexes?: ReturnType<typeof readFAI>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n    chunkSizeLimit = 1000000,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n    chunkSizeLimit?: number\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n    this.chunkSizeLimit = chunkSizeLimit\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts)\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return Object.keys((await this._getIndexes(opts)).name)\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const returnObject = {} as { [key: string]: number }\n    const idx = await this._getIndexes(opts)\n    const vals = Object.values(idx.id)\n    for (let i = 0; i < vals.length; i += 1) {\n      returnObject[vals[i].name] = vals[i].length\n    }\n    return returnObject\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    return idx.name[seqName]?.length\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return !!(await this._getIndexes(opts)).name[name]\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesById(\n    seqId: number,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).id[seqId]\n    if (!indexEntry) {\n      return undefined\n    }\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  /**\n   * @param {string} seqName\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).name[seqName]\n    if (!indexEntry) {\n      return undefined\n    }\n\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndexEntry(\n    indexEntry: IndexEntry,\n    min = 0,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > indexEntry.length) {\n      end = indexEntry.length\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(indexEntry, min)\n    const readlen = _faiOffset(indexEntry, end) - position\n\n    if (readlen > this.chunkSizeLimit) {\n      throw new Error(\n        `data size of ${readlen.toLocaleString()} bytes exceeded chunk size limit of ${this.chunkSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n\n    const residues = Buffer.allocUnsafe(readlen)\n    await this.fasta.read(residues, 0, readlen, position, opts)\n    return residues.toString('utf8').replace(/\\s+/g, '')\n  }\n}\n","import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport IndexedFasta from './indexedFasta'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n    chunkSizeLimit,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n    chunkSizeLimit?: number\n  }) {\n    super({ fasta, path, fai, faiPath, chunkSizeLimit })\n    if (fasta && gzi) {\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      this.fasta = new BgzfFilehandle({ path, gziPath })\n    }\n  }\n}\n","import fromEntries from 'object.fromentries'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\nimport BgzipIndexedFasta from './bgzipIndexedFasta'\nimport IndexedFasta from './indexedFasta'\n\nif (!Object.fromEntries) {\n  // @ts-ignore\n  fromEntries.shim()\n}\n\nfunction parseSmallFasta(text: string) {\n  return text\n    .split('>')\n    .filter(t => /\\S/.test(t))\n    .map(entryText => {\n      const [defLine, ...seqLines] = entryText.split('\\n')\n      const [id, ...description] = defLine.split(' ')\n      const sequence = seqLines.join('').replace(/\\s/g, '')\n      return {\n        id,\n        description: description.join(' '),\n        sequence,\n      }\n    })\n}\n\n// memoized\nclass FetchableSmallFasta {\n  fasta: GenericFilehandle\n\n  data: Promise<{ id: string; description: string; sequence: string }[]>\n\n  constructor({ fasta, path }: { fasta: GenericFilehandle; path: string }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass fasta or path')\n    }\n    this.data = this.fasta.readFile().then(buffer => {\n      const text = buffer.toString('utf8')\n      return parseSmallFasta(text)\n    })\n  }\n\n  async fetch(id: string, start: number, end: number) {\n    const data = await this.data\n    const entry = data.find(iter => iter.id === id)\n    const length = end - start\n    if (!entry) {\n      throw new Error(`no sequence with id ${id} exists`)\n    }\n    return entry.sequence.substr(start, length)\n  }\n\n  async getSequenceNames() {\n    const data = await this.data\n    return data.map(entry => entry.id)\n  }\n}\n\nexport { parseSmallFasta, FetchableSmallFasta, IndexedFasta, BgzipIndexedFasta }\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n"],"names":["_faiOffset","idx","pos","offset","lineBytes","Math","floor","lineLength","readFAI","fai","opts","readFile","text","length","Error","idCounter","data","toString","split","filter","line","test","map","row","currSeq","name","id","start","end","Object","fromEntries","entry","IndexedFasta","fasta","path","faiPath","chunkSizeLimit","this","LocalFile","indexes","_getIndexes","keys","returnObject","vals","values","i","seqName","_a","seqId","min","max","indexEntry","undefined","_fetchFromIndexEntry","getResiduesByName","TypeError","position","readlen","toLocaleString","residues","Buffer","allocUnsafe","read","replace","BgzipIndexedFasta","gzi","gziPath","BgzfFilehandle","filehandle","gziFilehandle","__importDefault","mod","__esModule","defineProperty","exports","value","abortcontroller_ponyfill_1","require","AggregateAbortController_1","AggregateStatusReporter_1","AbortablePromiseCache","fill","cache","get","set","delete","fillCallback","key","signal","statusCallback","aborter","default","statusReporter","addCallback","newEntry","promise","message","callback","settled","aborted","addSignal","addEventListener","evict","then","catch","e","console","error","has","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","result","next","done","exception","code","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","size","AggregateStatusReporter","callbacks","currentMessage","forEach","elt","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1"],"sourceRoot":""}