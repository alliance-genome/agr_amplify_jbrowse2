{"version":3,"file":"static/js/3967.f73ed71c.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/LinearReadArcsDisplay/drawFeats.ts","../../../plugins/alignments/src/shared/util.ts"],"sourcesContent":["import { getContainingView, getSession } from '@jbrowse/core/util'\nimport { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\nimport { Assembly } from '@jbrowse/core/assemblyManager/assembly'\n\n// locals\nimport {\n  getPairedOrientationColor,\n  getPairedInsertSizeColor,\n  getPairedInsertSizeAndOrientationColor,\n} from '../shared/color'\nimport { featurizeSA } from '../MismatchParser'\nimport { LinearReadArcsDisplayModel } from './model'\nimport { hasPairedReads } from '../shared/util'\n\ntype LGV = LinearGenomeViewModel\n\nfunction jitter(n: number) {\n  return Math.random() * 2 * n - n\n}\n\ninterface CoreFeat {\n  strand: number\n  refName: string\n  start: number\n  end: number\n}\n\nfunction drawLineAtOffset(\n  ctx: CanvasRenderingContext2D,\n  offset: number,\n  height: number,\n  color: string,\n) {\n  // draws a vertical line off to middle of nowhere if the second end not found\n  ctx.strokeStyle = color\n  ctx.beginPath()\n  ctx.moveTo(offset, 0)\n  ctx.lineTo(offset, height)\n  ctx.stroke()\n}\n\nexport function drawFeats(\n  self: LinearReadArcsDisplayModel,\n  ctx: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n) {\n  const {\n    chainData,\n    colorBy,\n    drawInter,\n    drawLongRange,\n    lineWidthSetting,\n    jitterVal,\n  } = self\n  if (!chainData) {\n    return\n  }\n  const view = getContainingView(self) as LGV\n  const { assemblyManager } = getSession(self)\n  const { chains, stats } = chainData\n  const hasPaired = hasPairedReads(chainData)\n  const asm = assemblyManager.get(view.assemblyNames[0])\n  const type = colorBy?.type || 'insertSizeAndOrientation'\n  if (!asm) {\n    return\n  }\n  ctx.lineWidth = lineWidthSetting\n\n  function draw(\n    k1: CoreFeat & { tlen?: number; pair_orientation?: string },\n    k2: CoreFeat,\n    assembly: Assembly,\n    longRange?: boolean,\n  ) {\n    const s1 = k1.strand\n    const s2 = k2.strand\n    const f1 = s1 === -1\n    const f2 = s2 === -1\n\n    const p1 = f1 ? k1.start : k1.end\n    const p2 = hasPaired ? (f2 ? k2.start : k2.end) : f2 ? k2.end : k2.start\n    const ra1 = assembly.getCanonicalRefName(k1.refName) || k1.refName\n    const ra2 = assembly.getCanonicalRefName(k2.refName) || k2.refName\n    const r1 = view.bpToPx({ refName: ra1, coord: p1 })?.offsetPx\n    const r2 = view.bpToPx({ refName: ra2, coord: p2 })?.offsetPx\n\n    if (r1 !== undefined && r2 !== undefined) {\n      const radius = (r2 - r1) / 2\n      const absrad = Math.abs(radius)\n      const p = r1 - view.offsetPx\n      const p2 = r2 - view.offsetPx\n      const drawArcInsteadOfBezier = absrad > 10_000\n\n      // bezier (used for non-long-range arcs) requires moveTo before beginPath\n      // arc (used for long-range) requires moveTo after beginPath (or else a\n      // unwanted line at y=0 is rendered along with the arc)\n      if (longRange && drawArcInsteadOfBezier) {\n        ctx.moveTo(p, 0)\n        ctx.beginPath()\n      } else {\n        ctx.beginPath()\n        ctx.moveTo(p, 0)\n      }\n\n      if (longRange && drawArcInsteadOfBezier) {\n        ctx.strokeStyle = 'red'\n      } else {\n        if (hasPaired) {\n          if (type === 'insertSizeAndOrientation') {\n            ctx.strokeStyle = getPairedInsertSizeAndOrientationColor(\n              k1,\n              k2,\n              stats,\n            )[0]\n          } else if (type === 'orientation') {\n            ctx.strokeStyle = getPairedOrientationColor(k1)[0]\n          } else if (type === 'insertSize') {\n            ctx.strokeStyle =\n              getPairedInsertSizeColor(k1, k2, stats)?.[0] || 'grey'\n          } else if (type === 'gradient') {\n            ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`\n          }\n        } else {\n          if (type === 'orientation' || type === 'insertSizeAndOrientation') {\n            if (s1 === -1 && s2 === 1) {\n              ctx.strokeStyle = 'navy'\n            } else if (s1 === 1 && s2 === -1) {\n              ctx.strokeStyle = 'green'\n            } else {\n              ctx.strokeStyle = 'grey'\n            }\n          } else if (type === 'gradient') {\n            ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`\n          }\n        }\n      }\n\n      const destX = p + radius * 2\n      const destY = Math.min(height + jitter(jitterVal), absrad)\n      if (longRange) {\n        // avoid drawing gigantic circles that glitch out the rendering,\n        // instead draw vertical lines\n        if (absrad > 100_000) {\n          drawLineAtOffset(ctx, p + jitter(jitterVal), height, 'red')\n          drawLineAtOffset(ctx, p2 + jitter(jitterVal), height, 'red')\n        } else if (drawArcInsteadOfBezier) {\n          ctx.arc(p + radius + jitter(jitterVal), 0, absrad, 0, Math.PI)\n          ctx.stroke()\n        } else {\n          ctx.bezierCurveTo(\n            p + jitter(jitterVal),\n            destY,\n            destX,\n            destY,\n            destX + jitter(jitterVal),\n            0,\n          )\n          ctx.stroke()\n        }\n      } else {\n        ctx.bezierCurveTo(\n          p + jitter(jitterVal),\n          destY,\n          destX,\n          destY,\n          destX + jitter(jitterVal),\n          0,\n        )\n        ctx.stroke()\n      }\n    } else if (r1 && drawInter) {\n      drawLineAtOffset(ctx, r1 - view.offsetPx, height, 'purple')\n    }\n  }\n\n  for (const chain of chains) {\n    // chain.length === 1, singleton (other pairs/mates not in view)\n    if (chain.length === 1 && drawLongRange) {\n      const f = chain[0]\n      if (hasPaired && !(f.flags & 8)) {\n        const mate = {\n          refName: f.next_ref || '',\n          start: f.next_pos || 0,\n          end: f.next_pos || 0,\n          strand: f.strand,\n        }\n        draw(f, mate, asm, true)\n      } else {\n        const features = [f, ...featurizeSA(f.SA, f.id, f.strand, f.name)].sort(\n          (a, b) => a.clipPos - b.clipPos,\n        )\n        for (let i = 0; i < features.length - 1; i++) {\n          const f = features[i]\n          const v1 = features[i + 1]\n          draw(f, v1, asm, true)\n        }\n      }\n    } else {\n      const res = hasPaired\n        ? chain.filter(f => !(f.flags & 2048) && !(f.flags & 8))\n        : chain\n            .sort((a, b) => a.clipPos - b.clipPos)\n            .filter(f => !(f.flags & 256))\n      for (let i = 0; i < res.length - 1; i++) {\n        draw(res[i], res[i + 1], asm, false)\n      }\n    }\n  }\n}\n","import { ChainData } from './fetchChains'\n\nexport function hasPairedReads(features: ChainData) {\n  for (const f of features.chains.values()) {\n    if (f[0].flags & 1) {\n      return true\n    }\n  }\n  return false\n}\n"],"names":["jitter","n","Math","random","drawLineAtOffset","ctx","offset","height","color","strokeStyle","beginPath","moveTo","lineTo","stroke","drawFeats","self","width","chainData","colorBy","drawInter","drawLongRange","lineWidthSetting","jitterVal","view","getContainingView","assemblyManager","getSession","chains","stats","hasPaired","hasPairedReads","asm","get","assemblyNames","type","lineWidth","_step","_iterator","_createForOfIteratorHelper","s","done","chain","value","length","f","flags","features","concat","_toConsumableArray","featurizeSA","SA","id","strand","name","sort","a","b","clipPos","i","draw","refName","next_ref","start","next_pos","end","res","filter","err","e","k1","k2","assembly","longRange","_view$bpToPx","_view$bpToPx2","s1","s2","f2","p1","p2","ra1","getCanonicalRefName","ra2","r1","bpToPx","coord","offsetPx","r2","undefined","radius","absrad","abs","p","drawArcInsteadOfBezier","getPairedInsertSizeAndOrientationColor","getPairedOrientationColor","_getPairedInsertSizeC","getPairedInsertSizeColor","log10","destX","destY","min","arc","PI","bezierCurveTo","values"],"sourceRoot":""}