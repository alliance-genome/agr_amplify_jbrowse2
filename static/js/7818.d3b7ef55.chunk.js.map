{"version":3,"file":"static/js/7818.d3b7ef55.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/indexedfasta/src/indexedFasta.ts","../../../node_modules/@gmod/indexedfasta/src/bgzipIndexedFasta.ts","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js"],"sourcesContent":["import { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface IndexEntry {\n  offset: number\n  lineBytes: number\n  lineLength: number\n  length: number\n}\n\nfunction _faiOffset(idx: IndexEntry, pos: number) {\n  return (\n    idx.offset +\n    idx.lineBytes * Math.floor(pos / idx.lineLength) +\n    (pos % idx.lineLength)\n  )\n}\n\nasync function readFAI(fai: GenericFilehandle, opts?: BaseOpts) {\n  const text = await fai.readFile(opts)\n  if (!(text && text.length)) {\n    throw new Error('No data read from FASTA index (FAI) file')\n  }\n\n  let idCounter = 0\n  let currSeq: { name: string; id: number } | undefined\n  const data = text\n    .toString('utf8')\n    .split(/\\r?\\n/)\n    .filter(line => /\\S/.test(line))\n    .map(line => line.split('\\t'))\n    .filter(row => row[0] !== '')\n    .map(row => {\n      if (!currSeq || currSeq.name !== row[0]) {\n        currSeq = { name: row[0], id: idCounter }\n        idCounter += 1\n      }\n\n      return {\n        id: currSeq.id,\n        name: row[0],\n        length: +row[1],\n        start: 0,\n        end: +row[1],\n        offset: +row[2],\n        lineLength: +row[3],\n        lineBytes: +row[4],\n      }\n    })\n\n  return {\n    name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n    id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n  }\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  chunkSizeLimit: number\n  indexes?: ReturnType<typeof readFAI>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n    chunkSizeLimit = 1000000,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n    chunkSizeLimit?: number\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n    this.chunkSizeLimit = chunkSizeLimit\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts)\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return Object.keys((await this._getIndexes(opts)).name)\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const returnObject = {} as { [key: string]: number }\n    const idx = await this._getIndexes(opts)\n    const vals = Object.values(idx.id)\n    for (let i = 0; i < vals.length; i += 1) {\n      returnObject[vals[i].name] = vals[i].length\n    }\n    return returnObject\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    return idx.name[seqName]?.length\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return !!(await this._getIndexes(opts)).name[name]\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesById(\n    seqId: number,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).id[seqId]\n    if (!indexEntry) {\n      return undefined\n    }\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  /**\n   * @param {string} seqName\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).name[seqName]\n    if (!indexEntry) {\n      return undefined\n    }\n\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndexEntry(\n    indexEntry: IndexEntry,\n    min = 0,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > indexEntry.length) {\n      end = indexEntry.length\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(indexEntry, min)\n    const readlen = _faiOffset(indexEntry, end) - position\n\n    if (readlen > this.chunkSizeLimit) {\n      throw new Error(\n        `data size of ${readlen.toLocaleString()} bytes exceeded chunk size limit of ${this.chunkSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n\n    const residues = Buffer.allocUnsafe(readlen)\n    await this.fasta.read(residues, 0, readlen, position, opts)\n    return residues.toString('utf8').replace(/\\s+/g, '')\n  }\n}\n","import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport IndexedFasta from './indexedFasta'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n    chunkSizeLimit,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n    chunkSizeLimit?: number\n  }) {\n    super({ fasta, path, fai, faiPath, chunkSizeLimit })\n    if (fasta && gzi) {\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      this.fasta = new BgzfFilehandle({ path, gziPath })\n    }\n  }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n"],"names":["_faiOffset","idx","pos","offset","lineBytes","Math","floor","lineLength","readFAI","fai","opts","readFile","text","length","Error","idCounter","data","toString","split","filter","line","test","map","row","currSeq","name","id","start","end","Object","fromEntries","entry","IndexedFasta","fasta","path","faiPath","chunkSizeLimit","this","LocalFile","indexes","_getIndexes","keys","returnObject","vals","values","i","seqName","seqId","min","max","indexEntry","undefined","_fetchFromIndexEntry","getResiduesByName","TypeError","position","readlen","toLocaleString","residues","Buffer","allocUnsafe","read","replace","BgzipIndexedFasta","gzi","gziPath","BgzfFilehandle","filehandle","gziFilehandle","__importDefault","mod","__esModule","defineProperty","exports","value","abortcontroller_ponyfill_1","require","AggregateAbortController_1","AggregateStatusReporter_1","AbortablePromiseCache","fill","cache","get","set","delete","fillCallback","key","signal","statusCallback","aborter","default","statusReporter","addCallback","newEntry","promise","message","callback","settled","aborted","addSignal","addEventListener","evict","then","catch","e","console","error","has","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","result","next","done","exception","code","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","size","AggregateStatusReporter","callbacks","currentMessage","forEach","elt","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1"],"sourceRoot":""}