{"version":3,"file":"static/js/6925.043dfd9a.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/cram/src/unzip-pako.ts","../../../node_modules/@gmod/cram/src/errors.js","../../../node_modules/@gmod/cram/src/rans/constants.js","../../../node_modules/@gmod/cram/src/rans/decoding.js","../../../node_modules/@gmod/cram/src/rans/frequencies.js","../../../node_modules/@gmod/cram/src/rans/index.js","../../../node_modules/@gmod/cram/src/rans/d04.js","../../../node_modules/@gmod/cram/src/rans/d14.js","../../../node_modules/@gmod/cram/src/cramFile/sectionParsers.js","../../../node_modules/@gmod/cram/src/cramFile/util.js","../../../node_modules/@gmod/cram/src/cramFile/constants.js","../../../node_modules/@gmod/cram/src/cramFile/record.js","../../../node_modules/@gmod/cram/src/cramFile/slice/decodeRecord.js","../../../node_modules/@gmod/cram/src/cramFile/slice/index.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/_base.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/huffman.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/external.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/byteArrayStop.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/byteArrayLength.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/beta.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/gamma.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/subexp.js","../../../node_modules/@gmod/cram/src/cramFile/codecs/index.js","../../../node_modules/@gmod/cram/src/cramFile/container/compressionScheme.js","../../../node_modules/@gmod/cram/src/cramFile/container/index.js","../../../node_modules/@gmod/cram/src/io/bufferCache.js","../../../node_modules/@gmod/cram/src/io/remoteFile.js","../../../node_modules/@gmod/cram/src/io/index.js","../../../node_modules/@gmod/cram/src/sam.js","../../../node_modules/@gmod/cram/src/cramFile/file.js","../../../node_modules/@gmod/cram/src/cramFile/index.js","../../../node_modules/@gmod/cram/src/indexedCramFile.js","../../../node_modules/@gmod/cram/src/craiIndex.js","../../../node_modules/@gmod/cram/node_modules/quick-lru/index.js","../../../node_modules/@jkbonfield/htscodecs/arith_gen.js","../../../node_modules/@jkbonfield/htscodecs/arith_sh.js","../../../node_modules/@jkbonfield/htscodecs/byte_model.js","../../../node_modules/@jkbonfield/htscodecs/fqzcomp.js","../../../node_modules/@jkbonfield/htscodecs/index.js","../../../node_modules/@jkbonfield/htscodecs/iostream.js","../../../node_modules/@jkbonfield/htscodecs/rans.js","../../../node_modules/@jkbonfield/htscodecs/rans4x16.js","../../../node_modules/@jkbonfield/htscodecs/tok3.js","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js","../../../node_modules/bzip2/bzip2.js","../../../node_modules/charenc/charenc.js","../../../node_modules/cross-fetch/dist/browser-ponyfill.js","../../../node_modules/crypt/crypt.js","../../../node_modules/is-buffer/index.js","../../../node_modules/md5/md5.js"],"sourcesContent":["import { inflate } from 'pako'\n\nexport function unzip(input: Buffer) {\n  return Buffer.from(inflate(input))\n}\n","export class CramError extends Error {}\n\n/** Error caused by encountering a part of the CRAM spec that has not yet been implemented */\nexport class CramUnimplementedError extends Error {}\n\n/** An error caused by malformed data.  */\nexport class CramMalformedError extends CramError {}\n\n/**\n * An error caused by attempting to read beyond the end of the defined data.\n */\nexport class CramBufferOverrunError extends CramMalformedError {}\n\n/**\n * An error caused by data being too big, exceeding a size limit.\n */\nexport class CramSizeLimitError extends CramError {}\n\n/**\n * An invalid argument was supplied to a cram-js method or object.\n */\nexport class CramArgumentError extends CramError {}\n","const TF_SHIFT = 12\nconst TOTFREQ = 1 << TF_SHIFT\nconst RANS_BYTE_L = 1 << 23\n\nexport { TF_SHIFT, TOTFREQ, RANS_BYTE_L }\n","import { CramMalformedError } from '../errors'\n\nimport { RANS_BYTE_L } from './constants'\n\nclass FC {\n  // int F, C;\n  constructor() {\n    this.F = undefined\n    this.C = undefined\n  }\n}\n\nclass AriDecoder {\n  // final FC[] fc = new FC[256];\n  // byte[] R;\n\n  constructor() {\n    this.fc = new Array(256)\n    for (let i = 0; i < this.fc.length; i += 1) {\n      this.fc[i] = new FC()\n    }\n    this.R = null\n  }\n}\n\nclass Symbol {\n  // int start; // Start of range.\n  // int freq; // Symbol frequency.\n  constructor() {\n    this.start = undefined\n    this.freq = undefined\n  }\n}\n\n// Initialize a decoder symbol to start \"start\" and frequency \"freq\"\nfunction symbolInit(sym, start, freq) {\n  if (!(start <= 1 << 16)) {\n    throw new CramMalformedError(`assertion failed: start <= 1<<16`)\n  }\n  if (!(freq <= (1 << 16) - start)) {\n    throw new CramMalformedError(`assertion failed: freq <= 1<<16`)\n  }\n  sym.start = start\n  sym.freq = freq\n}\n\n// Advances in the bit stream by \"popping\" a single symbol with range start\n// \"start\" and frequency \"freq\". All frequencies are assumed to sum to\n// \"1 << scaleBits\".\n// No renormalization or output happens.\n/* private static int */ function advanceStep(\n  /* final int */ r,\n  /* final int */ start,\n  /* final int */ freq,\n  /* final int */ scaleBits,\n) {\n  /* final int */ const mask = (1 << scaleBits) - 1\n\n  // s, x = D(x)\n  return freq * (r >> scaleBits) + (r & mask) - start\n}\n\n// Equivalent to RansDecAdvanceStep that takes a symbol.\n/* static int  */ function advanceSymbolStep(\n  /* final int */ r,\n  /* final RansDecSymbol */ sym,\n  /* final int */ scaleBits,\n) {\n  return advanceStep(r, sym.start, sym.freq, scaleBits)\n}\n\n// Returns the current cumulative frequency (map it to a symbol yourself!)\n/* static int */ function get(/* final int */ r, /* final int */ scaleBits) {\n  return r & ((1 << scaleBits) - 1)\n}\n\n// Advances in the bit stream by \"popping\" a single symbol with range start\n// \"start\" and frequency \"freq\". All frequencies are assumed to sum to\n// \"1 << scaleBits\",\n// and the resulting bytes get written to ptr (which is updated).\n/* private static int */ function advance(\n  /* int */ r,\n  /* final ByteBuffer */ pptr,\n  /* final int */ start,\n  /* final int */ freq,\n  /* final int */ scaleBits,\n) {\n  /* final int */ const mask = (1 << scaleBits) - 1\n\n  // s, x = D(x)\n  r = freq * (r >> scaleBits) + (r & mask) - start\n\n  // re-normalize\n  if (r < RANS_BYTE_L) {\n    do {\n      /* final int */ const b = 0xff & pptr.get()\n      r = (r << 8) | b\n    } while (r < RANS_BYTE_L)\n  }\n\n  return r\n}\n\n// Equivalent to RansDecAdvance that takes a symbol.\n/*  static int */ function advanceSymbol(\n  /* final int */ r,\n  /* final ByteBuffer */ pptr,\n  /* final RansDecSymbol */ sym,\n  /* final int */ scaleBits,\n) {\n  return advance(r, pptr, sym.start, sym.freq, scaleBits)\n}\n\n// Re-normalize.\n/*  static int */ function renormalize(\n  /* int */ r,\n  /* final ByteBuffer */ pptr,\n) {\n  // re-normalize\n  if (r < RANS_BYTE_L) {\n    do {\n      r = (r << 8) | (0xff & pptr.get())\n    } while (r < RANS_BYTE_L)\n  }\n\n  return r\n}\n\nconst Decode = {\n  FC,\n  AriDecoder,\n  Symbol,\n  symbolInit,\n  advanceStep,\n  advanceSymbolStep,\n  get,\n  advanceSymbol,\n  renormalize,\n}\n\nexport default Decode\n","import { CramMalformedError } from '../errors'\n\nimport { TOTFREQ } from './constants'\nimport Decoding from './decoding'\n\nfunction assert(result) {\n  if (!result) {\n    throw new CramMalformedError('assertion failed')\n  }\n}\n\nexport function readStatsO0(\n  /* ByteBuffer */ cp,\n  /* Decoding.AriDecoder */ decoder,\n  /* Decoding.RansDecSymbol[] */ syms,\n) {\n  // Pre-compute reverse lookup of frequency.\n  let rle = 0\n  let x = 0\n  let j = cp.get() & 0xff\n  do {\n    if (decoder.fc[j] == null) {\n      decoder.fc[j] = new Decoding.FC()\n    }\n    decoder.fc[j].F = cp.get() & 0xff\n    if (decoder.fc[j].F >= 128) {\n      decoder.fc[j].F &= ~128\n      decoder.fc[j].F = ((decoder.fc[j].F & 127) << 8) | (cp.get() & 0xff)\n    }\n    decoder.fc[j].C = x\n\n    Decoding.symbolInit(syms[j], decoder.fc[j].C, decoder.fc[j].F)\n\n    /* Build reverse lookup table */\n    if (!decoder.R) {\n      decoder.R = new Array(TOTFREQ)\n    }\n    decoder.R.fill(j, x, x + decoder.fc[j].F)\n\n    x += decoder.fc[j].F\n\n    if (rle === 0 && j + 1 === (0xff & cp.getByteAt(cp.position()))) {\n      j = cp.get() & 0xff\n      rle = cp.get() & 0xff\n    } else if (rle !== 0) {\n      rle -= 1\n      j += 1\n    } else {\n      j = cp.get() & 0xff\n    }\n  } while (j !== 0)\n\n  assert(x < TOTFREQ)\n}\n\nexport function readStatsO1(\n  /* ByteBuffer */ cp,\n  /*  Decoding.AriDecoder[] */ D,\n  /* Decoding.RansDecSymbol[][] */ syms,\n) {\n  let rlei = 0\n  let i = 0xff & cp.get()\n  do {\n    let rlej = 0\n    let x = 0\n    let j = 0xff & cp.get()\n    if (D[i] == null) {\n      D[i] = new Decoding.AriDecoder()\n    }\n    do {\n      if (D[i].fc[j] == null) {\n        D[i].fc[j] = new Decoding.FC()\n      }\n      D[i].fc[j].F = 0xff & cp.get()\n      if (D[i].fc[j].F >= 128) {\n        D[i].fc[j].F &= ~128\n        D[i].fc[j].F = ((D[i].fc[j].F & 127) << 8) | (0xff & cp.get())\n      }\n      D[i].fc[j].C = x\n\n      if (D[i].fc[j].F === 0) {\n        D[i].fc[j].F = TOTFREQ\n      }\n\n      if (syms[i][j] == null) {\n        syms[i][j] = new Decoding.RansDecSymbol()\n      }\n\n      Decoding.symbolInit(syms[i][j], D[i].fc[j].C, D[i].fc[j].F)\n\n      /* Build reverse lookup table */\n      if (D[i].R == null) {\n        D[i].R = new Array(TOTFREQ)\n      }\n      D[i].R.fill(j, x, x + D[i].fc[j].F)\n\n      x += D[i].fc[j].F\n      assert(x <= TOTFREQ)\n\n      if (rlej === 0 && j + 1 === (0xff & cp.getByteAt(cp.position()))) {\n        j = 0xff & cp.get()\n        rlej = 0xff & cp.get()\n      } else if (rlej !== 0) {\n        rlej -= 1\n        j += 1\n      } else {\n        j = 0xff & cp.get()\n      }\n    } while (j !== 0)\n\n    if (rlei === 0 && i + 1 === (0xff & cp.getByteAt(cp.position()))) {\n      i = 0xff & cp.get()\n      rlei = 0xff & cp.get()\n    } else if (rlei !== 0) {\n      rlei -= 1\n      i += 1\n    } else {\n      i = 0xff & cp.get()\n    }\n  } while (i !== 0)\n}\n","import { CramMalformedError } from '../errors'\n\nimport Decoding from './decoding'\nimport { readStatsO0, readStatsO1 } from './frequencies'\n\nimport D04 from './d04'\nimport D14 from './d14'\n\n// const /* int */ ORDER_BYTE_LENGTH = 1\n// const /* int */ COMPRESSED_BYTE_LENGTH = 4\nconst /* int */ RAW_BYTE_LENGTH = 4\n// const /* int */ PREFIX_BYTE_LENGTH =\n//   ORDER_BYTE_LENGTH + COMPRESSED_BYTE_LENGTH + RAW_BYTE_LENGTH\n\n// enum ORDER {\n//     ZERO, ONE;\n\n//     static ORDER fromInt(const /* int */ value) {\n//         try {\n//             return ORDER.values()[value];\n//         } catch (const ArrayIndexOutOfBoundsException e) {\n//             throw new RuntimeException(\"Unknown rANS order: \" + value);\n//         }\n//     }\n// }\n\n// static ByteBuffer compress(const ByteBuffer input, const ORDER order, const ByteBuffer out) {\n//     if (input.remaining() == 0)\n//         return EMPTY_BUFFER;\n\n//     if (input.remaining() < 4)\n//         return encode_order0_way4(input, out);\n\n//     switch (order) {\n//         case ZERO:\n//             return encode_order0_way4(input, out);\n//         case ONE:\n//             return encode_order1_way4(input, out);\n\n//         default:\n//             throw new RuntimeException(\"Unknown rANS order: \" + order);\n//     }\n// }\n\n// static /* ByteBuffer */ allocateIfNeeded(/* const int */ in_size,\n//                                            /* const ByteBuffer */ out_buf) {\n//     const /* int */ compressedSize = (/* int */) (1.05 * in_size + 257 * 257 * 3 + 4);\n//     if (out_buf == null)\n//         return ByteBuffer.allocate(compressedSize);\n//     if (out_buf.remaining() < compressedSize)\n//         throw new RuntimeException(\"Insufficient buffer size.\");\n//     out_buf.order(ByteOrder.LITTLE_ENDIAN);\n//     return out_buf;\n// }\n\n// static ByteBuffer encode_order0_way4(const ByteBuffer input,\n//                                              ByteBuffer out_buf) {\n//     const /* int */ in_size = input.remaining();\n//     out_buf = allocateIfNeeded(in_size, out_buf);\n//     const /* int */ freqTableStart = PREFIX_BYTE_LENGTH;\n//     out_buf.position(freqTableStart);\n\n//     const /* int */[] F = Frequencies.calcFrequencies_o0(in);\n//     const RansEncSymbol[] syms = Frequencies.buildSyms_o0(F);\n\n//     const ByteBuffer cp = out_buf.slice();\n//     const /* int */ frequencyTable_size = Frequencies.writeFrequencies_o0(cp, F);\n\n//     input.rewind();\n//     const /* int */ compressedBlob_size = E04.compress(input, syms, cp);\n\n//     finalizeCompressed(0, out_buf, in_size, frequencyTable_size,\n//             compressedBlob_size);\n//     return out_buf;\n// }\n\n// static ByteBuffer encode_order1_way4(const ByteBuffer input,\n//                                              ByteBuffer out_buf) {\n//     const /* int */ in_size = input.remaining();\n//     out_buf = allocateIfNeeded(in_size, out_buf);\n//     const /* int */ freqTableStart = PREFIX_BYTE_LENGTH;\n//     out_buf.position(freqTableStart);\n\n//     const /* int */[][] F = Frequencies.calcFrequencies_o1(in);\n//     const RansEncSymbol[][] syms = Frequencies.buildSyms_o1(F);\n\n//     const ByteBuffer cp = out_buf.slice();\n//     const /* int */ frequencyTable_size = Frequencies.writeFrequencies_o1(cp, F);\n\n//     input.rewind();\n//     const /* int */ compressedBlob_size = E14.compress(input, syms, cp);\n\n//     finalizeCompressed(1, out_buf, in_size, frequencyTable_size,\n//             compressedBlob_size);\n//     return out_buf;\n// }\n\n// static void finalizeCompressed(const /* int */ order, const ByteBuffer out_buf,\n//                                        const /* int */ in_size, const /* int */ frequencyTable_size, const /* int */ compressedBlob_size) {\n//     out_buf.limit(PREFIX_BYTE_LENGTH + frequencyTable_size\n//             + compressedBlob_size);\n//     out_buf.put(0, (byte) order);\n//     out_buf.order(ByteOrder.LITTLE_ENDIAN);\n//     const /* int */ compressedSizeOffset = ORDER_BYTE_LENGTH;\n//     out_buf.putInt(compressedSizeOffset, frequencyTable_size\n//             + compressedBlob_size);\n//     const /* int */ rawSizeOffset = ORDER_BYTE_LENGTH + COMPRESSED_BYTE_LENGTH;\n//     out_buf.putInt(rawSizeOffset, in_size);\n//     out_buf.rewind();\n// }\n\nfunction /* static ByteBuffer */ uncompressOrder0Way4(\n  /* const ByteBuffer  */ input,\n  /* const ByteBuffer  */ out,\n) {\n  // input.order(ByteOrder.LITTLE_ENDIAN);\n  const D = new Decoding.AriDecoder()\n  const syms = new Array(256)\n  for (let i = 0; i < syms.length; i += 1) {\n    syms[i] = new Decoding.Symbol()\n  }\n\n  readStatsO0(input, D, syms)\n\n  D04(input, D, syms, out)\n\n  return out\n}\n\nfunction /* static ByteBuffer */ uncompressOrder1Way4(\n  /* const ByteBuffer */ input,\n  /* const ByteBuffer */ output,\n) {\n  const D = new Array(256)\n  for (let i = 0; i < D.length; i += 1) {\n    D[i] = new Decoding.AriDecoder()\n  }\n  const /* Decoding.RansDecSymbol[][]  */ syms = new Array(256)\n  for (let i = 0; i < syms.length; i += 1) {\n    syms[i] = new Array(256)\n    for (let j = 0; j < syms[i].length; j += 1) {\n      syms[i][j] = new Decoding.Symbol()\n    }\n  }\n  readStatsO1(input, D, syms)\n\n  D14(input, output, D, syms)\n\n  return output\n}\n\n/* compat layer to make a node buffer act like a java ByteBuffer */\nclass ByteBuffer {\n  constructor(nodeBuffer, initialInputPosition = 0) {\n    this._buffer = nodeBuffer\n    this._position = initialInputPosition\n    this.length = nodeBuffer.length\n  }\n\n  get() {\n    const b = this._buffer[this._position]\n    this._position += 1\n    return b\n  }\n\n  getByte() {\n    return this.get()\n  }\n\n  getByteAt(position) {\n    return this._buffer[position]\n  }\n\n  position() {\n    return this._position\n  }\n\n  put(val) {\n    this._buffer[this._position] = val\n    this._position += 1\n    return val\n  }\n\n  putAt(position, val) {\n    this._buffer[position] = val\n    return val\n  }\n\n  setPosition(pos) {\n    this._position = pos\n    return pos\n  }\n\n  getInt() {\n    const i = this._buffer.readInt32LE(this._position)\n    this._position += 4\n    return i\n  }\n\n  remaining() {\n    return this._buffer.length - this._position\n  }\n}\n\n// static /* const */ ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);\nexport default function uncompress(\n  inputBuffer,\n  outputBuffer,\n  initialInputPosition = 0,\n) {\n  if (inputBuffer.length === 0) {\n    outputBuffer.fill(0)\n    return outputBuffer\n  }\n\n  const input = new ByteBuffer(inputBuffer, initialInputPosition)\n  // input.order(ByteOrder.LITTLE_ENDIAN);\n\n  const order = input.get()\n  if (order !== 0 && order !== 1) {\n    throw new CramMalformedError(`Invalid rANS order ${order}`)\n  }\n\n  const /* int */ inputSize = input.getInt()\n  if (inputSize !== input.remaining() - RAW_BYTE_LENGTH) {\n    throw new CramMalformedError('Incorrect input length.')\n  }\n\n  const /* int */ outputSize = input.getInt()\n  const output = new ByteBuffer(outputBuffer || Buffer.allocUnsafe(outputSize))\n  // TODO output.limit(outputSize)\n\n  if (output.length < outputSize) {\n    throw new CramMalformedError(\n      `Output buffer too small to fit ${outputSize} bytes.`,\n    )\n  }\n\n  switch (order) {\n    case 0:\n      return uncompressOrder0Way4(input, output)\n\n    case 1:\n      return uncompressOrder1Way4(input, output)\n\n    default:\n      throw new CramMalformedError(`Invalid rANS order: ${order}`)\n  }\n}\n","import { CramMalformedError } from '../errors'\n\nimport { TF_SHIFT } from './constants'\nimport Decoding from './decoding'\n\nexport default function uncompress(\n  /* ByteBuffer */ input,\n  /* Decoding.AriDecoder */ D,\n  /* Decoding.Symbol[] */ syms,\n  /* ByteBuffer */ out,\n) {\n  let rans0 = input.getInt()\n  let rans1 = input.getInt()\n  let rans2 = input.getInt()\n  let rans3 = input.getInt()\n\n  const /* int */ outputSize = out.remaining()\n  const /* int */ outputEnd = outputSize & ~3\n  for (let i = 0; i < outputEnd; i += 4) {\n    const /* byte */ c0 = D.R[Decoding.get(rans0, TF_SHIFT)]\n    const /* byte */ c1 = D.R[Decoding.get(rans1, TF_SHIFT)]\n    const /* byte */ c2 = D.R[Decoding.get(rans2, TF_SHIFT)]\n    const /* byte */ c3 = D.R[Decoding.get(rans3, TF_SHIFT)]\n\n    out.putAt(i, c0)\n    out.putAt(i + 1, c1)\n    out.putAt(i + 2, c2)\n    out.putAt(i + 3, c3)\n\n    rans0 = Decoding.advanceSymbolStep(rans0, syms[0xff & c0], TF_SHIFT)\n    rans1 = Decoding.advanceSymbolStep(rans1, syms[0xff & c1], TF_SHIFT)\n    rans2 = Decoding.advanceSymbolStep(rans2, syms[0xff & c2], TF_SHIFT)\n    rans3 = Decoding.advanceSymbolStep(rans3, syms[0xff & c3], TF_SHIFT)\n\n    rans0 = Decoding.renormalize(rans0, input)\n    rans1 = Decoding.renormalize(rans1, input)\n    rans2 = Decoding.renormalize(rans2, input)\n    rans3 = Decoding.renormalize(rans3, input)\n  }\n\n  out.setPosition(outputEnd)\n  let /* byte */ c\n  switch (outputSize & 3) {\n    case 0:\n      break\n    case 1:\n      c = D.R[Decoding.get(rans0, TF_SHIFT)]\n      Decoding.advanceSymbol(rans0, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n      break\n\n    case 2:\n      c = D.R[Decoding.get(rans0, TF_SHIFT)]\n      Decoding.advanceSymbol(rans0, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n\n      c = D.R[Decoding.get(rans1, TF_SHIFT)]\n      Decoding.advanceSymbol(rans1, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n      break\n\n    case 3:\n      c = D.R[Decoding.get(rans0, TF_SHIFT)]\n      Decoding.advanceSymbol(rans0, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n\n      c = D.R[Decoding.get(rans1, TF_SHIFT)]\n      Decoding.advanceSymbol(rans1, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n\n      c = D.R[Decoding.get(rans2, TF_SHIFT)]\n      Decoding.advanceSymbol(rans2, input, syms[0xff & c], TF_SHIFT)\n      out.put(c)\n      break\n\n    default:\n      throw new CramMalformedError(\n        'invalid output size encountered during rANS decoding',\n      )\n  }\n\n  out.setPosition(0)\n}\n","import { TF_SHIFT } from './constants'\nimport Decoding from './decoding'\n\nexport default function uncompress(\n  /* ByteBuffer */ input,\n  /* ByteBuffer */ output,\n  /* Decoding.AriDecoder[] */ D,\n  /* Decoding.Symbol[][] */ syms,\n) {\n  const /* int */ outputSize = output.remaining()\n  let rans0 = input.getInt()\n  let rans1 = input.getInt()\n  let rans2 = input.getInt()\n  let rans7 = input.getInt()\n\n  const /* int */ isz4 = outputSize >> 2\n  let /* int */ i0 = 0\n  let /* int */ i1 = isz4\n  let /* int */ i2 = 2 * isz4\n  let /* int */ i7 = 3 * isz4\n  let /* int */ l0 = 0\n  let /* int */ l1 = 0\n  let /* int */ l2 = 0\n  let /* int */ l7 = 0\n  for (; i0 < isz4; i0 += 1, i1 += 1, i2 += 1, i7 += 1) {\n    const /* int */ c0 = 0xff & D[l0].R[Decoding.get(rans0, TF_SHIFT)]\n    const /* int */ c1 = 0xff & D[l1].R[Decoding.get(rans1, TF_SHIFT)]\n    const /* int */ c2 = 0xff & D[l2].R[Decoding.get(rans2, TF_SHIFT)]\n    const /* int */ c7 = 0xff & D[l7].R[Decoding.get(rans7, TF_SHIFT)]\n\n    output.putAt(i0, c0)\n    output.putAt(i1, c1)\n    output.putAt(i2, c2)\n    output.putAt(i7, c7)\n\n    rans0 = Decoding.advanceSymbolStep(rans0, syms[l0][c0], TF_SHIFT)\n    rans1 = Decoding.advanceSymbolStep(rans1, syms[l1][c1], TF_SHIFT)\n    rans2 = Decoding.advanceSymbolStep(rans2, syms[l2][c2], TF_SHIFT)\n    rans7 = Decoding.advanceSymbolStep(rans7, syms[l7][c7], TF_SHIFT)\n\n    rans0 = Decoding.renormalize(rans0, input)\n    rans1 = Decoding.renormalize(rans1, input)\n    rans2 = Decoding.renormalize(rans2, input)\n    rans7 = Decoding.renormalize(rans7, input)\n\n    l0 = c0\n    l1 = c1\n    l2 = c2\n    l7 = c7\n  }\n\n  // Remainder\n  for (; i7 < outputSize; i7 += 1) {\n    const /* int */ c7 = 0xff & D[l7].R[Decoding.get(rans7, TF_SHIFT)]\n    output.putAt(i7, c7)\n    rans7 = Decoding.advanceSymbol(rans7, input, syms[l7][c7], TF_SHIFT)\n    l7 = c7\n  }\n}\n","import { Parser } from '@gmod/binary-parser'\n\nconst singleItf8 = new Parser().itf8()\n\nconst cramFileDefinition = {\n  parser: new Parser()\n    .string('magic', { length: 4 })\n    .uint8('majorVersion')\n    .uint8('minorVersion')\n    .string('fileId', { length: 20, stripNull: true }),\n  maxLength: 26,\n}\n\nconst cramBlockHeader = {\n  parser: new Parser()\n    .uint8('compressionMethod', {\n      formatter: /* istanbul ignore next */ b => {\n        const method = [\n          'raw',\n          'gzip',\n          'bzip2',\n          'lzma',\n          'rans',\n          'rans4x16',\n          'arith',\n          'fqzcomp',\n          'tok3',\n        ][b]\n        if (!method) {\n          throw new Error(`compression method number ${b} not implemented`)\n        }\n        return method\n      },\n    })\n    .uint8('contentType', {\n      formatter: /* istanbul ignore next */ b => {\n        const type = [\n          'FILE_HEADER',\n          'COMPRESSION_HEADER',\n          'MAPPED_SLICE_HEADER',\n          'UNMAPPED_SLICE_HEADER', // < only used in cram v1\n          'EXTERNAL_DATA',\n          'CORE_DATA',\n        ][b]\n        if (!type) {\n          throw new Error(`invalid block content type id ${b}`)\n        }\n        return type\n      },\n    })\n    .itf8('contentId')\n    .itf8('compressedSize')\n    .itf8('uncompressedSize'),\n  maxLength: 17,\n}\n\nconst cramBlockCrc32 = {\n  parser: new Parser().uint32('crc32'),\n  maxLength: 4,\n}\n\n// const ENCODING_NAMES = [\n//   'NULL', // 0\n//   'EXTERNAL', // 1\n//   'GOLOMB', // 2\n//   'HUFFMAN_INT', // 3\n//   'BYTE_ARRAY_LEN', // 4\n//   'BYTE_ARRAY_STOP', // 5\n//   'BETA', // 6\n//   'SUBEXP', // 7\n//   'GOLOMB_RICE', // 8\n//   'GAMMA', // 9\n// ]\n\nconst cramTagDictionary = new Parser().itf8('size').buffer('ents', {\n  length: 'size',\n  formatter: /* istanbul ignore next */ buffer => {\n    function makeTagSet(stringStart, stringEnd) {\n      const str = buffer.toString('utf8', stringStart, stringEnd)\n      const tags = []\n      for (let i = 0; i < str.length; i += 3) {\n        tags.push(str.substr(i, 3))\n      }\n      return tags\n    }\n    /* eslint-disable */\n    var tagSets = []\n    var stringStart = 0\n    var i\n    /* eslint-enable */\n    for (i = 0; i < buffer.length; i += 1) {\n      if (!buffer[i]) {\n        tagSets.push(makeTagSet(stringStart, i))\n        stringStart = i + 1\n      }\n    }\n    if (i > stringStart) {\n      tagSets.push(makeTagSet(stringStart, i))\n    }\n    return tagSets\n  },\n})\n\n// const cramPreservationMapKeys = 'XX RN AP RR SM TD'.split(' ')\nconst parseByteAsBool = new Parser().uint8(null, {\n  formatter: /* istanbul ignore next */ val => !!val,\n})\n\nconst cramPreservationMap = new Parser()\n  .itf8('mapSize')\n  .itf8('mapCount')\n  .array('ents', {\n    length: 'mapCount',\n    type: new Parser()\n      .string('key', {\n        length: 2,\n        stripNull: false,\n        // formatter: val => cramPreservationMapKeys[val] || 0,\n      })\n      .choice('value', {\n        tag: 'key',\n        choices: {\n          MI: parseByteAsBool,\n          UI: parseByteAsBool,\n          PI: parseByteAsBool,\n          RN: parseByteAsBool,\n          AP: parseByteAsBool,\n          RR: parseByteAsBool,\n          SM: new Parser().array(null, { type: 'uint8', length: 5 }),\n          TD: new Parser().nest(null, {\n            type: cramTagDictionary,\n            formatter: /* istanbul ignore next */ data => data.ents,\n          }),\n        },\n      }),\n  })\n\n/* istanbul ignore next */\nfunction formatMap(data) {\n  const map = {}\n  for (let i = 0; i < data.ents.length; i += 1) {\n    const { key, value } = data.ents[i]\n    if (map[key]) {\n      console.warn(`duplicate key ${key} in map`)\n    }\n    map[key] = value\n  }\n  return map\n}\n\nconst unversionedParsers = {\n  cramFileDefinition,\n  cramBlockHeader,\n  cramBlockCrc32,\n}\n\n// each of these is a function of the major and minor version\nconst versionedParsers = {\n  // assemble a section parser for the unmapped slice header, with slight\n  // variations depending on the major version of the cram file\n  cramUnmappedSliceHeader(majorVersion) {\n    let maxLength = 0\n    let parser = new Parser().itf8('numRecords')\n    maxLength += 5\n\n    // recordCounter is itf8 in a CRAM v2 file, absent in CRAM v1\n    if (majorVersion >= 3) {\n      parser = parser.ltf8('recordCounter')\n      maxLength += 9\n    } else if (majorVersion === 2) {\n      parser = parser.itf8('recordCounter')\n      maxLength += 5\n    }\n\n    parser = parser\n      .itf8('numBlocks')\n      .itf8('numContentIds')\n      .array('contentIds', {\n        type: singleItf8,\n        length: 'numContentIds',\n      })\n    maxLength += 5 * 2 // + numContentIds*5\n\n    // the md5 sum is missing in cram v1\n    if (majorVersion >= 2) {\n      parser = parser.array('md5', { type: 'uint8', length: 16 })\n      maxLength += 16\n    }\n\n    const maxLengthFunc = numContentIds => maxLength + numContentIds * 5\n\n    return { parser, maxLength: maxLengthFunc } // : p, maxLength: numContentIds => 5 + 9 + 5 * 2 + 5 * numContentIds + 16 }\n  },\n\n  // assembles a section parser for the unmapped slice header, with slight\n  // variations depending on the major version of the cram file\n  cramMappedSliceHeader(majorVersion) {\n    let parser = new Parser()\n      .itf8('refSeqId')\n      .itf8('refSeqStart')\n      .itf8('refSeqSpan')\n      .itf8('numRecords')\n    let maxLength = 5 * 4\n\n    if (majorVersion >= 3) {\n      parser = parser.ltf8('recordCounter')\n      maxLength += 9\n    } else if (majorVersion === 2) {\n      parser = parser.itf8('recordCounter')\n      maxLength += 5\n    }\n\n    parser = parser\n      .itf8('numBlocks')\n      .itf8('numContentIds')\n      .array('contentIds', {\n        type: singleItf8,\n        length: 'numContentIds',\n      })\n      .itf8('refBaseBlockId')\n    maxLength += 5 * 3\n\n    // the md5 sum is missing in cram v1\n    if (majorVersion >= 2) {\n      parser = parser.array('md5', { type: 'uint8', length: 16 })\n      maxLength += 16\n    }\n\n    const maxLengthFunc = numContentIds => maxLength + numContentIds * 5\n\n    return { parser, maxLength: maxLengthFunc }\n  },\n\n  cramEncoding(majorVersion) {\n    const parser = new Parser()\n      .namely('cramEncoding')\n      .itf8('codecId')\n      .itf8('parametersBytes')\n      .choice('parameters', {\n        tag: 'codecId',\n        choices: {\n          0: new Parser(), // NULL\n          1: new Parser().itf8('blockContentId'), // EXTERNAL\n          2: new Parser().itf8('offset').itf8('M'), // GOLOMB,\n          // HUFFMAN_INT\n          3: Parser.start()\n            .itf8('numCodes')\n            .array('symbols', { length: 'numCodes', type: singleItf8 })\n            .itf8('numLengths')\n            .array('bitLengths', { length: 'numLengths', type: singleItf8 }),\n          4: Parser.start() // BYTE_ARRAY_LEN\n            .nest('lengthsEncoding', { type: 'cramEncoding' })\n            .nest('valuesEncoding', { type: 'cramEncoding' }),\n          // BYTE_ARRAY_STOP is a little different for CRAM v1\n          5: new Parser()\n            .uint8('stopByte')\n            [majorVersion > 1 ? 'itf8' : 'int']('blockContentId'),\n          6: new Parser().itf8('offset').itf8('length'), // BETA\n          7: new Parser().itf8('offset').itf8('K'), // SUBEXP\n          8: new Parser().itf8('offset').itf8('log2m'), // GOLOMB_RICE\n          9: new Parser().itf8('offset'), // GAMMA\n        },\n      })\n\n    return { parser }\n  },\n\n  cramDataSeriesEncodingMap(majorVersion) {\n    return new Parser()\n      .itf8('mapSize')\n      .itf8('mapCount')\n      .array('ents', {\n        length: 'mapCount',\n        type: new Parser()\n          .string('key', { length: 2, stripNull: false })\n          .nest('value', { type: this.cramEncoding(majorVersion).parser }),\n      })\n  },\n\n  cramTagEncodingMap(majorVersion) {\n    return new Parser()\n      .itf8('mapSize')\n      .itf8('mapCount')\n      .array('ents', {\n        length: 'mapCount',\n        type: new Parser()\n          .itf8('key', {\n            formatter: /* istanbul ignore next */ integerRepresentation =>\n              /* istanbul ignore next */\n              String.fromCharCode((integerRepresentation >> 16) & 0xff) +\n              String.fromCharCode((integerRepresentation >> 8) & 0xff) +\n              String.fromCharCode(integerRepresentation & 0xff),\n          })\n          .nest('value', { type: this.cramEncoding(majorVersion).parser }),\n      })\n  },\n\n  cramCompressionHeader(majorVersion) {\n    let parser = new Parser()\n    // TODO: if we want to support CRAM v1, we will need to refactor\n    // compression header into 2 parts to parse the landmarks,\n    // like the container header\n    parser = parser\n      .nest('preservation', {\n        type: cramPreservationMap,\n        formatter: formatMap,\n      })\n      .nest('dataSeriesEncoding', {\n        type: this.cramDataSeriesEncodingMap(majorVersion),\n        formatter: formatMap,\n      })\n      .nest('tagEncoding', {\n        type: this.cramTagEncodingMap(majorVersion),\n        formatter: formatMap,\n      })\n    return { parser }\n  },\n\n  cramContainerHeader1(majorVersion) {\n    let parser = new Parser()\n      .int32('length') // byte size of the container data (blocks)\n      .itf8('refSeqId') // reference sequence identifier, -1 for unmapped reads, -2 for multiple reference sequences\n      .itf8('refSeqStart') // the alignment start position or 0 for unmapped reads\n      .itf8('alignmentSpan') // the length of the alignment or 0 for unmapped reads\n      .itf8('numRecords') // number of records in the container\n    let maxLength = 4 + 5 * 4\n\n    if (majorVersion >= 3) {\n      parser = parser.ltf8('recordCounter') // 1-based sequential index of records in the file/stream.\n      maxLength += 9\n    } else if (majorVersion === 2) {\n      parser = parser.itf8('recordCounter')\n      maxLength += 5\n    }\n\n    if (majorVersion > 1) {\n      parser = parser.ltf8('numBases') // number of read bases\n      maxLength += 9\n    }\n    parser = parser\n      .itf8('numBlocks') // the number of blocks\n      .itf8('numLandmarks') // the number of landmarks\n    maxLength += 5 + 5\n\n    return { parser, maxLength }\n  },\n\n  cramContainerHeader2(majorVersion) {\n    let parser = new Parser()\n      .itf8('numLandmarks') // the number of blocks\n      // Each integer value of this array is a byte offset\n      // into the blocks byte array. Landmarks are used for\n      // random access indexing.\n      .array('landmarks', {\n        type: new Parser().itf8(),\n        length: 'numLandmarks',\n      })\n\n    let crcLength = 0\n    if (majorVersion >= 3) {\n      parser = parser.uint32('crc32')\n      crcLength = 4\n    }\n    return {\n      parser,\n      maxLength: numLandmarks => 5 + numLandmarks * 5 + crcLength,\n    }\n  },\n}\n\nfunction getSectionParsers(majorVersion) {\n  const parsers = Object.assign({}, unversionedParsers)\n  Object.keys(versionedParsers).forEach(parserName => {\n    parsers[parserName] = versionedParsers[parserName](majorVersion)\n  })\n  return parsers\n}\n\nexport { cramFileDefinition, getSectionParsers }\n","import md5 from 'md5'\nimport { CramBufferOverrunError } from '../errors'\n\nexport function itf8Size(v) {\n  if (!(v & ~0x7f)) {\n    return 1\n  }\n  if (!(v & ~0x3fff)) {\n    return 2\n  }\n  if (!(v & ~0x1fffff)) {\n    return 3\n  }\n  if (!(v & ~0xfffffff)) {\n    return 4\n  }\n  return 5\n}\n\nexport function parseItf8(buffer, initialOffset) {\n  let offset = initialOffset\n  const countFlags = buffer[offset]\n  let result\n  if (countFlags < 0x80) {\n    result = countFlags\n    offset += 1\n  } else if (countFlags < 0xc0) {\n    result = ((countFlags << 8) | buffer[offset + 1]) & 0x3fff\n    offset += 2\n  } else if (countFlags < 0xe0) {\n    result =\n      ((countFlags << 16) | (buffer[offset + 1] << 8) | buffer[offset + 2]) &\n      0x1fffff\n    offset += 3\n  } else if (countFlags < 0xf0) {\n    result =\n      ((countFlags << 24) |\n        (buffer[offset + 1] << 16) |\n        (buffer[offset + 2] << 8) |\n        buffer[offset + 3]) &\n      0x0fffffff\n    offset += 4\n  } else {\n    result =\n      ((countFlags & 0x0f) << 28) |\n      (buffer[offset + 1] << 20) |\n      (buffer[offset + 2] << 12) |\n      (buffer[offset + 3] << 4) |\n      (buffer[offset + 4] & 0x0f)\n    // x=((0xff & 0x0f)<<28) | (0xff<<20) | (0xff<<12) | (0xff<<4) | (0x0f & 0x0f);\n    // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n    offset += 5\n  }\n  if (offset > buffer.length) {\n    throw new CramBufferOverrunError(\n      'Attempted to read beyond end of buffer; this file seems truncated.',\n    )\n  }\n  return [result, offset - initialOffset]\n}\n\n// parseLtf8(buffer, initialOffset) {\n//   let offset = initialOffset\n//   const countFlags = buffer[offset]\n//   let result\n//   if (countFlags < 0x80) {\n//     result = countFlags\n//     offset += 1\n//   } else if (countFlags < 0xc0) {\n//     result = ((buffer[offset] << 8) | buffer[offset + 1]) & 0x3fff\n//     offset += 2\n//   } else if (countFlags < 0xe0) {\n//     result =\n//       ((buffer[offset] << 16) |\n//         (buffer[offset + 1] << 8) |\n//         buffer[offset + 2]) &\n//       0x1fffff\n//     offset += 3\n//   } else if (countFlags < 0xf0) {\n//     result =\n//       ((buffer[offset] << 24) |\n//         (buffer[offset + 1] << 16) |\n//         (buffer[offset + 2] << 8) |\n//         buffer[offset + 3]) &\n//       0x0fffffff\n//     offset += 4\n//   } else if (countFlags < 0xf8) {\n//     result =\n//       ((buffer[offset] & 15) * Math.pow(2,32) + (buffer[offset + 1] << 24)) |\n//       ((buffer[offset + 2] << 16) |\n//         (buffer[offset + 3] << 8) |\n//         buffer[offset + 4])\n//     // TODO *val_p = uv < 0x80000000UL ? uv : -((int32_t) (0xffffffffUL - uv)) - 1;\n//     offset += 5\n//   } else if (countFlags < 0xfc) {\n//     result =\n//       ((((buffer[offset] & 7) << 8) | buffer[offset + 1]) * Math.pow(2,32) +\n//         (buffer[offset + 2] << 24)) |\n//       ((buffer[offset + 3] << 16) |\n//         (buffer[offset + 4] << 8) |\n//         buffer[offset + 5])\n//     offset += 6\n//   } else if (countFlags < 0xfe) {\n//     result =\n//       ((((buffer[offset] & 3) << 16) |\n//         (buffer[offset + 1] << 8) |\n//         buffer[offset + 2]) *\n//         Math.pow(2,32) +\n//         (buffer[offset + 3] << 24)) |\n//       ((buffer[offset + 4] << 16) |\n//         (buffer[offset + 5] << 8) |\n//         buffer[offset + 6])\n//     offset += 7\n//   } else if (countFlags < 0xff) {\n//     result = Long.fromBytesBE(buffer.slice(offset + 1, offset + 8))\n//     if (\n//       result.greaterThan(Number.MAX_SAFE_INTEGER) ||\n//       result.lessThan(Number.MIN_SAFE_INTEGER)\n//     )\n//       throw new CramUnimplementedError('integer overflow')\n//     result = result.toNumber()\n//     offset += 8\n//   } else {\n//     result = Long.fromBytesBE(buffer.slice(offset + 1, offset + 9))\n//     if (\n//       result.greaterThan(Number.MAX_SAFE_INTEGER) ||\n//       result.lessThan(Number.MIN_SAFE_INTEGER)\n//     )\n//       throw new CramUnimplementedError('integer overflow')\n//     result = result.toNumber()\n//     offset += 9\n//   }\n//   return [result, offset - initialOffset]\n// },\n\nexport function parseItem(\n  buffer,\n  parser,\n  startBufferPosition = 0,\n  startFilePosition = 0,\n) {\n  const { offset, result } = parser.parse(buffer)\n  result._endPosition = offset + startFilePosition\n  result._size = offset - startBufferPosition\n  return result\n}\n\n// this would be nice as a decorator, but i'm a little worried about\n// babel support for it going away or changing.\n// memoizes a method in the stupidest possible way, with no regard for the\n// arguments.  actually, this only works on methods that take no arguments\nexport function tinyMemoize(_class, methodName) {\n  const method = _class.prototype[methodName]\n  const memoAttrName = `_memo_${methodName}`\n  _class.prototype[methodName] = function _tinyMemoized() {\n    if (!(memoAttrName in this)) {\n      const res = method.call(this)\n      this[memoAttrName] = res\n      Promise.resolve(res).catch(() => {\n        delete this[memoAttrName]\n      })\n    }\n    return this[memoAttrName]\n  }\n}\n\nexport function sequenceMD5(seq) {\n  return md5(seq.toUpperCase().replace(/[^\\x21-\\x7e]/g, ''))\n}\n","const Constants = {\n  CRAM_FLAG_PRESERVE_QUAL_SCORES: 1 << 0,\n  CRAM_FLAG_DETACHED: 1 << 1,\n  CRAM_FLAG_MATE_DOWNSTREAM: 1 << 2,\n  CRAM_FLAG_NO_SEQ: 1 << 3,\n  CRAM_FLAG_MASK: (1 << 4) - 1,\n\n  // mate read is reversed\n  CRAM_M_REVERSE: 1,\n  // mated read is unmapped\n  CRAM_M_UNMAP: 2,\n\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n\n  BAM_CMATCH: 0,\n  BAM_CINS: 1,\n  BAM_CDEL: 2,\n  BAM_CREF_SKIP: 3,\n  BAM_CSOFT_CLIP: 4,\n  BAM_CHARD_CLIP: 5,\n  BAM_CPAD: 6,\n  BAM_CEQUAL: 7,\n  BAM_CDIFF: 8,\n  BAM_CBACK: 9,\n\n  BAM_CIGAR_STR: 'MIDNSHP:XB',\n  BAM_CIGAR_SHIFT: 4,\n  BAM_CIGAR_MASK: 0xf,\n  BAM_CIGAR_TYPE: 0x3c1a7,\n}\n\nexport default Constants\n","import Constants from './constants'\n\nfunction decodeReadSequence(cramRecord, refRegion) {\n  // if it has no length, it has no sequence\n  if (!cramRecord.lengthOnRef && !cramRecord.readLength) {\n    return undefined\n  }\n\n  if (cramRecord.isUnknownBases()) {\n    return undefined\n  }\n\n  // remember: all coordinates are 1-based closed\n  const regionSeqOffset = cramRecord.alignmentStart - refRegion.start\n\n  if (!cramRecord.readFeatures) {\n    return refRegion.seq\n      .substr(regionSeqOffset, cramRecord.lengthOnRef)\n      .toUpperCase()\n  }\n\n  let bases = ''\n  let regionPos = regionSeqOffset\n  let currentReadFeature = 0\n  while (bases.length < cramRecord.readLength) {\n    if (currentReadFeature < cramRecord.readFeatures.length) {\n      const feature = cramRecord.readFeatures[currentReadFeature]\n      if (feature.code === 'Q' || feature.code === 'q') {\n        currentReadFeature += 1\n      } else if (feature.pos === bases.length + 1) {\n        // process the read feature\n        currentReadFeature += 1\n\n        if (feature.code === 'b') {\n          // specify a base pair for some reason\n          const ret = feature.data.split(',')\n          const added = String.fromCharCode(...ret)\n          bases += added\n          regionPos += added.length\n        } else if (feature.code === 'B') {\n          // base pair and associated quality\n          // TODO: do we need to set the quality in the qual scores?\n          bases += feature.data[0]\n          regionPos += 1\n        } else if (feature.code === 'X') {\n          // base substitution\n          bases += feature.sub\n          regionPos += 1\n        } else if (feature.code === 'I') {\n          // insertion\n          bases += feature.data\n        } else if (feature.code === 'D') {\n          // deletion\n          regionPos += feature.data\n        } else if (feature.code === 'i') {\n          // insert single base\n          bases += feature.data\n        } else if (feature.code === 'N') {\n          // reference skip. delete some bases\n          // do nothing\n          // seqBases.splice(feature.pos - 1, feature.data)\n          regionPos += feature.data\n        } else if (feature.code === 'S') {\n          // soft clipped bases that should be present in the read seq\n          // seqBases.splice(feature.pos - 1, 0, ...feature.data.split(''))\n          bases += feature.data\n        } else if (feature.code === 'P') {\n          // padding, do nothing\n        } else if (feature.code === 'H') {\n          // hard clip, do nothing\n        }\n      } else if (currentReadFeature < cramRecord.readFeatures.length) {\n        // put down a chunk of sequence up to the next read feature\n        const chunk = refRegion.seq.substr(\n          regionPos,\n          cramRecord.readFeatures[currentReadFeature].pos - bases.length - 1,\n        )\n        bases += chunk\n        regionPos += chunk.length\n      }\n    } else {\n      // put down a chunk of reference up to the full read length\n      const chunk = refRegion.seq.substr(\n        regionPos,\n        cramRecord.readLength - bases.length,\n      )\n      bases += chunk\n      regionPos += chunk.length\n    }\n  }\n\n  return bases.toUpperCase()\n}\n\nconst baseNumbers = {\n  a: 0,\n  A: 0,\n  c: 1,\n  C: 1,\n  g: 2,\n  G: 2,\n  t: 3,\n  T: 3,\n  n: 4,\n  N: 4,\n}\n\nfunction decodeBaseSubstitution(\n  cramRecord,\n  refRegion,\n  compressionScheme,\n  readFeature,\n) {\n  if (!refRegion) {\n    return\n  }\n\n  // decode base substitution code using the substitution matrix\n  const refCoord = readFeature.refPos - refRegion.start\n  const refBase = refRegion.seq.charAt(refCoord)\n  if (refBase) {\n    readFeature.ref = refBase\n  }\n  let baseNumber = baseNumbers[refBase]\n  if (baseNumber === undefined) {\n    baseNumber = 4\n  }\n  const substitutionScheme = compressionScheme.substitutionMatrix[baseNumber]\n  const base = substitutionScheme[readFeature.data]\n  if (base) {\n    readFeature.sub = base\n  }\n}\n\n/**\n * Class of each CRAM record returned by this API.\n */\nexport default class CramRecord {\n  constructor() {\n    this.tags = {}\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  /**\n   * @returns {boolean} true if the read is detached\n   */\n  isDetached() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_DETACHED)\n  }\n\n  /** @returns {boolean} true if the read has a mate in this same CRAM segment */\n  hasMateDownStream() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_MATE_DOWNSTREAM)\n  }\n\n  /** @returns {boolean} true if the read contains qual scores */\n  isPreservingQualityScores() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_PRESERVE_QUAL_SCORES)\n  }\n\n  /** @returns {boolean} true if the read has no sequence bases */\n  isUnknownBases() {\n    return !!(this.cramFlags & Constants.CRAM_FLAG_NO_SEQ)\n  }\n\n  /**\n   * Get the original sequence of this read.\n   * @returns {String} sequence basepairs\n   */\n  getReadBases() {\n    if (!this.readBases && this._refRegion) {\n      this.readBases = decodeReadSequence(this, this._refRegion)\n    }\n    return this.readBases\n  }\n\n  /**\n   * Get the pair orientation of a paired read. Adapted from igv.js\n   * @returns {String} of paired orientatin\n   */\n  getPairOrientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      this.isPaired() &&\n      !this.isMateUnmapped() &&\n      this.mate &&\n      this.sequenceId === this.mate.sequenceId\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      let isize = this.templateLength || this.templateSize\n      if (this.alignmentStart > this.mate.alignmentStart && isize > 0) {\n        isize = -isize\n      }\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return null\n  }\n\n  /**\n   * Annotates this feature with the given reference sequence basepair\n   * information. This will add a `sub` and a `ref` item to base\n   * subsitution read features given the actual substituted and reference\n   * base pairs, and will make the `getReadSequence()` method work.\n   *\n   * @param {object} refRegion\n   * @param {number} refRegion.start\n   * @param {number} refRegion.end\n   * @param {string} refRegion.seq\n   * @param {CramContainerCompressionScheme} compressionScheme\n   * @returns {undefined} nothing\n   */\n  addReferenceSequence(refRegion, compressionScheme) {\n    if (this.readFeatures) {\n      // use the reference bases to decode the bases\n      // substituted in each base substitution\n      this.readFeatures.forEach(readFeature => {\n        if (readFeature.code === 'X') {\n          decodeBaseSubstitution(\n            this,\n            refRegion,\n            compressionScheme,\n            readFeature,\n          )\n        }\n      })\n    }\n\n    // if this region completely covers this read,\n    // keep a reference to it\n    if (\n      !this.readBases &&\n      refRegion.start <= this.alignmentStart &&\n      refRegion.end >=\n        this.alignmentStart + (this.lengthOnRef || this.readLength) - 1\n    ) {\n      this._refRegion = refRegion\n    }\n  }\n\n  toJSON() {\n    const data = {}\n    Object.keys(this).forEach(k => {\n      if (k.charAt(0) === '_') {\n        return\n      }\n      data[k] = this[k]\n    })\n\n    data.readBases = this.getReadBases()\n\n    return data\n  }\n}\n","import Long from 'long'\nimport { CramMalformedError, CramUnimplementedError } from '../../errors'\nimport CramRecord from '../record'\nimport Constants from '../constants'\n/**\n * given a Buffer, read a string up to the first null character\n * @private\n */\nfunction readNullTerminatedStringFromBuffer(buffer) {\n  const zeroOffset = buffer.indexOf(0)\n  if (zeroOffset === -1) {\n    return buffer.toString('utf8')\n  }\n  return buffer.toString('utf8', 0, zeroOffset)\n}\n\n/**\n * parse a BAM tag's array value from a binary buffer\n * @private\n */\nfunction parseTagValueArray(buffer) {\n  const arrayType = String.fromCharCode(buffer[0])\n  const length = buffer.readInt32LE(1)\n\n  const schema = {\n    c: ['readInt8', 1],\n    C: ['readUInt8', 1],\n    s: ['readInt16LE', 2],\n    S: ['readUInt16LE', 2],\n    i: ['readInt32LE', 4],\n    I: ['readUInt32LE', 4],\n    f: ['readFloatLE', 4],\n  }[arrayType]\n  if (!schema) {\n    throw new CramMalformedError(`invalid tag value array type '${arrayType}'`)\n  }\n\n  const [getMethod, itemSize] = schema\n  const array = new Array(length)\n  let offset = 5\n  for (let i = 0; i < length; i += 1) {\n    array[i] = buffer[getMethod](offset)\n    offset += itemSize\n  }\n  return array\n}\n\nfunction parseTagData(tagType, buffer) {\n  if (!buffer.readInt32LE) {\n    buffer = Buffer.from(buffer)\n  }\n  if (tagType === 'Z') {\n    return readNullTerminatedStringFromBuffer(buffer)\n  }\n  if (tagType === 'A') {\n    return String.fromCharCode(buffer[0])\n  }\n  if (tagType === 'I') {\n    const val = Long.fromBytesLE(buffer)\n    if (\n      val.greaterThan(Number.MAX_SAFE_INTEGER) ||\n      val.lessThan(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new CramUnimplementedError('integer overflow')\n    }\n    return val.toNumber()\n  }\n  if (tagType === 'i') {\n    return buffer.readInt32LE(0)\n  }\n  if (tagType === 's') {\n    return buffer.readInt16LE(0)\n  }\n  if (tagType === 'S') {\n    return buffer.readUInt16LE(0)\n  }\n  if (tagType === 'c') {\n    return buffer.readInt8(0)\n  }\n  if (tagType === 'C') {\n    return buffer.readUInt8(0)\n  }\n  if (tagType === 'f') {\n    return buffer.readFloatLE(0)\n  }\n  if (tagType === 'H') {\n    const hex = readNullTerminatedStringFromBuffer(buffer)\n    return Number.parseInt(hex.replace(/^0x/, ''), 16)\n  }\n  if (tagType === 'B') {\n    return parseTagValueArray(buffer)\n  }\n\n  throw new CramMalformedError(`Unrecognized tag type ${tagType}`)\n}\n\nfunction decodeReadFeatures(\n  cramRecord,\n  readFeatureCount,\n  decodeDataSeries,\n  compressionScheme,\n  majorVersion,\n) {\n  let currentReadPos = 0\n  let currentRefPos = cramRecord.alignmentStart - 1\n  const readFeatures = new Array(readFeatureCount)\n\n  function decodeRFData([type, dataSeriesName]) {\n    const data = decodeDataSeries(dataSeriesName)\n    if (type === 'character') {\n      return String.fromCharCode(data)\n    }\n    if (type === 'string') {\n      return data.toString('utf8')\n    }\n    if (type === 'numArray') {\n      return data.toArray()\n    }\n    // else if (type === 'number') {\n    //   return data[0]\n    // }\n    return data\n  }\n\n  for (let i = 0; i < readFeatureCount; i += 1) {\n    const code = String.fromCharCode(decodeDataSeries('FC'))\n\n    const readPosDelta = decodeDataSeries('FP')\n\n    const readFeature = { code }\n    // map of operator name -> data series name\n    const data1Schema = {\n      B: ['character', 'BA'],\n      S: ['string', majorVersion > 1 ? 'SC' : 'IN'], // IN if cram v1, SC otherwise\n      X: ['number', 'BS'],\n      D: ['number', 'DL'],\n      I: ['string', 'IN'],\n      i: ['character', 'BA'],\n      b: ['string', 'BB'],\n      q: ['numArray', 'QQ'],\n      Q: ['number', 'QS'],\n      H: ['number', 'HC'],\n      P: ['number', 'PD'],\n      N: ['number', 'RS'],\n    }[code]\n\n    if (!data1Schema) {\n      throw new CramMalformedError(`invalid read feature code \"${code}\"`)\n    }\n\n    readFeature.data = decodeRFData(data1Schema)\n\n    // if this is a tag with two data items, make the data an array and add the second item\n    const data2Schema = { B: ['number', 'QS'] }[code]\n    if (data2Schema) {\n      readFeature.data = [readFeature.data, decodeRFData(data2Schema)]\n    }\n\n    currentReadPos += readPosDelta\n    readFeature.pos = currentReadPos\n\n    currentRefPos += readPosDelta\n    readFeature.refPos = currentRefPos\n\n    // for gapping features, adjust the reference position for read features that follow\n    if (code === 'D' || code === 'N') {\n      currentRefPos += readFeature.data\n    } else if (code === 'I' || code === 'S') {\n      currentRefPos -= readFeature.data.length\n    } else if (code === 'i') {\n      currentRefPos -= 1\n    }\n\n    readFeatures[i] = readFeature\n  }\n  return readFeatures\n}\n\nfunction thingToString(thing) {\n  if (thing instanceof Buffer) {\n    return readNullTerminatedStringFromBuffer(thing)\n  }\n  if (thing.length && thing.indexOf) {\n    // array-like\n    if (!thing[thing.length - 1]) {\n      // trim zeroes off the end if necessary\n      const termIndex = thing.indexOf(0)\n      return String.fromCharCode(...thing.slice(0, termIndex))\n    }\n    return String.fromCharCode(...thing)\n  }\n  return String(thing)\n}\n\nexport default function decodeRecord(\n  slice,\n  decodeDataSeries,\n  compressionScheme,\n  sliceHeader,\n  coreDataBlock,\n  blocksByContentId,\n  cursors,\n  majorVersion,\n  recordNumber,\n) {\n  const cramRecord = new CramRecord()\n\n  cramRecord.flags = decodeDataSeries('BF')\n\n  // note: the C data type of compressionFlags is byte in cram v1\n  // and int32 in cram v2+, but that does not matter for us here\n  // in javascript land.\n  cramRecord.cramFlags = decodeDataSeries('CF')\n\n  if (majorVersion > 1 && sliceHeader.content.refSeqId === -2) {\n    cramRecord.sequenceId = decodeDataSeries('RI')\n  } else {\n    cramRecord.sequenceId = sliceHeader.content.refSeqId\n  }\n\n  cramRecord.readLength = decodeDataSeries('RL')\n  // if APDelta, will calculate the true start in a second pass\n  cramRecord.alignmentStart = decodeDataSeries('AP')\n  if (compressionScheme.APdelta) {\n    cramRecord.alignmentStart += cursors.lastAlignmentStart\n  }\n  cursors.lastAlignmentStart = cramRecord.alignmentStart\n  cramRecord.readGroupId = decodeDataSeries('RG')\n\n  if (compressionScheme.readNamesIncluded) {\n    cramRecord.readName = thingToString(decodeDataSeries('RN'))\n  }\n\n  // mate record\n  if (cramRecord.isDetached()) {\n    // note: the MF is a byte in 1.0, int32 in 2+, but once again this doesn't matter for javascript\n    const mate = {}\n    mate.flags = decodeDataSeries('MF')\n    if (!compressionScheme.readNamesIncluded) {\n      mate.readName = thingToString(decodeDataSeries('RN'))\n      cramRecord.readName = mate.readName\n    }\n    mate.sequenceId = decodeDataSeries('NS')\n    mate.alignmentStart = decodeDataSeries('NP')\n    if (mate.flags || mate.sequenceId > -1) {\n      cramRecord.mate = mate\n    }\n    cramRecord.templateSize = decodeDataSeries('TS')\n\n    // set mate unmapped if needed\n    if (mate.flags & Constants.CRAM_M_UNMAP) {\n      cramRecord.flags |= Constants.BAM_FMUNMAP\n    }\n    // set mate reversed if needed\n    if (mate.flags & Constants.CRAM_M_REVERSE) {\n      cramRecord.flags |= Constants.BAM_FMREVERSE\n    }\n\n    // detachedCount++\n  } else if (cramRecord.hasMateDownStream()) {\n    cramRecord.mateRecordNumber = decodeDataSeries('NF') + recordNumber + 1\n  }\n\n  // TODO: the aux tag parsing will have to be refactored if we want to support\n  // cram v1\n  const TLindex = decodeDataSeries('TL')\n  if (TLindex < 0) {\n    /* TODO: check nTL: TLindex >= compressionHeader.tagEncoding.size */\n    throw new CramMalformedError('invalid TL index')\n  }\n\n  // TN = tag names\n  const TN = compressionScheme.getTagNames(TLindex)\n  const ntags = TN.length\n\n  for (let i = 0; i < ntags; i += 1) {\n    const tagId = TN[i]\n    const tagName = tagId.substr(0, 2)\n    const tagType = tagId.substr(2, 1)\n\n    const tagCodec = compressionScheme.getCodecForTag(tagId)\n    if (!tagCodec) {\n      throw new CramMalformedError(\n        `no codec defined for auxiliary tag ${tagId}`,\n      )\n    }\n    const tagData = tagCodec.decode(\n      slice,\n      coreDataBlock,\n      blocksByContentId,\n      cursors,\n    )\n    cramRecord.tags[tagName] = parseTagData(tagType, tagData)\n  }\n\n  if (!cramRecord.isSegmentUnmapped()) {\n    // reading read features\n    const /* int */ readFeatureCount = decodeDataSeries('FN')\n    if (readFeatureCount) {\n      cramRecord.readFeatures = decodeReadFeatures(\n        cramRecord,\n        readFeatureCount,\n        decodeDataSeries,\n        compressionScheme,\n        majorVersion,\n      )\n    }\n\n    // compute the read's true span on the reference sequence, and the end coordinate of the alignment on the reference\n    let lengthOnRef = cramRecord.readLength\n    if (cramRecord.readFeatures) {\n      cramRecord.readFeatures.forEach(({ code, data }) => {\n        if (code === 'D' || code === 'N') {\n          lengthOnRef += data\n        } else if (code === 'I' || code === 'S') {\n          lengthOnRef -= data.length\n        } else if (code === 'i') {\n          lengthOnRef -= 1\n        }\n      })\n    }\n    if (Number.isNaN(lengthOnRef)) {\n      console.warn(\n        `${\n          cramRecord.readName ||\n          `${cramRecord.sequenceId}:${cramRecord.alignmentStart}`\n        } record has invalid read features`,\n      )\n      lengthOnRef = cramRecord.readLength\n    }\n    cramRecord.lengthOnRef = lengthOnRef\n\n    // mapping quality\n    cramRecord.mappingQuality = decodeDataSeries('MQ')\n    if (cramRecord.isPreservingQualityScores()) {\n      const bases = new Array(cramRecord.readLength)\n      for (let i = 0; i < bases.length; i += 1) {\n        bases[i] = decodeDataSeries('QS')\n      }\n      cramRecord.qualityScores = bases\n    }\n  } else if (cramRecord.isUnknownBases()) {\n    cramRecord.readBases = null\n    cramRecord.qualityScores = null\n  } else {\n    const bases = new Array(cramRecord.readLength)\n    for (let i = 0; i < bases.length; i += 1) {\n      bases[i] = decodeDataSeries('BA')\n    }\n    cramRecord.readBases = String.fromCharCode(...bases)\n\n    if (cramRecord.isPreservingQualityScores()) {\n      for (let i = 0; i < bases.length; i += 1) {\n        bases[i] = decodeDataSeries('QS')\n      }\n\n      cramRecord.qualityScores = bases\n    }\n  }\n\n  return cramRecord\n}\n","import {\n  CramMalformedError,\n  CramBufferOverrunError,\n  CramArgumentError,\n} from '../../errors'\nimport { parseItem, tinyMemoize, sequenceMD5 } from '../util'\n\nimport Constants from '../constants'\nimport decodeRecord from './decodeRecord'\n\n/**\n * @private\n * Try to estimate the template length from a bunch of interrelated multi-segment reads.\n * @param {Array[CramRecord]} allRecords\n * @param {number} currentRecordNumber\n * @param {CramRecord} thisRecord\n */\nfunction calculateMultiSegmentMatedTemplateLength(\n  allRecords,\n  currentRecordNumber,\n  thisRecord,\n) {\n  function getAllMatedRecords(startRecord) {\n    const records = [startRecord]\n    if (startRecord.mateRecordNumber >= 0) {\n      const mateRecord = allRecords[startRecord.mateRecordNumber]\n      if (!mateRecord) {\n        throw new CramMalformedError(\n          'intra-slice mate record not found, this file seems malformed',\n        )\n      }\n      records.push(...getAllMatedRecords(mateRecord))\n    }\n    return records\n  }\n\n  const matedRecords = getAllMatedRecords(thisRecord)\n  const starts = matedRecords.map(r => r.alignmentStart)\n  const ends = matedRecords.map(r => r.alignmentStart + r.readLength - 1)\n  const estimatedTemplateLength = Math.max(...ends) - Math.min(...starts) + 1\n  if (estimatedTemplateLength >= 0) {\n    matedRecords.forEach(r => {\n      if (r.templateLength !== undefined) {\n        throw new CramMalformedError(\n          'mate pair group has some members that have template lengths already, this file seems malformed',\n        )\n      }\n      r.templateLength = estimatedTemplateLength\n    })\n  }\n}\n\n/**\n * @private\n * Attempt to calculate the `templateLength` for a pair of intra-slice paired reads.\n * Ported from htslib. Algorithm is imperfect.\n * @param {CramRecord} thisRecord\n * @param {CramRecord} mateRecord\n */\nfunction calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord) {\n  // this just estimates the template length by using the simple (non-gapped) end coordinate of each\n  // read, because gapping in the alignment doesn't mean the template is longer or shorter\n  const start = Math.min(thisRecord.alignmentStart, mateRecord.alignmentStart)\n  const end = Math.max(\n    thisRecord.alignmentStart + thisRecord.readLength - 1,\n    mateRecord.alignmentStart + mateRecord.readLength - 1,\n  )\n  const lengthEstimate = end - start + 1\n  thisRecord.templateLength = lengthEstimate\n  mateRecord.templateLength = lengthEstimate\n}\n\n/**\n * @private establishes a mate-pair relationship between two records in the same slice.\n * CRAM compresses mate-pair relationships between records in the same slice down into\n * just one record having the index in the slice of its mate\n */\nfunction associateIntraSliceMate(\n  allRecords,\n  currentRecordNumber,\n  thisRecord,\n  mateRecord,\n) {\n  if (!mateRecord) {\n    throw new CramMalformedError(\n      'could not resolve intra-slice mate pairs, file seems truncated or malformed',\n    )\n  }\n\n  const complicatedMultiSegment = !!(\n    mateRecord.mate ||\n    (mateRecord.mateRecordNumber !== undefined &&\n      mateRecord.mateRecordNumber !== currentRecordNumber)\n  )\n\n  // Deal with lossy read names\n  if (!thisRecord.readName) {\n    thisRecord.readName = String(thisRecord.uniqueId)\n    mateRecord.readName = thisRecord.readName\n  }\n\n  thisRecord.mate = {\n    sequenceId: mateRecord.sequenceId,\n    alignmentStart: mateRecord.alignmentStart,\n    uniqueId: mateRecord.uniqueId,\n  }\n  if (mateRecord.readName) {\n    thisRecord.mate.readName = mateRecord.readName\n  }\n\n  // the mate record might have its own mate pointer, if this is some kind of\n  // multi-segment (more than paired) scheme, so only relate that one back to this one\n  // if it does not have any other relationship\n  if (!mateRecord.mate && mateRecord.mateRecordNumber === undefined) {\n    mateRecord.mate = {\n      sequenceId: thisRecord.sequenceId,\n      alignmentStart: thisRecord.alignmentStart,\n      uniqueId: thisRecord.uniqueId,\n    }\n    if (thisRecord.readName) {\n      mateRecord.mate.readName = thisRecord.readName\n    }\n  }\n\n  // make sure the proper flags and cramFlags are set on both records\n  // paired\n  thisRecord.flags |= Constants.BAM_FPAIRED\n\n  // set mate unmapped if needed\n  if (mateRecord.flags & Constants.BAM_FUNMAP) {\n    thisRecord.flags |= Constants.BAM_FMUNMAP\n    // thisRecord.templateLength = 0\n  }\n  if (thisRecord.flags & Constants.BAM_FUNMAP) {\n    // thisRecord.templateLength = 0\n    mateRecord.flags |= Constants.BAM_FMUNMAP\n  }\n\n  // set mate reversed if needed\n  if (mateRecord.flags & Constants.BAM_FREVERSE) {\n    thisRecord.flags |= Constants.BAM_FMREVERSE\n  }\n  if (thisRecord.flags & Constants.BAM_FREVERSE) {\n    mateRecord.flags |= Constants.BAM_FMREVERSE\n  }\n\n  if (thisRecord.templateLength === undefined) {\n    if (complicatedMultiSegment) {\n      calculateMultiSegmentMatedTemplateLength(\n        allRecords,\n        currentRecordNumber,\n        thisRecord,\n      )\n    } else {\n      calculateIntraSliceMatePairTemplateLength(thisRecord, mateRecord)\n    }\n  }\n\n  // delete this last because it's used by the\n  // complicated template length estimation\n  delete thisRecord.mateRecordNumber\n}\n\nexport default class CramSlice {\n  constructor(container, position) {\n    this.container = container\n    this.file = container.file\n    this.containerPosition = position\n  }\n\n  // memoize\n  async getHeader() {\n    // fetch and parse the slice header\n    const sectionParsers = await this.file.getSectionParsers()\n    const containerHeader = await this.container.getHeader()\n    const header = await this.file.readBlock(\n      containerHeader._endPosition + this.containerPosition,\n    )\n    if (header.contentType === 'MAPPED_SLICE_HEADER') {\n      header.content = parseItem(\n        header.content,\n        sectionParsers.cramMappedSliceHeader.parser,\n        0,\n        containerHeader._endPosition,\n      )\n    } else if (header.contentType === 'UNMAPPED_SLICE_HEADER') {\n      header.content = parseItem(\n        header.content,\n        sectionParsers.cramUnmappedSliceHeader.parser,\n        0,\n        containerHeader._endPosition,\n      )\n    } else {\n      throw new CramMalformedError(\n        `error reading slice header block, invalid content type ${header._contentType}`,\n      )\n    }\n    return header\n  }\n\n  // memoize\n  async getBlocks() {\n    const header = await this.getHeader()\n    // read all the blocks into memory and store them\n    let blockPosition = header._endPosition\n    const blocks = new Array(header.content.numBlocks)\n    for (let i = 0; i < blocks.length; i += 1) {\n      blocks[i] = await this.file.readBlock(blockPosition)\n      blockPosition = blocks[i]._endPosition\n    }\n\n    return blocks\n  }\n\n  // no memoize\n  async getCoreDataBlock() {\n    const blocks = await this.getBlocks()\n    // the core data block is always the first block in the slice\n    return blocks[0]\n  }\n\n  // memoize\n  async _getBlocksContentIdIndex() {\n    const blocks = await this.getBlocks()\n    const blocksByContentId = {}\n    blocks.forEach(block => {\n      if (block.contentType === 'EXTERNAL_DATA') {\n        blocksByContentId[block.contentId] = block\n      }\n    })\n    return blocksByContentId\n  }\n\n  async getBlockByContentId(id) {\n    const blocksByContentId = await this._getBlocksContentIdIndex()\n    return blocksByContentId[id]\n  }\n\n  async getReferenceRegion() {\n    // read the slice header\n    const sliceHeader = (await this.getHeader()).content\n\n    if (sliceHeader.refSeqId < 0) {\n      return undefined\n    }\n\n    const compressionScheme = await this.container.getCompressionScheme()\n\n    // console.log(JSON.stringify(sliceHeader, null, '  '))\n\n    if (sliceHeader.refBaseBlockId >= 0) {\n      const refBlock = this.getBlockByContentId(sliceHeader.refBaseBlockId)\n      if (!refBlock) {\n        throw new CramMalformedError(\n          'embedded reference specified, but reference block does not exist',\n        )\n      }\n\n      if (sliceHeader.span > refBlock.uncompressedSize) {\n        throw new CramMalformedError('Embedded reference is too small')\n      }\n\n      return {\n        seq: refBlock.data.toString('utf8'),\n        start: sliceHeader.refSeqStart,\n        end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,\n        span: sliceHeader.refSeqSpan,\n      }\n    }\n    if (\n      compressionScheme.referenceRequired ||\n      this.file.fetchReferenceSequenceCallback\n    ) {\n      if (!this.file.fetchReferenceSequenceCallback) {\n        throw new Error(\n          'reference sequence not embedded, and seqFetch callback not provided, cannot fetch reference sequence',\n        )\n      }\n\n      const seq = await this.file.fetchReferenceSequenceCallback(\n        sliceHeader.refSeqId,\n        sliceHeader.refSeqStart,\n        sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,\n      )\n\n      if (seq.length !== sliceHeader.refSeqSpan) {\n        throw new CramArgumentError(\n          'seqFetch callback returned a reference sequence of the wrong length',\n        )\n      }\n\n      return {\n        seq,\n        start: sliceHeader.refSeqStart,\n        end: sliceHeader.refSeqStart + sliceHeader.refSeqSpan - 1,\n        span: sliceHeader.refSeqSpan,\n      }\n    }\n\n    return undefined\n  }\n\n  getAllRecords() {\n    return this.getRecords(() => true)\n  }\n\n  async _fetchRecords() {\n    const { majorVersion } = await this.file.getDefinition()\n\n    const compressionScheme = await this.container.getCompressionScheme()\n\n    const sliceHeader = await this.getHeader()\n\n    const blocksByContentId = await this._getBlocksContentIdIndex()\n\n    // check MD5 of reference if available\n    if (\n      majorVersion > 1 &&\n      this.file.options.checkSequenceMD5 &&\n      sliceHeader.content.refSeqId >= 0 &&\n      sliceHeader.content.md5.join('') !== '0000000000000000'\n    ) {\n      const refRegion = await this.getReferenceRegion()\n      if (refRegion) {\n        const { seq, start, end } = refRegion\n        const seqMd5 = sequenceMD5(seq)\n        const storedMd5 = sliceHeader.content.md5\n          .map(byte => (byte < 16 ? '0' : '') + byte.toString(16))\n          .join('')\n        if (seqMd5 !== storedMd5) {\n          throw new CramMalformedError(\n            `MD5 checksum reference mismatch for ref ${sliceHeader.content.refSeqId} pos ${start}..${end}. recorded MD5: ${storedMd5}, calculated MD5: ${seqMd5}`,\n          )\n        }\n      }\n    }\n\n    // tracks the read position within the block. codec.decode() methods\n    // advance the byte and bit positions in the cursor as they decode data\n    // note that we are only decoding a single block here, the core data block\n    const coreDataBlock = await this.getCoreDataBlock()\n    const cursors = {\n      lastAlignmentStart: sliceHeader.content.refSeqStart || 0,\n      coreBlock: { bitPosition: 7, bytePosition: 0 },\n      externalBlocks: {\n        getCursor(contentId) {\n          if (!this[contentId]) {\n            this[contentId] = { bitPosition: 7, bytePosition: 0 }\n          }\n          return this[contentId]\n        },\n      },\n    }\n\n    const decodeDataSeries = dataSeriesName => {\n      const codec = compressionScheme.getCodecForDataSeries(dataSeriesName)\n      if (!codec) {\n        throw new CramMalformedError(\n          `no codec defined for ${dataSeriesName} data series`,\n        )\n      }\n      // console.log(dataSeriesName, Object.getPrototypeOf(codec))\n      return codec.decode(this, coreDataBlock, blocksByContentId, cursors)\n    }\n    let records = new Array(sliceHeader.content.numRecords)\n    for (let i = 0; i < records.length; i += 1) {\n      try {\n        records[i] = decodeRecord(\n          this,\n          decodeDataSeries,\n          compressionScheme,\n          sliceHeader,\n          coreDataBlock,\n          blocksByContentId,\n          cursors,\n          majorVersion,\n          i,\n        )\n        records[i].uniqueId =\n          sliceHeader.contentPosition +\n          sliceHeader.content.recordCounter +\n          i +\n          1\n      } catch (e) {\n        if (e instanceof CramBufferOverrunError) {\n          console.warn(\n            'read attempted beyond end of buffer, file seems truncated.',\n          )\n          records = records.filter(r => !!r)\n          break\n        } else {\n          throw e\n        }\n      }\n    }\n\n    // interpret `recordsToNextFragment` attributes to make standard `mate` objects\n    // Resolve mate pair cross-references between records in this slice\n    for (let i = 0; i < records.length; i += 1) {\n      const { mateRecordNumber } = records[i]\n      if (mateRecordNumber >= 0) {\n        associateIntraSliceMate(\n          records,\n          i,\n          records[i],\n          records[mateRecordNumber],\n        )\n      }\n    }\n\n    return records\n  }\n\n  async getRecords(filterFunction) {\n    // fetch the features if necessary, using the file-level feature cache\n    const cacheKey = this.container.filePosition + this.containerPosition\n    let recordsPromise = this.file.featureCache.get(cacheKey)\n    if (!recordsPromise) {\n      recordsPromise = this._fetchRecords()\n      this.file.featureCache.set(cacheKey, recordsPromise)\n    }\n\n    const records = (await recordsPromise).filter(filterFunction)\n\n    // if we can fetch reference sequence, add the reference sequence to the records\n    if (records.length && this.file.fetchReferenceSequenceCallback) {\n      const sliceHeader = await this.getHeader()\n      if (\n        sliceHeader.content.refSeqId >= 0 || // single-ref slice\n        sliceHeader.content.refSeqId === -2 // multi-ref slice\n      ) {\n        const singleRefId =\n          sliceHeader.content.refSeqId >= 0\n            ? sliceHeader.content.refSeqId\n            : undefined\n        const compressionScheme = await this.container.getCompressionScheme()\n        const refRegions = {} // seqId => { start, end, seq }\n\n        // iterate over the records to find the spans of the reference sequences we need to fetch\n        for (let i = 0; i < records.length; i += 1) {\n          const seqId =\n            singleRefId !== undefined ? singleRefId : records[i].sequenceId\n          let refRegion = refRegions[seqId]\n          if (!refRegion) {\n            refRegion = {\n              id: seqId,\n              start: records[i].alignmentStart,\n              end: -Infinity,\n            }\n            refRegions[seqId] = refRegion\n          }\n\n          const end =\n            records[i].alignmentStart +\n            (records[i].lengthOnRef || records[i].readLength) -\n            1\n          if (end > refRegion.end) {\n            refRegion.end = end\n          }\n          if (records[i].alignmentStart < refRegion.start) {\n            refRegion.start = records[i].alignmentStart\n          }\n        }\n\n        // fetch the `seq` for all of the ref regions\n        await Promise.all(\n          Object.values(refRegions).map(async refRegion => {\n            if (refRegion.id !== -1 && refRegion.start <= refRegion.end) {\n              refRegion.seq = await this.file.fetchReferenceSequenceCallback(\n                refRegion.id,\n                refRegion.start,\n                refRegion.end,\n              )\n            }\n          }),\n        )\n\n        // now decorate all the records with them\n        for (let i = 0; i < records.length; i += 1) {\n          const seqId =\n            singleRefId !== undefined ? singleRefId : records[i].sequenceId\n          const refRegion = refRegions[seqId]\n          if (refRegion && refRegion.seq) {\n            records[i].addReferenceSequence(refRegion, compressionScheme)\n          }\n        }\n      }\n    }\n\n    return records\n  }\n}\n\n// memoize several methods in the class for performance\n'getHeader getBlocks _getBlocksContentIdIndex'\n  .split(' ')\n  .forEach(method => tinyMemoize(CramSlice, method))\n","import { CramBufferOverrunError } from '../../errors'\n\nconst validDataTypes = {\n  int: true,\n  byte: true,\n  long: true,\n  byteArray: true,\n  byteArrayBlock: true,\n}\n\n// codec base class\nexport default class CramCodec {\n  constructor(parameters = {}, dataType) {\n    this.parameters = parameters\n    this.dataType = dataType\n    if (!dataType) {\n      throw new TypeError('must provide a data type to codec constructor')\n    }\n    if (!validDataTypes[dataType]) {\n      throw new TypeError(`invalid data type ${dataType}`)\n    }\n  }\n\n  // decode(slice, coreDataBlock, blocksByContentId, cursors) {\n  // }\n\n  _getBits(data, cursor, numBits) {\n    let val = 0\n    if (\n      cursor.bytePosition + (7 - cursor.bitPosition + numBits) / 8 >\n      data.length\n    ) {\n      throw new CramBufferOverrunError(\n        'read error during decoding. the file seems to be truncated.',\n      )\n    }\n    for (let dlen = numBits; dlen; dlen -= 1) {\n      // get the next `dlen` bits in the input, put them in val\n      val <<= 1\n      val |= (data[cursor.bytePosition] >> cursor.bitPosition) & 1\n      cursor.bitPosition -= 1\n      if (cursor.bitPosition < 0) {\n        cursor.bytePosition += 1\n      }\n      cursor.bitPosition &= 7\n    }\n    return val\n  }\n}\n","import { CramMalformedError } from '../../errors'\nimport CramCodec from './_base'\n\nfunction numberOfSetBits(ii) {\n  let i = (ii - (ii >> 1)) & 0x55555555\n  i = (i & 0x33333333) + ((i >> 2) & 0x33333333)\n  return (((i + (i >> 4)) & 0x0f0f0f0f) * 0x01010101) >> 24\n}\n\nexport default class HuffmanIntCodec extends CramCodec {\n  constructor(parameters = {}, dataType) {\n    super(parameters, dataType)\n    if (!['byte', 'int'].includes(this.dataType)) {\n      throw new TypeError(\n        `${this.dataType} decoding not yet implemented by HUFFMAN_INT codec`,\n      )\n    }\n\n    this.buildCodeBook()\n    this.buildCodes()\n    this.buildCaches()\n\n    // if this is a degenerate zero-length huffman code, special-case the decoding\n    if (this.sortedCodes[0].bitLength === 0) {\n      this._decode = this._decodeZeroLengthCode\n    }\n  }\n\n  buildCodeBook() {\n    // parse the parameters together into a `codes` data structure\n    let codes = new Array(this.parameters.numCodes)\n    for (let i = 0; i < this.parameters.numCodes; i += 1) {\n      codes[i] = {\n        symbol: this.parameters.symbols[i],\n        bitLength: this.parameters.bitLengths[i],\n      }\n    }\n    // sort the codes by bit length and symbol value\n    codes = codes.sort(\n      (a, b) => a.bitLength - b.bitLength || a.symbol - b.symbol,\n    )\n\n    this.codeBook = {}\n    codes.forEach(code => {\n      if (!this.codeBook[code.bitLength]) {\n        this.codeBook[code.bitLength] = []\n      }\n      this.codeBook[code.bitLength].push(code.symbol)\n    })\n  }\n\n  buildCodes() {\n    this.codes = {} /*  new TreeMap<Integer, HuffmanBitCode>(); */\n    let codeLength = 0\n    let codeValue = -1\n    Object.entries(this.codeBook).forEach(([bitLength, symbols]) => {\n      bitLength = parseInt(bitLength, 10)\n      symbols.forEach(symbol => {\n        const code = { bitLength, value: symbol }\n        codeValue += 1\n        const delta = bitLength - codeLength // new length?\n        codeValue <<= delta // pad with 0's\n        code.bitCode = codeValue // calculated: huffman code\n        codeLength += delta // adjust current code length\n\n        if (numberOfSetBits(codeValue) > bitLength) {\n          throw new CramMalformedError('Symbol out of range')\n        }\n\n        this.codes[symbol] = code\n      })\n    })\n  }\n\n  buildCaches() {\n    this.sortedCodes = Object.values(this.codes).sort(\n      (a, b) => a.bitLength - b.bitLength || a.bitCode - b.bitCode,\n    )\n\n    // this.sortedValues = this.parameters.values.sort((a,b) => a-b)\n    this.sortedByValue = Object.values(this.codes).sort(\n      (a, b) => a.value - b.value,\n    )\n\n    this.sortedValuesByBitCode = this.sortedCodes.map(c => c.value)\n    this.sortedBitCodes = this.sortedCodes.map(c => c.bitCode)\n    this.sortedBitLengthsByBitCode = this.sortedCodes.map(c => c.bitLength)\n    const maxBitCode = Math.max(...this.sortedBitCodes)\n\n    this.bitCodeToValue = new Array(maxBitCode + 1).fill(-1)\n    for (let i = 0; i < this.sortedBitCodes.length; i += 1) {\n      this.bitCodeToValue[this.sortedCodes[i].bitCode] = i\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    return this._decode(slice, coreDataBlock, cursors.coreBlock)\n  }\n\n  // _decodeNull() {\n  //   return -1\n  // }\n\n  // the special case for zero-length codes\n  _decodeZeroLengthCode() {\n    return this.sortedCodes[0].value\n  }\n\n  _decode(slice, coreDataBlock, coreCursor) {\n    const input = coreDataBlock.content\n\n    let prevLen = 0\n    let bits = 0\n    for (let i = 0; i < this.sortedCodes.length; i += 1) {\n      const length = this.sortedCodes[i].bitLength\n      bits <<= length - prevLen\n      bits |= this._getBits(input, coreCursor, length - prevLen)\n      prevLen = length\n      {\n        const index = this.bitCodeToValue[bits]\n        if (index > -1 && this.sortedBitLengthsByBitCode[index] === length) {\n          return this.sortedValuesByBitCode[index]\n        }\n\n        for (\n          let j = i;\n          this.sortedCodes[j + 1].bitLength === length &&\n          j < this.sortedCodes.length;\n          j += 1\n        ) {\n          i += 1\n        }\n      }\n    }\n    throw new CramMalformedError('Huffman symbol not found.')\n  }\n}\n","import {\n  CramUnimplementedError,\n  CramMalformedError,\n  CramBufferOverrunError,\n} from '../../errors'\nimport CramCodec from './_base'\nimport { parseItf8 } from '../util'\n\nexport default class ExternalCodec extends CramCodec {\n  constructor(parameters = {}, dataType) {\n    super(parameters, dataType)\n    if (this.dataType === 'int') {\n      this._decodeData = this._decodeInt\n    } else if (this.dataType === 'byte') {\n      this._decodeData = this._decodeByte\n    } else {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by EXTERNAL codec`,\n      )\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    const { blockContentId } = this.parameters\n    const contentBlock = blocksByContentId[blockContentId]\n    if (!contentBlock) {\n      throw new CramMalformedError(\n        `no block found with content ID ${blockContentId}`,\n      )\n    }\n    const cursor = cursors.externalBlocks.getCursor(blockContentId)\n    return this._decodeData(contentBlock, cursor)\n  }\n\n  _decodeInt(contentBlock, cursor) {\n    const [result, bytesRead] = parseItf8(\n      contentBlock.content,\n      cursor.bytePosition,\n    )\n    cursor.bytePosition += bytesRead\n    return result\n  }\n\n  _decodeByte(contentBlock, cursor) {\n    if (cursor.bytePosition >= contentBlock.content.length) {\n      throw new CramBufferOverrunError(\n        'attempted to read beyond end of block. this file seems truncated.',\n      )\n    }\n    const result = contentBlock.content[cursor.bytePosition]\n    cursor.bytePosition += 1\n    return result\n  }\n}\n","import { CramBufferOverrunError, CramMalformedError } from '../../errors'\n\nimport CramCodec from './_base'\n\nexport default class ByteArrayStopCodec extends CramCodec {\n  constructor(parameters = {}, dataType) {\n    super(parameters, dataType)\n    if (dataType === 'byteArray') {\n      this._decode = this._decodeByteArray\n    } else {\n      throw new TypeError(\n        `byteArrayStop codec does not support data type ${dataType}`,\n      )\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    const { blockContentId } = this.parameters\n    const contentBlock = blocksByContentId[blockContentId]\n    if (!contentBlock) {\n      throw new CramMalformedError(\n        `no block found with content ID ${blockContentId}`,\n      )\n    }\n    const cursor = cursors.externalBlocks.getCursor(blockContentId)\n    return this._decode(contentBlock, cursor)\n  }\n\n  _decodeByteArray(contentBlock, cursor) {\n    const dataBuffer = contentBlock.content\n    const { stopByte } = this.parameters\n    // scan to the next stop byte\n    const startPosition = cursor.bytePosition\n    let stopPosition = cursor.bytePosition\n    while (\n      dataBuffer[stopPosition] !== stopByte &&\n      stopPosition < dataBuffer.length\n    ) {\n      if (stopPosition === dataBuffer.length) {\n        throw new CramBufferOverrunError(\n          `byteArrayStop reading beyond length of data buffer?`,\n        )\n      }\n      stopPosition += 1\n    }\n    cursor.bytePosition = stopPosition + 1\n    const data = dataBuffer.slice(startPosition, stopPosition)\n    return data\n  }\n}\n","import { tinyMemoize } from '../util'\n\nimport CramCodec from './_base'\n\nexport default class ByteArrayStopCodec extends CramCodec {\n  constructor(parameters = {}, dataType, instantiateCodec) {\n    super(parameters, dataType)\n    this.instantiateCodec = instantiateCodec\n    if (dataType !== 'byteArray') {\n      throw new TypeError(\n        `byteArrayLength does not support data type ${dataType}`,\n      )\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    const lengthCodec = this._getLengthCodec()\n    const arrayLength = lengthCodec.decode(\n      slice,\n      coreDataBlock,\n      blocksByContentId,\n      cursors,\n    )\n\n    const dataCodec = this._getDataCodec()\n    const data = new Array(arrayLength)\n    for (let i = 0; i < arrayLength; i += 1) {\n      data[i] = dataCodec.decode(\n        slice,\n        coreDataBlock,\n        blocksByContentId,\n        cursors,\n      )\n    }\n\n    return data\n  }\n\n  // memoize\n  _getLengthCodec() {\n    const encodingParams = this.parameters.lengthsEncoding\n    return this.instantiateCodec(encodingParams, 'int')\n  }\n\n  // memoize\n  _getDataCodec() {\n    const encodingParams = this.parameters.valuesEncoding\n\n    return this.instantiateCodec(encodingParams, 'byte')\n  }\n}\n\n'_getLengthCodec _getDataCodec'\n  .split(' ')\n  .forEach(method => tinyMemoize(ByteArrayStopCodec, method))\n","import { CramUnimplementedError } from '../../errors'\nimport CramCodec from './_base'\n\nexport default class BetaCodec extends CramCodec {\n  constructor(parameters = {}, dataType) {\n    super(parameters, dataType)\n    if (this.dataType !== 'int') {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by BETA codec`,\n      )\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    const data =\n      this._getBits(\n        coreDataBlock.content,\n        cursors.coreBlock,\n        this.parameters.length,\n      ) - this.parameters.offset\n    return data\n  }\n}\n","import { CramUnimplementedError } from '../../errors'\nimport CramCodec from './_base'\n\nexport default class GammaCodec extends CramCodec {\n  constructor(parameters = {}, dataType) {\n    super(parameters, dataType)\n    if (this.dataType !== 'int') {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by GAMMA codec`,\n      )\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    let length = 1\n\n    while (this._getBits(coreDataBlock.content, cursors.coreBlock, 1) === 0) {\n      length += 1\n    }\n\n    const readBits = this._getBits(\n      coreDataBlock.content,\n      cursors.coreBlock,\n      length - 1,\n    )\n\n    const value = readBits | (1 << (length - 1))\n    return value - this.parameters.offset\n  }\n}\n","import { CramUnimplementedError } from '../../errors'\nimport CramCodec from './_base'\n\nexport default class SubexpCodec extends CramCodec {\n  constructor(parameters = {}, dataType) {\n    super(parameters, dataType)\n    if (this.dataType !== 'int') {\n      throw new CramUnimplementedError(\n        `${this.dataType} decoding not yet implemented by SUBEXP codec`,\n      )\n    }\n  }\n\n  decode(slice, coreDataBlock, blocksByContentId, cursors) {\n    let numLeadingOnes = 0\n    while (this._getBits(coreDataBlock.content, cursors.coreBlock, 1)) {\n      numLeadingOnes += 1\n    }\n\n    let b\n    let n\n    if (numLeadingOnes === 0) {\n      b = this.parameters.K\n      n = this._getBits(coreDataBlock.content, cursors.coreBlock, b)\n    } else {\n      b = numLeadingOnes + this.parameters.K - 1\n      n = (1 << b) | this._getBits(coreDataBlock.content, cursors.coreBlock, b)\n    }\n\n    return n - this.parameters.offset\n  }\n}\n","import { CramUnimplementedError } from '../../errors'\n\nimport HuffmanIntCodec from './huffman'\nimport ExternalCodec from './external'\nimport ByteArrayStopCodec from './byteArrayStop'\nimport ByteArrayLengthCodec from './byteArrayLength'\nimport BetaCodec from './beta'\nimport GammaCodec from './gamma'\nimport SubexpCodec from './subexp'\n\nconst codecClasses = {\n  1: ExternalCodec,\n  // 2: GolombCodec,\n  3: HuffmanIntCodec,\n  4: ByteArrayLengthCodec,\n  5: ByteArrayStopCodec,\n  6: BetaCodec,\n  7: SubexpCodec,\n  // 8: GolombRiceCodec,\n  9: GammaCodec,\n}\n\nexport function getCodecClassWithId(id) {\n  return codecClasses[id]\n}\n\nexport function instantiateCodec(encodingData, dataType) {\n  const CodecClass = getCodecClassWithId(\n    dataType === 'ignore' ? 0 : encodingData.codecId,\n  )\n  if (!CodecClass) {\n    throw new CramUnimplementedError(\n      `no codec implemented for codec ID ${encodingData.codecId}`,\n    )\n  }\n\n  return new CodecClass(encodingData.parameters, dataType, instantiateCodec)\n}\n","import { CramMalformedError } from '../../errors'\nimport { instantiateCodec } from '../codecs'\n\n// the hardcoded data type to be decoded for each core\n// data field\nconst dataSeriesTypes = {\n  BF: 'int',\n  CF: 'int',\n  RI: 'int',\n  RL: 'int',\n  AP: 'int',\n  RG: 'int',\n  MF: 'int',\n  NS: 'int',\n  NP: 'int',\n  TS: 'int',\n  NF: 'int',\n  TC: 'byte',\n  TN: 'int',\n  FN: 'int',\n  FC: 'byte',\n  FP: 'int',\n  BS: 'byte',\n  IN: 'byteArray',\n  SC: 'byteArray',\n  DL: 'int',\n  BA: 'byte',\n  BB: 'byteArray',\n  RS: 'int',\n  PD: 'int',\n  HC: 'int',\n  MQ: 'int',\n  RN: 'byteArray',\n  QS: 'byte',\n  QQ: 'byteArray',\n  TL: 'int',\n  TM: 'ignore',\n  TV: 'ignore',\n}\n\nfunction parseSubstitutionMatrix(byteArray) {\n  const matrix = new Array(5)\n  for (let i = 0; i < 5; i += 1) {\n    matrix[i] = new Array(4)\n  }\n\n  matrix[0][(byteArray[0] >> 6) & 3] = 'C'\n  matrix[0][(byteArray[0] >> 4) & 3] = 'G'\n  matrix[0][(byteArray[0] >> 2) & 3] = 'T'\n  matrix[0][(byteArray[0] >> 0) & 3] = 'N'\n\n  matrix[1][(byteArray[1] >> 6) & 3] = 'A'\n  matrix[1][(byteArray[1] >> 4) & 3] = 'G'\n  matrix[1][(byteArray[1] >> 2) & 3] = 'T'\n  matrix[1][(byteArray[1] >> 0) & 3] = 'N'\n\n  matrix[2][(byteArray[2] >> 6) & 3] = 'A'\n  matrix[2][(byteArray[2] >> 4) & 3] = 'C'\n  matrix[2][(byteArray[2] >> 2) & 3] = 'T'\n  matrix[2][(byteArray[2] >> 0) & 3] = 'N'\n\n  matrix[3][(byteArray[3] >> 6) & 3] = 'A'\n  matrix[3][(byteArray[3] >> 4) & 3] = 'C'\n  matrix[3][(byteArray[3] >> 2) & 3] = 'G'\n  matrix[3][(byteArray[3] >> 0) & 3] = 'N'\n\n  matrix[4][(byteArray[4] >> 6) & 3] = 'A'\n  matrix[4][(byteArray[4] >> 4) & 3] = 'C'\n  matrix[4][(byteArray[4] >> 2) & 3] = 'G'\n  matrix[4][(byteArray[4] >> 0) & 3] = 'T'\n\n  return matrix\n}\n\nexport default class CramContainerCompressionScheme {\n  constructor(content) {\n    Object.assign(this, content)\n    // interpret some of the preservation map tags for convenient use\n    this.readNamesIncluded = content.preservation.RN\n    this.APdelta = content.preservation.AP\n    this.referenceRequired = !!content.preservation.RR\n    this.tagIdsDictionary = content.preservation.TD\n    this.substitutionMatrix = parseSubstitutionMatrix(content.preservation.SM)\n\n    this.dataSeriesCodecCache = {}\n    this.tagCodecCache = {}\n  }\n\n  /**\n   * @param {string} tagName three-character tag name\n   * @private\n   */\n  getCodecForTag(tagName) {\n    if (!this.tagCodecCache[tagName]) {\n      const encodingData = this.tagEncoding[tagName]\n      if (encodingData) {\n        this.tagCodecCache[tagName] = instantiateCodec(\n          encodingData,\n          'byteArray', // all tags are byte array data\n        )\n      }\n    }\n    return this.tagCodecCache[tagName]\n  }\n\n  /**\n   *\n   * @param {number} tagListId ID of the tag list to fetch from the tag dictionary\n   * @private\n   */\n  getTagNames(tagListId) {\n    return this.tagIdsDictionary[tagListId]\n  }\n\n  getCodecForDataSeries(dataSeriesName) {\n    if (!this.dataSeriesCodecCache[dataSeriesName]) {\n      const encodingData = this.dataSeriesEncoding[dataSeriesName]\n      if (encodingData) {\n        const dataType = dataSeriesTypes[dataSeriesName]\n        if (!dataType) {\n          throw new CramMalformedError(\n            `data series name ${dataSeriesName} not defined in file compression header`,\n          )\n        }\n        this.dataSeriesCodecCache[dataSeriesName] = instantiateCodec(\n          encodingData,\n          dataType,\n        )\n      }\n    }\n    return this.dataSeriesCodecCache[dataSeriesName]\n  }\n\n  toJSON() {\n    const data = {}\n    Object.keys(this).forEach(k => {\n      if (/Cache$/.test(k)) {\n        return\n      }\n      data[k] = this[k]\n    })\n    return data\n  }\n}\n","import { CramMalformedError } from '../../errors'\n\nimport { itf8Size, parseItem, tinyMemoize } from '../util'\nimport CramSlice from '../slice'\nimport CramContainerCompressionScheme from './compressionScheme'\n\nexport default class CramContainer {\n  constructor(cramFile, position) {\n    // cram file this container comes from\n    this.file = cramFile\n    // position of this container in the file\n    this.filePosition = position\n    // console.log(`container: ${this.filePosition}`)\n  }\n\n  // memoize\n  getHeader() {\n    return this._readContainerHeader(this.filePosition)\n  }\n\n  // memoize\n  async getCompressionHeaderBlock() {\n    const containerHeader = await this.getHeader()\n\n    // if there are no records in the container, there will be no compression header\n    if (!containerHeader.numRecords) {\n      return null\n    }\n    const sectionParsers = await this.file.getSectionParsers()\n    const block = await this.getFirstBlock()\n    if (block.contentType !== 'COMPRESSION_HEADER') {\n      throw new CramMalformedError(\n        `invalid content type ${block.contentType} in what is supposed to be the compression header block`,\n      )\n    }\n    const content = parseItem(\n      block.content,\n      sectionParsers.cramCompressionHeader.parser,\n      0,\n      block.contentPosition,\n    )\n    block.content = content\n    return block\n  }\n\n  async getFirstBlock() {\n    const containerHeader = await this.getHeader()\n    return this.file.readBlock(containerHeader._endPosition)\n  }\n\n  // parses the compression header data into a CramContainerCompressionScheme object\n  // memoize\n  async getCompressionScheme() {\n    const header = await this.getCompressionHeaderBlock()\n    if (!header) {\n      return undefined\n    }\n    return new CramContainerCompressionScheme(header.content)\n  }\n\n  getSlice(slicePosition, sliceSize) {\n    // note: slicePosition is relative to the end of the container header\n    // TODO: perhaps we should cache slices?\n    return new CramSlice(this, slicePosition, sliceSize)\n  }\n\n  async _readContainerHeader(position) {\n    const sectionParsers = await this.file.getSectionParsers()\n    const { cramContainerHeader1, cramContainerHeader2 } = sectionParsers\n    const { size: fileSize } = await this.file.stat()\n\n    if (position >= fileSize) {\n      return undefined\n    }\n\n    // parse the container header. do it in 2 pieces because you cannot tell\n    // how much to buffer until you read numLandmarks\n    const bytes1 = Buffer.allocUnsafe(cramContainerHeader1.maxLength)\n    await this.file.read(bytes1, 0, cramContainerHeader1.maxLength, position)\n    const header1 = parseItem(bytes1, cramContainerHeader1.parser)\n    const numLandmarksSize = itf8Size(header1.numLandmarks)\n    if (position + header1.length >= fileSize) {\n      console.warn(\n        `${this.file}: container header at ${position} indicates that the container has length ${header1.length}, which extends beyond the length of the file. Skipping this container.`,\n      )\n      return undefined\n    }\n    const bytes2 = Buffer.allocUnsafe(\n      cramContainerHeader2.maxLength(header1.numLandmarks),\n    )\n    await this.file.read(\n      bytes2,\n      0,\n      cramContainerHeader2.maxLength(header1.numLandmarks),\n      position + header1._size - numLandmarksSize,\n    )\n    const header2 = parseItem(bytes2, cramContainerHeader2.parser)\n\n    if (this.file.validateChecksums && header2.crc32 !== undefined) {\n      await this.file.checkCrc32(\n        position,\n        header1._size + header2._size - numLandmarksSize - 4,\n        header2.crc32,\n        `container header beginning at position ${position}`,\n      )\n    }\n\n    const completeHeader = Object.assign(header1, header2, {\n      _size: header1._size + header2._size - numLandmarksSize,\n      _endPosition: header1._size + header2._size - numLandmarksSize + position,\n    })\n\n    return completeHeader\n  }\n}\n\n'getHeader getCompressionHeaderBlock getCompressionScheme'\n  .split(' ')\n  .forEach(method => tinyMemoize(CramContainer, method))\n","import LRU from 'quick-lru'\n\nexport default class BufferCache {\n  constructor({ fetch, size = 10000000, chunkSize = 32768 }) {\n    if (!fetch) {\n      throw new Error('fetch function required')\n    }\n    this.fetch = fetch\n    this.chunkSize = chunkSize\n    this.lruCache = new LRU({ maxSize: Math.floor(size / chunkSize) })\n  }\n\n  async get(outputBuffer, offset, length, position) {\n    if (outputBuffer.length < offset + length) {\n      throw new Error('output buffer not big enough for request')\n    }\n\n    // calculate the list of chunks involved in this fetch\n    const firstChunk = Math.floor(position / this.chunkSize)\n    const lastChunk = Math.floor((position + length) / this.chunkSize)\n\n    // fetch them all as necessary\n    const fetches = new Array(lastChunk - firstChunk + 1)\n    for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n      fetches[chunk - firstChunk] = this._getChunk(chunk).then(data => ({\n        data,\n        chunkNumber: chunk,\n      }))\n    }\n\n    // stitch together the response buffer using them\n    const chunks = await Promise.all(fetches)\n    const chunksOffset = position - chunks[0].chunkNumber * this.chunkSize\n    chunks.forEach(({ data, chunkNumber }) => {\n      const chunkPositionStart = chunkNumber * this.chunkSize\n      let copyStart = 0\n      let copyEnd = this.chunkSize\n      let copyOffset =\n        offset + (chunkNumber - firstChunk) * this.chunkSize - chunksOffset\n\n      if (chunkNumber === firstChunk) {\n        copyOffset = offset\n        copyStart = chunksOffset\n      }\n      if (chunkNumber === lastChunk) {\n        copyEnd = position + length - chunkPositionStart\n      }\n\n      data.copy(outputBuffer, copyOffset, copyStart, copyEnd)\n    })\n  }\n\n  _getChunk(chunkNumber) {\n    const cachedPromise = this.lruCache.get(chunkNumber)\n    if (cachedPromise) {\n      return cachedPromise\n    }\n\n    const freshPromise = this.fetch(\n      chunkNumber * this.chunkSize,\n      this.chunkSize,\n    )\n    this.lruCache.set(chunkNumber, freshPromise)\n    return freshPromise\n  }\n}\n","import fetch from 'cross-fetch'\nimport BufferCache from './bufferCache'\n\nexport default class RemoteFile {\n  constructor(source) {\n    this.position = 0\n    this.url = source\n    this.cache = new BufferCache({\n      fetch: (start, length) => this._fetch(start, length),\n    })\n  }\n\n  async _fetch(position, length) {\n    const headers = {}\n    if (length < Infinity) {\n      headers.range = `bytes=${position}-${position + length}`\n    } else if (length === Infinity && position !== 0) {\n      headers.range = `bytes=${position}-`\n    }\n    const response = await fetch(this.url, {\n      method: 'GET',\n      headers,\n      redirect: 'follow',\n      mode: 'cors',\n    })\n    if (\n      (response.status === 200 && position === 0) ||\n      response.status === 206\n    ) {\n      const nodeBuffer = Buffer.from(await response.arrayBuffer())\n\n      // try to parse out the size of the remote file\n      const sizeMatch = /\\/(\\d+)$/.exec(response.headers.get('content-range'))\n      if (sizeMatch[1]) {\n        this._stat = { size: parseInt(sizeMatch[1], 10) }\n      }\n\n      return nodeBuffer\n    }\n    throw new Error(`HTTP ${response.status} fetching ${this.url}`)\n  }\n\n  read(buffer, offset = 0, length = Infinity, position = 0) {\n    let readPosition = position\n    if (readPosition === null) {\n      readPosition = this.position\n      this.position += length\n    }\n    return this.cache.get(buffer, offset, length, position)\n  }\n\n  async readFile() {\n    const response = await fetch(this.url, {\n      method: 'GET',\n      redirect: 'follow',\n      mode: 'cors',\n    })\n    return Buffer.from(await response.arrayBuffer())\n  }\n\n  async stat() {\n    if (!this._stat) {\n      const buf = Buffer.allocUnsafe(10)\n      await this.read(buf, 0, 10, 0)\n      if (!this._stat) {\n        throw new Error(`unable to determine size of file at ${this.url}`)\n      }\n    }\n    return this._stat\n  }\n}\n","import url from 'url'\nimport RemoteFile from './remoteFile'\nimport LocalFile from './localFile'\n\nfunction fromUrl(source) {\n  const { protocol, pathname } = url.parse(source)\n  if (protocol === 'file:') {\n    return new LocalFile(unescape(pathname))\n  }\n  return new RemoteFile(source)\n}\n\nfunction open(maybeUrl, maybePath, maybeFilehandle) {\n  if (maybeFilehandle) {\n    return maybeFilehandle\n  }\n  if (maybeUrl) {\n    return fromUrl(maybeUrl)\n  }\n  if (maybePath) {\n    return new LocalFile(maybePath)\n  }\n  throw new Error('no url, path, or filehandle provided, cannot open')\n}\n\nexport { LocalFile, RemoteFile, fromUrl, open }\n","export function parseHeaderText(text) {\n  const lines = text.split(/\\r?\\n/)\n  const data = []\n  lines.forEach(line => {\n    const [tag, ...fields] = line.split(/\\t/)\n    const parsedFields = fields.map(f => {\n      const [fieldTag, value] = f.split(':', 2)\n      return { tag: fieldTag, value }\n    })\n    if (tag) {\n      data.push({ tag: tag.substr(1), data: parsedFields })\n    }\n  })\n  return data\n}\n","import { unzip } from '../unzip'\nimport crc32 from 'buffer-crc32'\nimport LRU from 'quick-lru'\n\nimport { CramUnimplementedError, CramMalformedError } from '../errors'\nimport ransuncompress from '../rans'\nimport {\n  cramFileDefinition as cramFileDefinitionParser,\n  getSectionParsers,\n} from './sectionParsers'\nimport htscodecs from '@jkbonfield/htscodecs'\nimport CramContainer from './container'\n\nimport { open } from '../io'\nimport { parseItem, tinyMemoize } from './util'\nimport { parseHeaderText } from '../sam'\n\nexport default class CramFile {\n  /**\n   * @param {object} args\n   * @param {object} [args.filehandle] - a filehandle that implements the stat() and\n   * read() methods of the Node filehandle API https://nodejs.org/api/fs.html#fs_class_filehandle\n   * @param {object} [args.path] - path to the cram file\n   * @param {object} [args.url] - url for the cram file.  also supports file:// urls for local files\n   * @param {function} [args.seqFetch] - a function with signature\n   * `(seqId, startCoordinate, endCoordinate)` that returns a promise for a string of sequence bases\n   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000\n   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5\n   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.\n   */\n  constructor(args) {\n    this.file = open(args.url, args.path, args.filehandle)\n    this.validateChecksums = true\n    this.fetchReferenceSequenceCallback = args.seqFetch\n    this.options = {\n      checkSequenceMD5: args.checkSequenceMD5 !== false,\n      cacheSize: args.cacheSize !== undefined ? args.cacheSize : 20000,\n    }\n\n    // cache of features in a slice, keyed by the\n    // slice offset. caches all of the features in a slice, or none.\n    // the cache is actually used by the slice object, it's just\n    // kept here at the level of the file\n    this.featureCache = new LRU({\n      maxSize: this.options.cacheSize,\n    })\n  }\n\n  toString() {\n    if (this.file.filename) {\n      return this.file.filename\n    }\n    if (this.file.url) {\n      return this.file.url\n    }\n\n    return '(cram file)'\n  }\n\n  // can just read this object like a filehandle\n  read(buffer, offset, length, position) {\n    return this.file.read(buffer, offset, length, position)\n  }\n\n  // can just stat this object like a filehandle\n  stat() {\n    return this.file.stat()\n  }\n\n  // memoized\n  async getDefinition() {\n    const headbytes = Buffer.allocUnsafe(cramFileDefinitionParser.maxLength)\n    await this.file.read(headbytes, 0, cramFileDefinitionParser.maxLength, 0)\n    const definition = cramFileDefinitionParser.parser.parse(headbytes).result\n    if (definition.majorVersion !== 2 && definition.majorVersion !== 3) {\n      throw new CramUnimplementedError(\n        `CRAM version ${definition.majorVersion} not supported`,\n      )\n    }\n    return definition\n  }\n\n  // memoize\n  async getSamHeader() {\n    const firstContainer = await this.getContainerById(0)\n    if (!firstContainer) {\n      throw new CramMalformedError('file contains no containers')\n    }\n\n    const { content } = await firstContainer.getFirstBlock()\n    // find the end of the trailing zeros in the header text\n    const headerLength = content.readInt32LE(0)\n    const textStart = 4\n    // let textEnd = content.length - 1\n    // while (textEnd >= textStart && !content[textEnd]) textEnd -= 1\n    // trim off the trailing zeros\n    const text = content.toString('utf8', textStart, textStart + headerLength)\n    this.header = text\n    return parseHeaderText(text)\n  }\n\n  async getHeaderText() {\n    await this.getSamHeader()\n    return this.header\n  }\n\n  // memoize\n  async getSectionParsers() {\n    const { majorVersion } = await this.getDefinition()\n    return getSectionParsers(majorVersion)\n  }\n\n  async getContainerById(containerNumber) {\n    const sectionParsers = await this.getSectionParsers()\n    let position = sectionParsers.cramFileDefinition.maxLength\n    const { size: fileSize } = await this.file.stat()\n    const { cramContainerHeader1 } = sectionParsers\n\n    // skip with a series of reads to the proper container\n    let currentContainer\n    for (let i = 0; i <= containerNumber; i += 1) {\n      // if we are about to go off the end of the file\n      // and have not found that container, it does not exist\n      if (position + cramContainerHeader1.maxLength + 8 >= fileSize) {\n        return undefined\n      }\n\n      currentContainer = this.getContainerAtPosition(position)\n      const currentHeader = await currentContainer.getHeader()\n      if (!currentHeader) {\n        throw new CramMalformedError(\n          `container ${containerNumber} not found in file`,\n        )\n      }\n      // if this is the first container, read all the blocks in the\n      // container to determine its length, because we cannot trust\n      // the container header's given length due to a bug somewhere\n      // in htslib\n      if (i === 0) {\n        position = currentHeader._endPosition\n        for (let j = 0; j < currentHeader.numBlocks; j += 1) {\n          const block = await this.readBlock(position)\n          position = block._endPosition\n        }\n      } else {\n        // otherwise, just traverse to the next container using the container's length\n        position += currentHeader._size + currentHeader.length\n      }\n    }\n\n    return currentContainer\n  }\n\n  async checkCrc32(position, length, recordedCrc32, description) {\n    const b = Buffer.allocUnsafe(length)\n    await this.file.read(b, 0, length, position)\n    const calculatedCrc32 = crc32.unsigned(b)\n    if (calculatedCrc32 !== recordedCrc32) {\n      throw new CramMalformedError(\n        `crc mismatch in ${description}: recorded CRC32 = ${recordedCrc32}, but calculated CRC32 = ${calculatedCrc32}`,\n      )\n    }\n  }\n\n  /**\n   * @returns {Promise[number]} the number of containers in the file\n   */\n  async containerCount() {\n    const sectionParsers = await this.getSectionParsers()\n    const { size: fileSize } = await this.file.stat()\n    const { cramContainerHeader1 } = sectionParsers\n\n    let containerCount = 0\n    let position = sectionParsers.cramFileDefinition.maxLength\n    while (position + cramContainerHeader1.maxLength + 8 < fileSize) {\n      const currentHeader = await this.getContainerAtPosition(\n        position,\n      ).getHeader()\n      if (!currentHeader) {\n        break\n      }\n      // if this is the first container, read all the blocks in the\n      // container, because we cannot trust the container\n      // header's given length due to a bug somewhere in htslib\n      if (containerCount === 0) {\n        position = currentHeader._endPosition\n        for (let j = 0; j < currentHeader.numBlocks; j += 1) {\n          const block = await this.readBlock(position)\n          position = block._endPosition\n        }\n      } else {\n        // otherwise, just traverse to the next container using the container's length\n        position += currentHeader._size + currentHeader.length\n      }\n      containerCount += 1\n    }\n\n    return containerCount\n  }\n\n  getContainerAtPosition(position) {\n    return new CramContainer(this, position)\n  }\n\n  async readBlockHeader(position) {\n    const sectionParsers = await this.getSectionParsers()\n    const { cramBlockHeader } = sectionParsers\n    const { size: fileSize } = await this.file.stat()\n\n    if (position + cramBlockHeader.maxLength >= fileSize) {\n      return undefined\n    }\n\n    const buffer = Buffer.allocUnsafe(cramBlockHeader.maxLength)\n    await this.file.read(buffer, 0, cramBlockHeader.maxLength, position)\n    return parseItem(buffer, cramBlockHeader.parser, 0, position)\n  }\n\n  async _parseSection(\n    section,\n    position,\n    size = section.maxLength,\n    preReadBuffer,\n  ) {\n    let buffer\n    if (preReadBuffer) {\n      buffer = preReadBuffer\n    } else {\n      const { size: fileSize } = await this.file.stat()\n      if (position + size >= fileSize) {\n        return undefined\n      }\n      buffer = Buffer.allocUnsafe(size)\n      await this.file.read(buffer, 0, size, position)\n    }\n    const data = parseItem(buffer, section.parser, 0, position)\n    if (data._size !== size) {\n      throw new CramMalformedError(\n        `section read error: requested size ${size} does not equal parsed size ${data._size}`,\n      )\n    }\n    return data\n  }\n\n  _uncompress(compressionMethod, inputBuffer, outputBuffer) {\n    if (compressionMethod === 'gzip') {\n      const result = unzip(inputBuffer)\n      result.copy(outputBuffer)\n    } else if (compressionMethod === 'bzip2') {\n      var bits = bzip2.array(inputBuffer)\n      var size = bzip2.header(bits)\n      var j = 0\n      do {\n        var chunk = bzip2.decompress(bits, size)\n        if (chunk != -1) {\n          Buffer.from(chunk).copy(outputBuffer, j)\n          j += chunk.length\n          size -= chunk.length\n        }\n      } while (chunk != -1)\n    } else if (compressionMethod === 'rans') {\n      ransuncompress(inputBuffer, outputBuffer)\n      //htscodecs r4x8 is slower, but compatible.\n      //htscodecs.r4x8_uncompress(inputBuffer, outputBuffer);\n    } else if (compressionMethod === 'rans4x16') {\n      htscodecs.r4x16_uncompress(inputBuffer, outputBuffer)\n    } else if (compressionMethod === 'arith') {\n      htscodecs.arith_uncompress(inputBuffer, outputBuffer)\n    } else if (compressionMethod === 'fqzcomp') {\n      htscodecs.fqzcomp_uncompress(inputBuffer, outputBuffer)\n    } else if (compressionMethod === 'tok3') {\n      htscodecs.tok3_uncompress(inputBuffer, outputBuffer)\n    } else {\n      throw new CramUnimplementedError(\n        `${compressionMethod} decompression not yet implemented`,\n      )\n    }\n  }\n\n  async readBlock(position) {\n    const { majorVersion } = await this.getDefinition()\n    const sectionParsers = await this.getSectionParsers()\n    const block = await this.readBlockHeader(position)\n    const blockContentPosition = block._endPosition\n    block.contentPosition = block._endPosition\n\n    const uncompressedData = Buffer.allocUnsafe(block.uncompressedSize)\n\n    if (block.compressionMethod !== 'raw') {\n      const compressedData = Buffer.allocUnsafe(block.compressedSize)\n      await this.read(\n        compressedData,\n        0,\n        block.compressedSize,\n        blockContentPosition,\n      )\n\n      this._uncompress(\n        block.compressionMethod,\n        compressedData,\n        uncompressedData,\n      )\n    } else {\n      await this.read(\n        uncompressedData,\n        0,\n        block.uncompressedSize,\n        blockContentPosition,\n      )\n    }\n\n    block.content = uncompressedData\n\n    if (majorVersion >= 3) {\n      // parse the crc32\n      const crc = await this._parseSection(\n        sectionParsers.cramBlockCrc32,\n        blockContentPosition + block.compressedSize,\n      )\n      block.crc32 = crc.crc32\n\n      // check the block data crc32\n      if (this.validateChecksums) {\n        await this.checkCrc32(\n          position,\n          block._size + block.compressedSize,\n          block.crc32,\n          'block data',\n        )\n      }\n\n      // make the endposition and size reflect the whole block\n      block._endPosition = crc._endPosition\n      block._size =\n        block.compressedSize + sectionParsers.cramBlockCrc32.maxLength\n    } else {\n      block._endPosition = blockContentPosition + block.compressedSize\n      block._size = block.compressedSize\n    }\n\n    return block\n  }\n}\n\n'getDefinition getSectionParsers getSamHeader'\n  .split(' ')\n  .forEach(method => tinyMemoize(CramFile, method))\n","import CramFile from './file'\n\nexport default CramFile\n","import { CramUnimplementedError, CramSizeLimitError } from './errors'\n\nimport CramFile from './cramFile'\n\nexport default class IndexedCramFile {\n  /**\n   *\n   * @param {object} args\n   * @param {CramFile} args.cram\n   * @param {Index-like} args.index object that supports getEntriesForRange(seqId,start,end) -> Promise[Array[index entries]]\n   * @param {number} [args.cacheSize] optional maximum number of CRAM records to cache.  default 20,000\n   * @param {number} [args.fetchSizeLimit] optional maximum number of bytes to fetch in a single getRecordsForRange call.  Default 3 MiB.\n   * @param {boolean} [args.checkSequenceMD5] - default true. if false, disables verifying the MD5\n   * checksum of the reference sequence underlying a slice. In some applications, this check can cause an inconvenient amount (many megabases) of sequences to be fetched.\n   */\n  constructor(args) {\n    // { cram, index, seqFetch /* fasta, fastaIndex */ }) {\n    if (args.cram) {\n      this.cram = args.cram\n    } else {\n      this.cram = new CramFile({\n        url: args.cramUrl,\n        path: args.cramPath,\n        filehandle: args.cramFilehandle,\n        seqFetch: args.seqFetch,\n        checkSequenceMD5: args.checkSequenceMD5,\n        cacheSize: args.cacheSize,\n      })\n    }\n\n    if (!(this.cram instanceof CramFile)) {\n      throw new Error('invalid arguments: no cramfile')\n    }\n\n    this.index = args.index\n    if (!this.index.getEntriesForRange) {\n      throw new Error('invalid arguments: not an index')\n    }\n\n    this.fetchSizeLimit = args.fetchSizeLimit || 3000000\n  }\n\n  /**\n   *\n   * @param {number} seq numeric ID of the reference sequence\n   * @param {number} start start of the range of interest. 1-based closed coordinates.\n   * @param {number} end end of the range of interest. 1-based closed coordinates.\n   * @returns {Promise[Array[CramRecord]]}\n   */\n  async getRecordsForRange(seq, start, end, opts = {}) {\n    opts.viewAsPairs = opts.viewAsPairs || false\n    opts.pairAcrossChr = opts.pairAcrossChr || false\n    opts.maxInsertSize = opts.maxInsertSize || 200000\n\n    if (typeof seq === 'string') {\n      // TODO: support string reference sequence names somehow\n      throw new CramUnimplementedError(\n        'string sequence names not yet supported',\n      )\n    }\n    const seqId = seq\n    const slices = await this.index.getEntriesForRange(seqId, start, end)\n    const totalSize = slices.map(s => s.sliceBytes).reduce((a, b) => a + b, 0)\n    if (totalSize > this.fetchSizeLimit) {\n      throw new CramSizeLimitError(\n        `data size of ${totalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n      )\n    }\n\n    // TODO: do we need to merge or de-duplicate the blocks?\n\n    // fetch all the slices and parse the feature data\n    const filter = feature =>\n      feature.sequenceId === seq &&\n      feature.alignmentStart <= end &&\n      feature.alignmentStart + feature.lengthOnRef - 1 >= start\n    const sliceResults = await Promise.all(\n      slices.map(slice => this.getRecordsInSlice(slice, filter)),\n    )\n\n    let ret = Array.prototype.concat(...sliceResults)\n    if (opts.viewAsPairs) {\n      const readNames = {}\n      const readIds = {}\n      for (let i = 0; i < ret.length; i += 1) {\n        const name = ret[i].readName\n        const id = ret[i].uniqueId\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name] += 1\n        readIds[id] = 1\n      }\n      const unmatedPairs = {}\n      Object.entries(readNames).forEach(([k, v]) => {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      })\n      const matePromises = []\n      for (let i = 0; i < ret.length; i += 1) {\n        const name = ret[i].readName\n        if (\n          unmatedPairs[name] &&\n          ret[i].mate &&\n          (ret[i].mate.sequenceId === seqId || opts.pairAcrossChr) &&\n          Math.abs(ret[i].alignmentStart - ret[i].mate.alignmentStart) <\n            opts.maxInsertSize\n        ) {\n          const mateSlices = this.index.getEntriesForRange(\n            ret[i].mate.sequenceId,\n            ret[i].mate.alignmentStart,\n            ret[i].mate.alignmentStart + 1,\n          )\n          matePromises.push(mateSlices)\n        }\n      }\n      const mateBlocks = await Promise.all(matePromises)\n      let mateChunks = []\n      for (let i = 0; i < mateBlocks.length; i += 1) {\n        mateChunks.push(...mateBlocks[i])\n      }\n      // filter out duplicates\n      mateChunks = mateChunks\n        .sort((a, b) => a.toString().localeCompare(b.toString()))\n        .filter(\n          (item, pos, ary) =>\n            !pos || item.toString() !== ary[pos - 1].toString(),\n        )\n\n      const mateRecordPromises = []\n      const mateFeatPromises = []\n\n      const mateTotalSize = mateChunks\n        .map(s => s.sliceBytes)\n        .reduce((a, b) => a + b, 0)\n      if (mateTotalSize > this.fetchSizeLimit) {\n        throw new Error(\n          `mate data size of ${mateTotalSize.toLocaleString()} bytes exceeded fetch size limit of ${this.fetchSizeLimit.toLocaleString()} bytes`,\n        )\n      }\n\n      mateChunks.forEach(c => {\n        let recordPromise = this.cram.featureCache.get(c.toString())\n        if (!recordPromise) {\n          recordPromise = this.getRecordsInSlice(c, () => true)\n          this.cram.featureCache.set(c.toString(), recordPromise)\n        }\n        mateRecordPromises.push(recordPromise)\n        const featPromise = recordPromise.then(feats => {\n          const mateRecs = []\n          for (let i = 0; i < feats.length; i += 1) {\n            const feature = feats[i]\n            if (unmatedPairs[feature.readName] && !readIds[feature.uniqueId]) {\n              mateRecs.push(feature)\n            }\n          }\n          return mateRecs\n        })\n        mateFeatPromises.push(featPromise)\n      })\n      const newMateFeats = await Promise.all(mateFeatPromises)\n      if (newMateFeats.length) {\n        const newMates = newMateFeats.reduce((result, current) =>\n          result.concat(current),\n        )\n        ret = ret.concat(newMates)\n      }\n    }\n    return ret\n  }\n\n  getRecordsInSlice(\n    { containerStart, sliceStart, sliceBytes },\n    filterFunction,\n  ) {\n    const container = this.cram.getContainerAtPosition(containerStart)\n    const slice = container.getSlice(sliceStart, sliceBytes)\n    return slice.getRecords(filterFunction)\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @returns {Promise} true if the CRAM file contains data for the given\n   * reference sequence numerical ID\n   */\n  hasDataForReferenceSequence(seqId) {\n    return this.index.hasDataForReferenceSequence(seqId)\n  }\n}\n","import AbortablePromiseCache from 'abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\nimport { unzip } from './unzip'\nimport { open } from './io'\nimport { CramMalformedError } from './errors'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nclass Slice {\n  constructor(args) {\n    Object.assign(this, args)\n  }\n\n  toString() {\n    return `${this.start}:${this.span}:${this.containerStart}:${this.sliceStart}:${this.sliceBytes}`\n  }\n}\n\nfunction addRecordToIndex(index, record) {\n  if (record.some(el => el === undefined)) {\n    throw new CramMalformedError('invalid .crai index file')\n  }\n\n  const [seqId, start, span, containerStart, sliceStart, sliceBytes] = record\n\n  if (!index[seqId]) {\n    index[seqId] = []\n  }\n\n  index[seqId].push(\n    new Slice({\n      start,\n      span,\n      containerStart,\n      sliceStart,\n      sliceBytes,\n    }),\n  )\n}\n\nexport default class CraiIndex {\n  // A CRAM index (.crai) is a gzipped tab delimited file containing the following columns:\n  // 1. Sequence id\n  // 2. Alignment start\n  // 3. Alignment span\n  // 4. Container start byte position in the file\n  // 5. Slice start byte position in the container data (‘blocks’)\n  // 6. Slice size in bytes\n  // Each line represents a slice in the CRAM file. Please note that all slices must be listed in index file.\n\n  /**\n   *\n   * @param {object} args\n   * @param {string} [args.path]\n   * @param {string} [args.url]\n   * @param {FileHandle} [args.filehandle]\n   */\n  constructor(args) {\n    const filehandle = open(args.url, args.path, args.filehandle)\n    this._parseCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: 1 }),\n      fill: (data, signal) => this.parseIndex({ signal }),\n    })\n    this.readFile = filehandle.readFile.bind(filehandle)\n  }\n\n  parseIndex() {\n    const index = {}\n    return this.readFile()\n      .then(data => {\n        if (data[0] === 31 && data[1] === 139) {\n          return unzip(data)\n        }\n        return data\n      })\n      .then(uncompressedBuffer => {\n        if (\n          uncompressedBuffer.length > 4 &&\n          uncompressedBuffer.readUInt32LE(0) === BAI_MAGIC\n        ) {\n          throw new CramMalformedError(\n            'invalid .crai index file. note: file appears to be a .bai index. this is technically legal but please open a github issue if you need support',\n          )\n        }\n        // interpret the text as regular ascii, since it is\n        // supposed to be only digits and whitespace characters\n        // this is written in a deliberately low-level fashion for performance,\n        // because some .crai files can be pretty large.\n        let currentRecord = []\n        let currentString = ''\n        for (let i = 0; i < uncompressedBuffer.length; i += 1) {\n          const charCode = uncompressedBuffer[i]\n          if (\n            (charCode >= 48 && charCode <= 57) /* 0-9 */ ||\n            (!currentString && charCode === 45) /* leading - */\n          ) {\n            currentString += String.fromCharCode(charCode)\n          } else if (charCode === 9 /* \\t */) {\n            currentRecord.push(Number.parseInt(currentString, 10))\n            currentString = ''\n          } else if (charCode === 10 /* \\n */) {\n            currentRecord.push(Number.parseInt(currentString, 10))\n            currentString = ''\n            addRecordToIndex(index, currentRecord)\n            currentRecord = []\n          } else if (charCode !== 13 /* \\r */ && charCode !== 32 /* space */) {\n            // if there are other characters in the file besides\n            // space and \\r, something is wrong.\n            throw new CramMalformedError('invalid .crai index file')\n          }\n        }\n\n        // if the file ends without a \\n, we need to flush our buffers\n        if (currentString) {\n          currentRecord.push(Number.parseInt(currentString, 10))\n        }\n        if (currentRecord.length === 6) {\n          addRecordToIndex(index, currentRecord)\n        }\n\n        // sort each of them by start\n        Object.entries(index).forEach(([seqId, ent]) => {\n          index[seqId] = ent.sort(\n            (a, b) => a.start - b.start || a.span - b.span,\n          )\n        })\n        return index\n      })\n  }\n\n  getIndex(opts = {}) {\n    return this._parseCache.get('index', null, opts.signal)\n  }\n\n  /**\n   * @param {number} seqId\n   * @returns {Promise} true if the index contains entries for\n   * the given reference sequence ID, false otherwise\n   */\n  async hasDataForReferenceSequence(seqId) {\n    return !!(await this.getIndex())[seqId]\n  }\n\n  /**\n   * fetch index entries for the given range\n   *\n   * @param {number} seqId\n   * @param {number} queryStart\n   * @param {number} queryEnd\n   *\n   * @returns {Promise} promise for\n   * an array of objects of the form\n   * `{start, span, containerStart, sliceStart, sliceBytes }`\n   */\n  async getEntriesForRange(seqId, queryStart, queryEnd) {\n    const seqEntries = (await this.getIndex())[seqId]\n    if (!seqEntries) {\n      return []\n    }\n\n    const compare = entry => {\n      const entryStart = entry.start\n      const entryEnd = entry.start + entry.span\n      if (entryStart >= queryEnd) {\n        return -1\n      } // entry is ahead of query\n      if (entryEnd <= queryStart) {\n        return 1\n      } // entry is behind query\n      return 0 // entry overlaps query\n    }\n    const bins = []\n    for (let i = 0; i < seqEntries.length; i += 1) {\n      if (compare(seqEntries[i]) === 0) {\n        bins.push(seqEntries[i])\n      }\n    }\n    return bins\n  }\n}\n","'use strict';\n\nclass QuickLRU {\n\tconstructor(options = {}) {\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst value = this.oldCache.get(key);\n\t\t\tthis._set(key, value);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tset(key, value) {\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, value);\n\t\t} else {\n\t\t\tthis._set(key, value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\treturn this.cache.has(key) || this.oldCache.has(key);\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this.oldCache.get(key);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tyield item;\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget size() {\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn this._size + oldCacheSize;\n\t}\n}\n\nmodule.exports = QuickLRU;\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst RangeCoder = require(\"./arith_sh\");\nconst IOStream = require(\"./iostream\");\nconst ByteModel = require(\"./byte_model\");\nconst bzip2 = require(\"bzip2\");\n\nconst ARITH_ORDER  = 1\nconst ARITH_EXT    = 4\nconst ARITH_STRIPE = 8\nconst ARITH_NOSIZE = 16\nconst ARITH_CAT    = 32\nconst ARITH_RLE    = 64\nconst ARITH_PACK   = 128\n\nmodule.exports = class RangeCoderGen {\n    decode(src) {\n\tthis.stream = new IOStream(src);\n\treturn this.decodeStream(this.stream)\n    }\n\n    decodeStream(stream, n_out=0) {\n\tvar flags = this.stream.ReadByte();\n\tif (!(flags & ARITH_NOSIZE))\n\t    n_out = this.stream.ReadUint7();\n\tvar e_len = n_out;\n\n\tvar order = flags & ARITH_ORDER;\n\n\t// 4-way recursion\n\tif (flags & ARITH_STRIPE)\n\t    return this.decodeStripe(this.stream, n_out)\n\n\t// Meta data\n\tif (flags & ARITH_PACK) {\n\t    var P\n\t    [P, e_len] = this.decodePackMeta(this.stream)\n\t}\n\n\t// NOP, useful for tiny blocks\n\tif (flags & ARITH_CAT)\n\t    var data = this.decodeCat(this.stream, e_len)\n\n\t// Entropy decode\n\telse if (flags & ARITH_EXT) {\n\t    var data = this.decodeExt(this.stream, e_len)\n\t} else if (flags & ARITH_RLE) {\n\t    var data = order\n\t\t? this.decodeRLE1(this.stream, e_len)\n\t\t: this.decodeRLE0(this.stream, e_len)\n\t} else {\n\t    var data = order\n\t\t? this.decode1(this.stream, e_len)\n\t\t: this.decode0(this.stream, e_len)\n\t}\n\n\t// Transforms\n\tif (flags & ARITH_PACK)\n\t    data = this.decodePack(data, P, n_out)\n\n\treturn data\n    }\n\n    encode(src, flags) {\n\tthis.stream = new IOStream(\"\", 0, src.length*1.1 + 100); // guestimate worst case!\n\n\tthis.stream.WriteByte(flags);\n\tif (!(flags & ARITH_NOSIZE))\n\t    this.stream.WriteUint7(src.length);\n\n\tif (flags & ARITH_STRIPE)\n\t    return Buffer.concat([this.stream.buf.slice(0, this.stream.pos),\n\t\t\t\t  this.encodeStripe(this.stream, src, flags>>8)])\n\n\tvar order = flags & ARITH_ORDER;\n\tvar e_len = src.length;\n\n\t// step 1: Encode meta-data\n\tvar pack_meta\n\tif (flags & ARITH_PACK)\n\t    [pack_meta, src, e_len] = this.encodePack(src)\n\n\t// step 2: Write any meta data\n\tif (flags & ARITH_PACK)\n\t    this.stream.WriteStream(pack_meta)\n\n\t// step 3: arith encoding below\n\tif (flags & ARITH_RLE) {\n\t    return order\n\t\t? this.encodeRLE1(src, e_len, this.stream)\n\t\t: this.encodeRLE0(src, e_len, this.stream);\n\t} else {\n\t    return order\n\t\t? this.encode1(src, e_len, this.stream)\n\t\t: this.encode0(src, e_len, this.stream);\n\t}\n    }\n\n    //----------------------------------------------------------------------\n    // Order-0 codec\n    decode0(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar byte_model = new ByteModel(max_sym);\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tfor (var i = 0; i < n_out; i++)\n\t    output[i] = byte_model.ModelDecode(stream, rc);\n\n\treturn output;\n    }\n\n    encode0(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!?\n\n\tvar byte_model = new ByteModel(max_sym);\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tfor (var i = 0; i < n_in; i++)\n\t    byte_model.ModelEncode(out, rc, src[i])\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // Order-1 codec\n\n    decode1(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar byte_model = new Array(max_sym);\n\tfor (var i = 0; i < max_sym; i++)\n\t    byte_model[i] = new ByteModel(max_sym);\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tvar last = 0;\n\tfor (var i = 0; i < n_out; i++) {\n\t    output[i] = byte_model[last].ModelDecode(stream, rc);\n\t    last = output[i];\n\t}\n\n\treturn output;\n    }\n\n    encode1(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!\n\n\tvar byte_model = new Array(max_sym);\n\tfor (var i = 0; i < max_sym; i++)\n\t    byte_model[i] = new ByteModel(max_sym);\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tvar last = 0;\n\tfor (var i = 0; i < n_in; i++) {\n\t    byte_model[last].ModelEncode(out, rc, src[i])\n\t    last = src[i]\n\t}\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // External codec\n    decodeExt(stream, n_out) {\n\t// Bzip2 only for now\n\tvar output = new Buffer.allocUnsafe(n_out)\n\tvar bits = bzip2.array(stream.buf.slice(stream.pos))\n\tvar size = bzip2.header(bits)\n\tvar j = 0\n\tdo {\n\t    var chunk = bzip2.decompress(bits, size);\n\t    if (chunk != -1) {\n\t        Buffer.from(chunk).copy(output, j)\n\t        j += chunk.length\n\t\tsize -= chunk.length\n\t    }\n\t} while(chunk != -1);\n\n\treturn output\n    }\n\n    encodeExt(stream, n_out) {\n\t// We cannot compress using Bzip2 now as it's\n\t// absent from bzip2.js, but consider using\n\t// https://github.com/cscott/compressjs\n    }\n\n    //----------------------------------------------------------------------\n    // Order-0 RLE codec\n    decodeRLE0(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar model_lit = new ByteModel(max_sym);\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tvar i = 0;\n\twhile (i < n_out) {\n\t    output[i] = model_lit.ModelDecode(stream, rc)\n\t    var part = model_run[output[i]].ModelDecode(stream, rc)\n\t    var run = part\n\t    var rctx = 256\n\t    while (part == 3) {\n\t\tpart = model_run[rctx].ModelDecode(stream, rc)\n\t\trctx = 257\n\t\trun += part\n\t    }\n\t    for (var j = 1; j <= run; j++)\n\t\toutput[i+j] = output[i]\n\t    i += run+1\n\t}\n\n\treturn output;\n    }\n\n    encodeRLE0(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!\n\n\tvar model_lit = new ByteModel(max_sym);\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tvar i = 0\n\twhile (i < n_in) {\n\t    model_lit.ModelEncode(out, rc, src[i])\n\t    var run = 1\n\t    while (i+run < n_in && src[i+run] == src[i])\n\t\trun++\n\t    run--\n\n\t    var rctx = src[i]\n\t    var last = src[i]\n\t    i += run+1\n\n\t    var part = run >= 3 ? 3 : run\n\t    model_run[rctx].ModelEncode(out, rc, part)\n\t    run -= part\n\t    rctx = 256\n\t    while (part == 3) {\n\t\tpart = run >= 3 ? 3 : run\n\t\tmodel_run[rctx].ModelEncode(out, rc, part)\n\t\trctx = 257\n\t\trun -= part\n\t    }\n\t}\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // Order-1 RLE codec\n\n    decodeRLE1(stream, n_out) {\n\tvar output = new Buffer.allocUnsafe(n_out);\n\n\tvar max_sym = stream.ReadByte()\n\tif (max_sym == 0)\n\t    max_sym = 256\n\n\tvar model_lit = new Array(max_sym);\n\tfor (var i = 0; i < max_sym; i++)\n\t    model_lit[i] = new ByteModel(max_sym);\n\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tvar rc = new RangeCoder(stream);\n\trc.RangeStartDecode(stream);\n\n\tvar last = 0;\n\tvar i = 0;\n\twhile (i < n_out) {\n\t    output[i] = model_lit[last].ModelDecode(stream, rc)\n\t    last = output[i]\n\t    var part = model_run[output[i]].ModelDecode(stream, rc)\n\t    var run = part\n\t    var rctx = 256\n\t    while (part == 3) {\n\t\tpart = model_run[rctx].ModelDecode(stream, rc)\n\t\trctx = 257\n\t\trun += part\n\t    }\n\t    for (var j = 1; j <= run; j++)\n\t\toutput[i+j] = output[i]\n\t    i += run+1\n\t}\n\n\treturn output;\n    }\n\n    encodeRLE1(src, n_in, out) {\n\t// Count the maximum symbol present\n\tvar max_sym = 0;\n\tfor (var i = 0; i < n_in; i++)\n\t    if (max_sym < src[i])\n\t\tmax_sym = src[i]\n\tmax_sym++;  // FIXME not what spec states!\n\n\tvar model_lit = new Array(max_sym)\n\tfor (var i = 0; i < max_sym; i++)\n\t    model_lit[i] = new ByteModel(max_sym);\n\tvar model_run = new Array(258);\n\tfor (var i = 0; i <= 257; i++)\n\t    model_run[i] = new ByteModel(4)\n\n\tout.WriteByte(max_sym);\n\tvar rc = new RangeCoder(out);\n\n\tvar i = 0\n\tvar last = 0\n\twhile (i < n_in) {\n\t    model_lit[last].ModelEncode(out, rc, src[i])\n\t    var run = 1\n\t    while (i+run < n_in && src[i+run] == src[i])\n\t\trun++\n\t    run--\n\n\t    var rctx = src[i]\n\t    last = src[i]\n\t    i += run+1\n\n\t    var part = run >= 3 ? 3 : run\n\t    model_run[rctx].ModelEncode(out, rc, part)\n\t    run -= part\n\t    rctx = 256\n\t    while (part == 3) {\n\t\tpart = run >= 3 ? 3 : run\n\t\tmodel_run[rctx].ModelEncode(out, rc, part)\n\t\trctx = 257\n\t\trun -= part\n\t    }\n\t}\n\trc.RangeFinishEncode(out)\n\n\treturn out.buf.slice(0, out.pos);\n    }\n\n    //----------------------------------------------------------------------\n    // Pack method\n    decodePackMeta(stream) {\n\tthis.nsym  = stream.ReadByte()\n\n\tvar M = new Array(this.nsym);\n\tfor (var i = 0; i < this.nsym; i++)\n\t    M[i] = stream.ReadByte()\n\n\tvar e_len = stream.ReadUint7(); // Could be derived data from nsym and n_out\n\n\treturn [M, e_len]\n    }\n\n    decodePack(data, M, len) {\n\tvar out = new Buffer.allocUnsafe(len);\n\n\tif (this.nsym <= 1) {\n\t    // Constant value\n\t    for (var i = 0; i < len; i++)\n\t\tout[i] = M[0]\n\n\t} else if (this.nsym <= 2) {\n\t    // 1 bit per value\n\t    for (var i = 0, j = 0; i < len; i++) {\n\t\tif (i % 8 == 0)\n\t\t    var v = data[j++]\n\t\tout[i] = M[v & 1]\n\t\tv >>= 1\n\t    }\n\n\t} else if (this.nsym <= 4) {\n\t    // 2 bits per value\n\t    for (var i = 0, j = 0; i < len; i++) {\n\t\tif (i % 4 == 0)\n\t\t    var v = data[j++]\n\t\tout[i] = M[v & 3]\n\t\tv >>= 2\n\t    }\n\n\t} else if (this.nsym <= 16) {\n\t    // 4 bits per value\n\t    for (var i = 0, j = 0; i < len; i++) {\n\t\tif (i % 2 == 0)\n\t\t    var v = data[j++]\n\t\tout[i] = M[v & 15]\n\t\tv >>= 4\n\t    }\n\n\t} else {\n\t    // 8 bits per value: NOP\n\t    return data\n\t}\n\n\treturn out\n    }\n\n    // Compute M array and return meta-data stream\n    packMeta(src) {\n\tvar stream = new IOStream(\"\", 0, 1024)\n\n\t// Count symbols\n\tvar M = new Array(256)\n\tfor (var i = 0; i < src.length; i++)\n\t    M[src[i]] = 1\n\n\t// Write Map\n\tfor (var nsym = 0, i = 0; i < 256; i++)\n\t    if (M[i])\n\t\tM[i] = ++nsym; // map to 1..N\n\tstream.WriteByte(nsym);\n\n\t// FIXME: add check for nsym > 16?\n\t// Or just accept it as an inefficient waste of time.\n\tfor (var i = 0; i < 256; i++) {\n\t    if (M[i]) {\n\t\tstream.WriteByte(i) // adjust to 0..N-1\n\t\tM[i]--;\n\t    }\n\t}\n\n\treturn [stream, M, nsym]\n    }\n\n    encodePack(data) {\n\tvar meta, M, nsym\n\t[meta, M, nsym] = this.packMeta(data)\n\n\tvar len = data.length\n\tvar i = 0;\n\tif (nsym <= 1) {\n\t    // Constant values\n\t    meta.WriteUint7(0)\n\t    return [meta, new Buffer.allocUnsafe(0), 0];\n\t}\n\n\tif (nsym <= 2) {\n\t    // 1 bit per value\n\t    var out = new Buffer.allocUnsafe(Math.floor((len+7)/8));\n\t    for (var i = 0, j = 0; i < (len & ~7); i+=8, j++)\n\t\tout[j] = (M[data[i+0]]<<0)\n\t\t       + (M[data[i+1]]<<1)\n\t\t       + (M[data[i+2]]<<2)\n\t\t       + (M[data[i+3]]<<3)\n\t\t       + (M[data[i+4]]<<4)\n\t\t       + (M[data[i+5]]<<5)\n\t\t       + (M[data[i+6]]<<6)\n\t\t       + (M[data[i+7]]<<7)\n\t    if (i < len) {\n\t\tout[j] = 0;\n\t\tvar v = 0;\n\t\twhile (i < len) {\n\t\t    out[j] |= M[data[i++]]<<v;\n\t\t    v++;\n\t\t}\n\t\tj++;\n\t    }\n\n\t    meta.WriteUint7(j)\n\t    return [meta, out, out.length]\n\t}\n\n\tif (nsym <= 4) {\n\t    // 2 bits per value\n\t    var out = new Buffer.allocUnsafe(Math.floor((len+3)/4));\n\t    for (var i = 0, j = 0; i < (len & ~3); i+=4, j++)\n\t\tout[j] = (M[data[i+0]]<<0)\n\t\t       + (M[data[i+1]]<<2)\n\t\t       + (M[data[i+2]]<<4)\n\t\t       + (M[data[i+3]]<<6)\n\n\t    if (i < len) {\n\t\tout[j] = 0;\n\t\tvar v = 0;\n\t\twhile (i < len) {\n\t\t    out[j] |= M[data[i++]]<<v;\n\t\t    v+=2;\n\t\t}\n\t\tj++;\n\t    }\n\n\t    meta.WriteUint7(j)\n\t    return [meta, out, out.length]\n\t}\n\n\tif (nsym <= 16) {\n\t    // 4 bits per value\n\t    var out = new Buffer.allocUnsafe(Math.floor((len+1)/2));\n\t    for (var i = 0, j = 0; i < (len & ~1); i+=2, j++)\n\t\tout[j] = (M[data[i+0]]<<0)\n\t\t       + (M[data[i+1]]<<4)\n\t    if (i < len)\n\t\tout[j++] = M[data[i++]];\n\n\t    meta.WriteUint7(j)\n\t    return [meta, out, out.length]\n\t}\n\n\t// Otherwise an expensive NOP\n\tmeta.WriteUint7(data.length)\n\treturn [meta, data, data.length]\n    }\n\n    //----------------------------------------------------------------------\n    // STRIPE method\n    encodeStripe(hdr, src, N) {\n    if (N == 0)\n\tN = 4; // old default\n\n\t// Split into multiple streams\n\tvar part = new Array(N)\n\tvar ulen = new Array(N)\n\tfor (var s = 0; s < N; s++) {\n\t    ulen[s] = Math.floor(src.length / N) + ((src.length % N) > s);\n\t    part[s] = new Array(ulen[s])\n\t}\n\n\tfor (var x = 0, i = 0; i < src.length; i+=N, x++) {\n\t    for (var j = 0; j < N; j++)\n\t\tif (x < part[j].length)\n\t\t    part[j][x] = src[i+j]\n\t}\n\n\t// Compress each part\n\tvar comp = new Array(N)\n\tvar total = 0\n\tfor (var s = 0; s < N; s++) {\n\t    // Example: try O0 and O1 and choose best\n\t    var comp0 = this.encode(part[s], 0)\n\t    var comp1 = this.encode(part[s], 1)\n\t    comp[s] = (comp1.length < comp0.length) ? comp1 : comp0\n\t    total += comp[s].length\n\t}\n\n\t// Serialise\n\tvar out = new IOStream(\"\", 0, total+5*N + 1)\n\tout.WriteByte(N)\n\tfor (var s = 0; s < N; s++)\n\t    out.WriteUint7(comp[s].length)\n\n\tfor (var s = 0; s < N; s++)\n\t    out.WriteData(comp[s], comp[s].length)\n\n\treturn out.buf.slice(0, out.buf.pos)\n    }\n\n    decodeStripe(stream, len) {\n\tvar N = stream.ReadByte()\n\t\n\t// Retrieve lengths\n\tvar clen = new Array(N)\n\tvar ulen = new Array(N)\n\tfor (var j = 0; j < N; j++)\n\t    clen[j] = stream.ReadUint7()\n\n\t// Decode streams\n\tvar T = new Array(N);\n\tfor (var j = 0; j < N; j++) {\n\t    ulen[j] = Math.floor(len / N) + ((len % N) > j)\n\t    T[j] = this.decodeStream(stream, ulen[j])\n\t}\n\n\t// Transpose\n\tvar out = new Buffer.allocUnsafe(len)\n\tfor (var j = 0; j < N; j++) {\n\t    for (var i = 0; i < ulen[j]; i++) {\n\t\tout[i*N + j] = T[j][i];\n\t    }\n\t}\n\n\treturn out\n    }\n\n    //----------------------------------------------------------------------\n    // Cat method\n    decodeCat(stream, len) {\n\tvar out = new Buffer.allocUnsafe(len);\n\tfor (var i = 0; i < len; i++)\n\t    out[i] = stream.ReadByte()\n\n\treturn out\n    }\n}\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// An arithmetic coder, based on Eugene Shelwien's reimplementation of\n// Michael Schindler range coder.\n//\n// Order-0 byte stream of ~/scratch/data/q40b\n// C:              3.1s decode  (approx same vs 32-bit and 64-bit)\n// Arith_sh.js     6.7s decode  (32-bit with carries)\n// Arith.js      317.0s decode  (64-bit no carries); int64 crippling it.\n\n//----------------------------------------------------------------------\n// Arithmetic (range) coder\nmodule.exports = class RangeCoder {\n    constructor(src) {\n\tthis.low   = 0;\n\tthis.range = 0xffffffff;\n\tthis.code  = 0;\n\tthis.FFnum = 0;\n\tthis.carry = 0;\n\tthis.cache = 0;\n    }\n\n    RangeStartDecode(src) {\n\tfor (var i = 0; i < 5; i++)\n\t    this.code = (this.code << 8) + src.ReadByte();\n\tthis.code &= 0xffffffff;\n\tthis.code >>>= 0; // force to be +ve int\n    }\n\n    RangeGetFrequency(tot_freq) {\n\tthis.range = Math.floor(this.range / tot_freq);\n\t//return this.code / this.range;\n\treturn Math.floor(this.code / this.range);\n\n\t// Conceptual scenario; return freq only and don't modify range yet\n\t//return Math.floor(this.code / (Math.floor(this.range / tot_freq)));\n    }\n\n    RangeDecode(src, sym_low, sym_freq, tot_freq) {\n\t// Conceptually we divide range here, but in practice we cached it earlier\n\t//this.range = Math.floor(this.range / tot_freq);\n\n\tthis.code  -= sym_low * this.range;\n\tthis.range *= sym_freq;\n\n\twhile (this.range < (1<<24)) {\n\t    this.range *= 256;\n\t    this.code = (this.code*256 + src.ReadByte());\n\t}\n    }\n\n    RangeShiftLow(dst) {\n\t// We know range is < (1<<24) as we got here.  We already have a\n\t// cached copy of 8 bits from low.  Is this correct, or does it need\n\t// fixing?  Possible scenarios.\n\t// 1. Low < 0xff000000 thus low+range < 0xffffffff and cache\n\t//    cannot possibly change.  Output cache and as many ffs as needed.\n\t// 2. We already detected an overflow in RangeEncode, setting carry.\n\t//    In this case output cached byte + 1 and any 00s needed.\n\t// 3. Neither case - range is low but we haven't yet detected if we're\n\t//    XXffffff or XY000000 scenario.  Increase counter for ff/00s.\n\n\tif (this.low < 0xff000000 | this.carry) {\n\t    // cached byte if no overflow, byte+1 otherwise\n\t    dst.WriteByte(this.cache + this.carry);\n\n\t    // Flush any tracked FFs (no carry) or 00s (carry).\n\t    while (this.FFnum) {\n\t\tdst.WriteByte(this.carry-1);\n\t\tthis.FFnum--;\n\t    }\n\n\t    // Take a copy of top byte ready for next flush\n\t    this.cache = this.low >>> 24;\n\t    this.carry = 0;\n\t} else {\n\t    this.FFnum++; // keep track of number of trailing ff/00 bytes to write\n\t}\n\tthis.low <<= 8;\n\tthis.low >>>= 0; // force to be +ve int\n    }\n\n    RangeEncode(dst, sym_low, sym_freq, tot_freq) {\n\tvar old_low = this.low\n\tthis.range  = Math.floor(this.range / tot_freq)\n\tthis.low   += sym_low * this.range;\n\tthis.low >>>= 0; // Truncate to +ve int so we can spot overflow\n\tthis.range *= sym_freq;\n\n\t// \"low + sym*range < old_low\" means we overflow; set carry.\n\t// NB: can this.low < old_low occur twice before range < (1<<24)?\n\t// We claim not, but prove it!\n\tif (this.low < old_low) {\n\t    if (this.carry != 0) console.log(\"ERROR: Multiple carry\")\n\t    this.carry = 1\n\t}\n\n\t// Renormalise if range gets too small\n\twhile (this.range < (1<<24)) {\n\t    this.range *= 256;\n\t    this.RangeShiftLow(dst);\n\t}\n    }\n\n    RangeFinishEncode(dst) {\n\tfor (var i = 0; i < 5; i++)\n\t    this.RangeShiftLow(dst)\n    }\n};\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// An adaptive probability model for encoding and decoding of symbols\n// within a given alphabet, using the range coder to get/put the\n// compressed data.\n\nconst MAX_FREQ = ((1<<16)-17)\nconst STEP     = 16\n\nmodule.exports = class ByteModel {\n    constructor(max_sym = 256) {\n\tthis.total_freq = max_sym;\n\tthis.max_sym = max_sym-1;\n\tthis.S = new Array\n\tthis.F = new Array\n\n\tfor (var i = 0; i <= this.max_sym; i++) {\n\t    this.S[i] = i;\n\t    this.F[i] = 1;\n\t}\n    }\n\n    ModelDecode(src, rc) {\n\t// Find symbol\n\tvar freq = rc.RangeGetFrequency(this.total_freq);\n\n\t// Linear scan to find cumulative frequency 'freq'\n\tvar acc = 0;\n\tvar x = 0;\n\twhile (acc + this.F[x] <= freq)\n\t    acc += this.F[x++];\n\n//\tfor (var acc = 0; (acc += this.F[x]) <= freq; x++)\n//\t    ;\n//\tacc -= this.F[x];\n\n\t// Update range coder\n\trc.RangeDecode(src, acc, this.F[x], this.total_freq);\n\n\t// Update model\n\tthis.F[x]       += STEP;\n\tthis.total_freq += STEP;\n\tif (this.total_freq > MAX_FREQ)\n\t    this.ModelRenormalise();\n\t\n\n\t// Keep symbols approximately frequency sorted\n\tvar sym = this.S[x];\n\tif (x > 0 && this.F[x] > this.F[x-1]) {\n\t    var tmp = this.F[x];\n\t    this.F[x] = this.F[x-1];\n\t    this.F[x-1] = tmp;\n\n\t    tmp = this.S[x];\n\t    this.S[x] = this.S[x-1];\n\t    this.S[x-1] = tmp;\n\t}\n\n\treturn sym;\n    }\n\n    ModelRenormalise() {\n\t// Halve all the frequencies, being careful not to hit zero\n\tthis.total_freq = 0;\n\tfor (var i = 0; i <= this.max_sym; i++) {\n\t    this.F[i] -= Math.floor(this.F[i] / 2);\n\t    this.total_freq += this.F[i];\n\t}\n    }\n\n    ModelEncode(dst, rc, sym) {\n\t// Find cumulative frequency\n\tvar acc = 0;\n\tfor (var x = 0; this.S[x] != sym; x++)\n\t    acc += this.F[x];\n\n\t// Encode\n\trc.RangeEncode(dst, acc, this.F[x], this.total_freq);\n\n\t// Update model\n\tthis.F[x]       += STEP;\n\tthis.total_freq += STEP;\n\tif (this.total_freq > MAX_FREQ) // FIXME x2\n\t    this.ModelRenormalise();\n\n\t// Keep symbols approximately frequency sorted\n\tvar sym = this.S[x];\n\tif (x > 0 && this.F[x] > this.F[x-1]) {\n\t    var tmp = this.F[x];\n\t    this.F[x] = this.F[x-1];\n\t    this.F[x-1] = tmp;\n\n\t    tmp = this.S[x];\n\t    this.S[x] = this.S[x-1];\n\t    this.S[x-1] = tmp;\n\t}\n    }\n};\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst IOStream = require(\"./iostream\");\nconst ByteModel = require(\"./byte_model\");\nconst RangeCoder = require(\"./arith_sh\");\n\n\n//----------------------------------------------------------------------\n// Main arithmetic entry function: decodes a compressed src and\n// returns the uncompressed buffer.\n\nfunction read_array(src, tab, size) {\n    var j = 0; // array value\n    var z = 0; // array index: tab[j]\n    var last = -1;\n\n    // Remove first level of run-length encoding\n    var R = new Array(1024) // runs\n    while (z < size) {\n\tvar run = src.ReadByte()\n\tR[j++] = run\n\tz += run\n\n\tif (run == last) {\n\t    var copy = src.ReadByte()\n\t    z += run * copy\n\t    while (copy--)\n\t\tR[j++] = run\n\t}\n\tlast = run\n    }\n\n    // Now expand runs in R to tab, noting 255 is max run\n    var i = 0\n    j = 0\n    z = 0\n    while (z < size) {\n\tvar run_len = 0\n\tdo {\n\t    var part = R[j++]\n\t    run_len += part\n\t} while (part == 255)\n\t\n\twhile (run_len--)\n\t    tab[z++] = i;\n\ti++\n    }\n}\n\nconst QMAX = 256\n\nconst FLAG_DEDUP  = 2\nconst FLAG_FLEN   = 4\nconst FLAG_SEL    = 8    // whether selector is used in context\nconst FLAG_QMAP   = 16\nconst FLAG_PTAB   = 32\nconst FLAG_DTAB   = 64\nconst FLAG_QTAB   = 128\n\nconst GFLAG_MULTI_PARAM = 1\nconst GFLAG_HAVE_STAB   = 2\nconst GFLAG_DO_REV      = 4\n\n// Compute a new context from our current state and qual q\nfunction fqz_update_ctx(params, state, q) {\n    var last = params.context\n    state.qctx = ((state.qctx << params.qshift) + params.qtab[q]); // >>> 0\n    last += ((state.qctx & ((1<<params.qbits)-1)) << params.qloc); // >>> 0\n\n    if (params.do_pos)\n\tlast += params.ptab[Math.min(state.p, 1023)] << params.ploc\n\n    if (params.do_delta) {\n\tlast += params.dtab[Math.min(state.delta, 255)] << params.dloc\n\t// Is it better to use q here or qtab[q]?\n\t// If qtab[q] we can map eg [a-z0-9A-Z]->0 ,->1 and have\n\t// delta being a token number count into comma separated lists?\n\tstate.delta += (state.prevq != q) ? 1 : 0\n\tstate.prevq = q\n    }\n\n    if (params.do_sel)\n\tlast += state.s << params.sloc\n\n    state.p--\n\n    return last & 0xffff\n}\n\nfunction decode_fqz_single_param(src) {\n    var p = {} // params\n    \n    // Load FQZ parameters\n    p.context = src.ReadUint16()\n    p.pflags  = src.ReadByte()\n\n    p.do_dedup  = p.pflags & FLAG_DEDUP\n    p.fixed_len = p.pflags & FLAG_FLEN\n    p.do_sel    = p.pflags & FLAG_SEL\n    p.do_qmap   = p.pflags & FLAG_QMAP\n    p.do_pos    = p.pflags & FLAG_PTAB\n    p.do_delta  = p.pflags & FLAG_DTAB\n    p.do_qtab   = p.pflags & FLAG_QTAB\n\n    p.max_sym = src.ReadByte()\n\n    var x = src.ReadByte()\n    p.qbits  = x>>4\n    p.qshift = x&15\n    x = src.ReadByte()\n    p.qloc = x>>4\n    p.sloc = x&15\n    x = src.ReadByte()\n    p.ploc = x>>4\n    p.dloc = x&15\n\n    // Qual map, eg to \"unbin\" Illumina qualities\n    p.qmap = new Array(256);\n    if (p.pflags & FLAG_QMAP) {\n\tfor (var i = 0; i < p.max_sym; i++)\n\t    p.qmap[i] = src.ReadByte()\n    } else {\n\t// Useful optimisation to speed up main loop\n\tfor (var i = 0; i < 256; i++)\n\t    p.qmap[i] = i;  // NOP\n    }\n\n    // Read tables\n    p.qtab = new Array(1024);\n    if (p.qbits > 0 && (p.pflags & FLAG_QTAB)) {\n\tread_array(src, p.qtab, 256)\n    } else {\n\t// Useful optimisation to speed up main loop\n\tfor (var i = 0; i < 256; i++)\n\t    p.qtab[i] = i;  // NOP\n    }\n\n    p.ptab = new Array(1024);\n    if (p.pflags & FLAG_PTAB)\n\tread_array(src, p.ptab, 1024);\n\n    p.dtab = new Array(256);\n    if (p.pflags & FLAG_DTAB)\n\tread_array(src, p.dtab, 256);\n\n    return p\n}\n\nfunction decode_fqz_params(src) {\n    var gparams = {\n\tmax_sym: 0\n    }\n\n    // Check fqz format version\n    var vers = src.ReadByte()\n    if (vers != 5) {\n\tconsole.error(\"Invalid FQZComp version number\");\n\treturn;\n    }\n\n    var gflags = src.ReadByte()\n    var nparam = (gflags & GFLAG_MULTI_PARAM) ? src.ReadByte() : 1\n    var max_sel = gflags.nparam > 1 ? gflags.nparam-1 : 0 // Note max_sel, not num_sel\n\n    var stab = new Array(256);\n    if (gflags & GFLAG_HAVE_STAB) {\n\tmax_sel = src.ReadByte()\n\tread_array(src, stab, 256);\n    } else {\n\tfor (var i = 0; i < nparam; i++)\n\t    stab[i] = i;\n\tfor (; i < 256; i++)\n\t    stab[i] = nparam-1;\n    }\n    gparams.do_rev = (gflags & GFLAG_DO_REV)\n    gparams.stab = stab\n    gparams.max_sel = max_sel\n\n    gparams.params = new Array(gparams.nparam)\n    for (var p = 0; p < nparam; p++) {\n\tgparams.params[p] = decode_fqz_single_param(src)\n\tif (gparams.max_sym < gparams.params[p].max_sym)\n\t    gparams.max_sym = gparams.params[p].max_sym\n    }\n\n    return gparams\n}\n\nfunction fqz_create_models(gparams) {\n    var model = {}\n\n    model.qual = new Array(1<<16)\n    for (var i = 0; i < (1<<16); i++)\n\tmodel.qual[i] = new ByteModel(gparams.max_sym+1) // +1 as max value not num. values\n\n    model.len = new Array(4)\n    for (var i = 0; i < 4; i++)\n\tmodel.len[i] = new ByteModel(256)\n\n    model.rev   = new ByteModel(2)\n    model.dup   = new ByteModel(2)\n\n    if (gparams.max_sel > 0)\n\tmodel.sel = new ByteModel(gparams.max_sel+1) // +1 as max value not num. values\n\n    return model\n}\n\n// Initialise a new record, updating state.\n// Returns 1 if dup, otherwise 0\nfunction decode_fqz_new_record(src, rc, gparams, model, state, rev) {\n    // Parameter selector\n    if (gparams.max_sel > 0) {\n\tstate.s = model.sel.ModelDecode(src, rc)\n    } else {\n\tstate.s = 0;\n    }\n    state.x = gparams.stab[state.s]\n\n    var params = gparams.params[state.x]\n\n    // Reset contexts at the start of each new record\n    if (params.fixed_len >= 0) {\n\t// Not fixed or fixed but first record\n\tvar len = model.len[0].ModelDecode(src, rc)\n\tlen |= model.len[1].ModelDecode(src, rc) << 8\n\tlen |= model.len[2].ModelDecode(src, rc) << 16\n\tlen |= model.len[3].ModelDecode(src, rc) << 24\n\tif (params.fixed_len > 0)\n\t    params.fixed_len = -len\n    } else {\n\tlen = -params.fixed_len\n    }\n    state.len = len\n\n    if (gparams.do_rev)\n\trev[state.rec] = model.rev.ModelDecode(src, rc)\n\n    state.is_dup = 0\n    if (params.pflags & FLAG_DEDUP) {\n\tif (model.dup.ModelDecode(src, rc))\n\t    state.is_dup = 1\n    }\n\n    state.p = len;  // number of remaining bytes in this record\n    state.delta = 0\n    state.qctx = 0\n    state.prevq = 0\n    state.rec++\n}\n\nfunction decode_fqz(src, q_lens) {\n    // Decode parameter block\n    var n_out = src.ReadUint7()\n    var gparams = decode_fqz_params(src)\n    if (!gparams) return\n    var params = gparams.params\n    var rev = new Array(q_lens.length)\n\n    // Create initial models\n    var model = fqz_create_models(gparams)\n\n    // Create our entropy encoder and output buffers\n    var rc = new RangeCoder(src)\n    rc.RangeStartDecode(src)\n    var output = new Buffer.allocUnsafe(n_out)\n\n    // Internal FQZ state\n    var state = {\n\tqctx:0,   // Qual-only sub-context\n\tprevq:0,  // Previous quality value\n\tdelta:0,  // Running delta (q vs prevq)\n\tp:0,      // Number of bases left in current record\n\ts:0,      // Current parameter selector value (0 if unused)\n\tx:0,      // \"stab\" tabulated copy of s\n\tlen:0,    // Length of current string\n\tis_dup:0, // This string is a duplicate of last\n\trec:0     // Record number\n    }\n\n    // The main decode loop itself\n    var i = 0     // position in output buffer\n    while (i < n_out) {\n\tif (state.p == 0) {\n\t    decode_fqz_new_record(src, rc, gparams, model, state, rev)\n\t    if (state.is_dup > 0) {\n\t\tif (model.dup.ModelDecode(src, rc)) {\n\t\t    // Duplicate of last line\n\t\t    for (var x = 0; x < len; x++)\n\t\t\toutput[i+x] = output[i+x-state.len]\n\t\t    i += state.len\n\t\t    state.p = 0\n\t\t    continue\n\t\t}\n\t    }\n\t    q_lens.push(state.len)\n\n\t    var params = gparams.params[state.x]\n\t    var last = params.context\n\t}\n\n\t// Decode the current quality (possibly mapped via qmap)\n\tvar Q = model.qual[last].ModelDecode(src, rc)\n\n\t//if (params.do_qmap)\n\t//    output[i++] = params.qmap[Q];\n\t//else\n\t//    output[i++] = Q\n\toutput[i++] = params.qmap[Q]; // optimised version of above\n\tlast = fqz_update_ctx(params, state, Q)\n    }\n\n    if (gparams.do_rev)\n\treverse_qualities(output, n_out, rev, q_lens)\n\n    return output;\n}\n\nfunction reverse_qualities(qual, qual_len, rev, len) {\n    var rec = 0\n    var i = 0\n    while (i < qual_len) {\n\tif (rev[rec]) {\n\t    var j = 0\n\t    var k = len[rec]-1\n\t    while (j < k) {\n\t\tvar tmp   = qual[i+j]\n\t\tqual[i+j] = qual[i+k]\n\t\tqual[i+k] = tmp\n\t\tj++\n\t\tk--\n\t    }\n\t}\n\n\ti += len[rec++];\n    }\n}\n\nfunction decode(src, q_lens) {\n    var stream = new IOStream(src);\n\n    //var n_out = stream.ReadUint32(); stream.ReadUint32(); // move to main\n\n    return decode_fqz(stream, q_lens);\n}\n    \n//----------------------------------------------------------------------\n// FQZComp encoder.\n\nfunction pick_fqz_params(src, q_lens, q_dirs, qhist) {\n    // Find cardinality of q_dirs\n    var qd_last = q_dirs[0];\n    for (var i = 0; i < q_dirs.length; i++)\n\tif (q_dirs[i] != qd_last)\n\t    break;\n    var qd_fixed = (i == q_dirs.length) ? 1 : 0\n\n    // Scan input to find number of symbols and max symbol\n    var nsym = 0\n    var max_sym = 0\n\n    // selector == 0: Assume one single input dataset\n    for (var i = 0; i < 256; i++)\n\tqhist[0][i] = 0;\n\n    var rec = 0;\n    var len = 0\n    for (var i = 0; i < src.length; i++) {\n\tif (len == 0) {\n\t    len = q_lens[rec < q_lens.length-1 ? rec++ : rec]\n\t}\n\tqhist[0][src[i]]++;\n\tlen--;\n    }\n    for (var i = 0; i < 256; i++) {\n\tif (!qhist[0][i])\n\t    continue;\n\tif (max_sym < i)\n\t    max_sym = i;\n\tnsym++;\n    }\n\n    var qshift = 5\n    var do_qmap = 0\n    // Reduced symbol frequencies implies lower qshift and\n    // a lookup table to go from qual to Q\n    if (nsym <= 16) {\n\tdo_qmap = 1 // based on qhist\n\tif (nsym <= 2)\n\t    qshift = 1\n\telse if (nsym <= 4)\n\t    qshift = 2\n\telse if (nsym <= 8)\n\t    qshift = 3\n\telse\n\t    qshift = 4\n    }\n\n//    // Two params and a 1-bit selector.\n//    // This is 1% overhead vs two data sets compressed independently.\n//    // It's 6.9% smaller than compressing both together with 1 param.\n//    if (0) return [{\n//\t// q4\n//\tqbits:     8,\n//\tqshift:    2,\n//\tqloc:      7,\n//\n//\tpbits:     7,\n//\tpshift:    1,\n//\tploc:      0,\n//\n//\tdbits:     0,\n//\tdshift:    0,\n//\tdloc:      0,\n//\n//      sbits:     0,\n//      sloc:      0,\n//\n//\t//sbits:     2,\n//\t//do_stab:   1,\n//\tsbits:     1,\n//\tdo_stab:   0,\n//\tcontext:   (0<<15),\n//\n//\tmax_sym:   36,\n//\tnsym:      4,\n//\n//\tdo_qmap:   1,\n//\tdo_dedup:  0,\n//\tfixed_len: 1,\n//\tdo_sel:  0,\n//\tdo_rev:    0,\n//\tdo_pos:    1,\n//\tdo_delta:  0,\n//\tdo_qtab:   0\n//    }, {\n//\t//q40\n//\tqbits:     9,\n//\tqshift:    5,\n//\tqloc:      7,\n//\n//\tpbits:     7,\n//\tpshift:    0,\n//\tploc:      0,\n//\n//\tdbits:     0,\n//\tdshift:    0,\n//\tdloc:      0,\n//\n//      sbits:     0,\n//      sloc:      0,\n//\n//\t//sbits:     2,\n//\t//do_stab:   1,\n//\tsbits:     1,\n//\tdo_stab:   0,\n//\tcontext:   (1<<15),\n//\n//\tmax_sym:   44,\n//\tnsym:      45,\n//\n//\tdo_qmap:   0,\n//\tdo_dedup:  0,\n//\tfixed_len: 1,\n//\tdo_sel:  0,\n//\tdo_rev:    0,\n//\tdo_pos:    1,\n//\tdo_delta:  0,\n//\tdo_qtab:   0\n//    }]\n\n    return [{qbits:     8+(qshift>4),\n\t     qshift:    qshift,\n\t     qloc:      7,\n\n\t     pbits:     7,\n\t     pshift:    q_lens[0] > 128 ? 1 : 0,\n\t     ploc:      0,\n\n\t     dbits:     qshift>4 ? 0 : 1,\n\t     dshift:    3,\n\t     dloc:      15,\n\n\n\t     // NB: Also useful as a way of embedding sel and doing sel\n\t     // specific contexts. Identical bar context. Eg 0<<15 or 1<<15.\n\t     sbits:     0,\n\t     sloc:      15,\n\t     do_stab:   0,\n\t     context:   (0<<15),\n\n\t     max_sym:   max_sym,\n\t     nsym:      nsym,\n\n\t     do_qmap:   do_qmap,\n\t     do_dedup:  0,\n\t     fixed_len: (q_lens.length == 1) ? 1 : 0,\n\t     do_sel:    0,\n\t     do_rev:    0,\n\t     do_pos:    1,\n\t     do_delta:  (qshift <= 4) ? 1 : 0,\n\t     do_qtab:   0,\n\n\t     // Override above with some attempt at using selectors\n\t     // when the q_dirs are specific and non-fixed.\n\t     qbits:     8+(qshift>4)-(qd_fixed==0),\n\t     sbits:     1,\n\t     sloc:      15-(qshift<=4), // read1 vs read2\n\t     do_stab:   1,\n\t     do_sel:    1,\n\t     \n//\t     // q4+dir: 7245769 with, 7353962 without. 1.5% saving\n//\t     qbits:     6,\n//\t     dbits:     2,\n//\t     dshift:    2,\n//\t     dloc:      13,\n//\t     sbits:     1,\n//\t     sloc:      15,\n//\t     do_stab:   1,\n//\t     do_sel:    1,\n\n\t     // with 20 bits of context, q40 = 31741545\n\t     // qbits 10, dbits 2, pbits 7, sbits 1\n\t    }]\n}\n\nfunction store_array(out, tab, size) {\n    var i = 0; // index into tab\n    var j = 0; // current value in tab[i]\n\n    var tmp1 = new Array(size*2);\n    var sz1 = 0;\n\n    // First level of RLE.  Replace all runs of 'j' values\n    // with run-lengths, including zeros for missing values.\n    // Eg 0 1 2 2 2 3 3 3 4 4 4 5 5 5 5   7 7\n    // to 1 1 3     3     3     4       0 2\n    while (i < size) {\n\t// Length of j^{th} element\n\tvar i_start = i\n\twhile (i < size && tab[i] == j)\n\t    i++;\n\tvar run_len = i - i_start\n\n\t// Encode run length to tmp array\n\tdo {\n\t    var r = Math.min(255, run_len)\n\t    tmp1[sz1++] = r\n\t    run_len -= r\n\t} while (r == 255)\n\tj++;\n    }\n\n    // Second round of RLE on our tmp array, using a different\n    // RLE algorithm.\n    // Eg 1 1    3 3  3 4 0 2\n    // to 1 1 +0 3 3 +1 4 0 2\n    var last = -1\n    var tmp2 = new Array(size*2)\n    var sz2 = 0\n    i = 0  // index into tmp1]\n    // k is used size of tmp1[]\n    while (i < sz1) {\n\tvar curr = tmp1[i++];\n\ttmp2[sz2++] = curr\n\tif (curr == last) {\n\t    var i_start = i;\n\t    while (i < sz1 && tmp1[i] == last && i - i_start < 255)\n\t\ti++;\n\t    tmp2[sz2++] = i - i_start;\n\t} else {\n\t    last = curr\n\t}\n    }\n\n    // Append 2nd RLE, tmp2, to out.\n    out.WriteData(tmp2, sz2)\n}\n\n\t\t\t\t     \n\n// q_lens is an array of quality lengths per record.\n// (If they're all the same, just set one value.)\nfunction encode_fqz_params(out, params, qhist, qtab, ptab, dtab, stab) {\n    var dsqr = [\n        0, 1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3,\n        4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5,\n        5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,\n        6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7\n    ]\n\n    for (var i = 0; i < params.length; i++)\n\tstab[i] = i; // 1 parameter set per selector value\n    for (; i < 256; i++)\n\tstab[i] = params.length-1;\n\n    // Store global meta-data\n    out.WriteByte(5);            // FQZ format number\n    var gflags = ((params.length > 1) ? GFLAG_MULTI_PARAM : 0)\n\t       | ((params[0].do_stab) ? GFLAG_HAVE_STAB   : 0)\n    out.WriteByte(gflags)\n\n    if (gflags & GFLAG_MULTI_PARAM)\n\tout.WriteByte(params.length) // Number of parameter blocks.\n\n    if (gflags & GFLAG_HAVE_STAB) {\n\tvar max_sel = 1<<params[0].sbits;\n\tif (max_sel > 0) max_sel--;\n\tout.WriteByte(max_sel)\n\tstore_array(out, stab, 256)\n    }\n\n    // Store per-param meta-data\n    for (var p = 0; p < params.length; p++) {\n\tout.WriteUint16(params[p].context)\n\tout.WriteByte((params[p].do_qtab  ? FLAG_QTAB  : 0) |  // FLAG\n\t\t      (params[p].do_delta ? FLAG_DTAB  : 0) |\n\t\t      (params[p].do_pos   ? FLAG_PTAB  : 0) |\n\t\t      (params[p].do_qmap  ? FLAG_QMAP  : 0) |\n\t\t      (params[p].do_sel   ? FLAG_SEL   : 0) |\n\t\t      (params[p].fixed_len? FLAG_FLEN  : 0) |\n\t\t      (params[p].do_dedup ? FLAG_DEDUP : 0))\n\tif (params[p].do_qmap)\n\t    out.WriteByte(params[p].nsym)\n\telse\n\t    out.WriteByte(params[p].max_sym)\n\tout.WriteByte((params[p].qbits << 4) | (params[p].qshift))\n\tout.WriteByte((params[p].qloc  << 4) | (params[p].sloc))\n\tout.WriteByte((params[p].ploc  << 4) | (params[p].dloc))\n\n\tif (params[p].do_qmap) {\n\t    params[p].max_sym = params[p].nsym\n\t    var n = 0;\n\t    for (var i = 0; i < 256; i++) {\n\t\tif (qhist[p][i]) {\n\t\t    out.WriteByte(i)\n\t\t    qhist[p][i] = n++;\n\t\t}\n\t    }\n\t    // Ensure we have all matched input params\n\t    for (; n < params[p].nsym; n++)\n\t\tout.WriteByte(0)\n\t} else {\n\t    //params[p].nsym = 255;\n\t    for (var i = 0; i < 256; i++)\n\t\tqhist[p][i] = i; // NOP\n\t}\n\n\tif (params[p].qbits > 0) {\n\t    //\t// Eg map 0-44 to a smaller range, to improve context usage.\n\t    //\t// Makes q40 test set go from 33596471 to 33450075 (-0.4%)\n\t    //\tparams[p].do_qtab = 1;\n\t    //\tfor (var j = i = 0; i < params[p].max_sym; i++) {\n\t    //\t    qtab[i]=j;\n\t    //\t    if ((i%3)!=0 | i >= 28) j++\n\t    //\t    console.log(\"qtab[\",i,\"]=\",qtab[i]);\n\t    //\t}\n\t    //\tfor (; i < 256; i++)\n\t    //\t    qtab[i] = qtab[params[p].max_sym-1]\n\n\t    for (var i = 0; i < 256; i++)\n\t\tqtab[p][i] = i; // NOP for now\n\n\t    if (params[p].do_qtab)\n\t\tstore_array(out, qtab[p], 256)\n\t}\n\n\tif (params[p].pbits > 0) {\n\t    for (var i = 0; i < 1024; i++)\n\t\tptab[p][i] = Math.min((1<<params[p].pbits)-1, i >> params[p].pshift)\n\n\t    store_array(out, ptab[p], 1024)\n\t}\n\n\tif (params[p].dbits > 0) {\n\t    for (var i = 0; i < 256; i++)\n\t\tif (dsqr[i] > (1<<params[p].dbits) - 1)\n\t\t    dsqr[i] = (1<<params[p].dbits) - 1\n\t    for (var i = 0; i < 256; i++)\n\t\tdtab[p][i] = dsqr[Math.min(dsqr.length-1, i >> params[p].dshift)]\n\n\t    store_array(out, dtab[p], 256)\n\t}\n    }\n\n    return out\n}\n\nfunction encode_fqz(out, src, q_lens, q_dirs, params, qhist, qtab, ptab, dtab, stab) {\n    //console.error(\"0:\",params[0])\n    //console.error(\"1:\",params[1])\n\n    var max_sel = 1<<params[0].sbits\n    if (max_sel > 0) max_sel--\n    var n_in = src.length\n\n    // Create the models\n    var max_sym = 0;\n    for (var p = 0; p < params.length; p++)\n\tif (max_sym < params[p].max_sym)\n\t    max_sym = params[p].max_sym;\n\n    var model_qual = new Array(1<<16)\n    for (var i = 0; i < (1<<16); i++)\n\tmodel_qual[i] = new ByteModel(max_sym+1)\n\n    var model_len = new Array(4)\n    for (var i = 0; i < 4; i++)\n\tmodel_len[i] = new ByteModel(256)\n\n    var model_rev    = new ByteModel(2)\n    var model_dup    = new ByteModel(2)\n    var model_sel    = new ByteModel(max_sel+1)\n\n    // Note: our JavaScript encoder doesn't have a way for reversing\n    // some quality strings, so we ignore do_rev for now.\n    var rc = new RangeCoder(src)\n\n    // The main encoding loop\n    var p = 0; // remaining position along current record\n    var i = 0; // index in src data\n    var rec = 0;\n\n    while (i < n_in) {\n\tif (p == 0) {\n\t    //var s = 0 // single non-mixed sample\n\t    var s = q_dirs[rec]\n\t    if (params[0].sbits > 0) {// FIXME: check All params[].do_stab / sbits must be identical\n\t\t//console.log(\"Ssel\", s)\n\t        model_sel.ModelEncode(out, rc, s)\n\t    }\n\t    var x = stab[s]\n\n\t    // Reset contexts at the statr of each new record\n\t    var len = q_lens[Math.min(q_lens.length-1, rec++)]\n\t    if (params[x].fixed_len) {\n\t\tif (params[x].fixed_len > 0) { // First length\n\t\t    //console.log(\"Len\", len)\n\t\t    model_len[0].ModelEncode(out, rc, len       & 0xff)\n\t\t    model_len[1].ModelEncode(out, rc, (len>>8)  & 0xff)\n\t\t    model_len[2].ModelEncode(out, rc, (len>>16) & 0xff)\n\t\t    model_len[3].ModelEncode(out, rc, (len>>24) & 0xff)\n\t\t    params[x].fixed_len = -1; // indicate we've stored it once\n\t\t}\n\t    } else {\n\t\t//console.log(\"len\", len)\n\t\tmodel_len[0].ModelEncode(out, rc, len       & 0xff)\n\t\tmodel_len[1].ModelEncode(out, rc, (len>>8)  & 0xff)\n\t\tmodel_len[2].ModelEncode(out, rc, (len>>16) & 0xff)\n\t\tmodel_len[3].ModelEncode(out, rc, (len>>24) & 0xff)\n\t    }\n\n\t    if (params[x].do_dedup)\n\t\tprocess.exit(1) // FIXME\n\n\t    p = len\n\t    var delta = 0\n\t    //var last  = 0\n\t    var last  = params[x].context\n\t    var qlast = 0\n\t    var q1    = 0\n\t}\n\n\t// Encode current quality\n\tvar q = src[i++]\n\tvar Q = qhist[x][q]\n\tmodel_qual[last].ModelEncode(out, rc, Q)\n\t//console.log(\"Ctx\",last,qhist[x][q])\n\n\t// Update contexts for next quality\n\tqlast = (qlast << params[x].qshift) + qtab[x][Q]\n\tlast  = params[x].context\n\tlast += (qlast & ((1<<params[x].qbits)-1)) << params[x].qloc\n\n\t// 46.6-48.6 billion cycles with ifs + \"<< params[x].?loc\" shifts\n\t// 47.3-47.3 billion cycles with ifs\n\t// 47.1-47.9 billion cycles without ifs\n\tif (params[x].pbits > 0)\n\t    last += ptab[x][Math.min(p, 1023)] << params[x].ploc\n\n\tif (params[x].dbits > 0) {\n\t    last += dtab[x][Math.min(delta, 255)] << params[x].dloc\n\t    delta += (q1 != Q) ? 1 : 0\n\t    q1 = Q\n\t}\n\n\tif (params[x].do_sel)\n\t    last += s << params[x].sloc\n\n\tlast = (last & 0xffff)\n\tp--\n    }\n\n    rc.RangeFinishEncode(out)\n    return out.buf.slice(0, out.pos)\n}\n\nfunction encode(src, q_lens, q_dirs) {\n    var qhist = new Array(2)\n    var qtab  = new Array(2)\n    var ptab  = new Array(2)\n    var dtab  = new Array(2)\n    var stab  = new Array(256)\n\n    for (var s = 0; s < 2; s++) {\n        qhist[s] = new Array(256)\n        qtab[s]  = new Array(256)\n        ptab[s]  = new Array(1024) \n        dtab[s]  = new Array(256)\n    }\n\n    var out = new IOStream(\"\", 0, src.length*1.1 + 100); // FIXME: guestimate worst case\n\n    out.WriteUint7(src.length);\n    var params = pick_fqz_params(src, q_lens, q_dirs, qhist)\n    var out = encode_fqz_params(out, params, qhist, qtab, ptab, dtab, stab)\n    return encode_fqz(out, src, q_lens, q_dirs, params, qhist, qtab, ptab, dtab, stab)\n}\n\nmodule.exports = { decode, encode }\n","/*\n * Copyright (c) 2020 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// This is an interface to the htscodecs reference implementation of\n// the CRAM 3.1 codecs.\n\n// This JavaScript file is not part of the reference implementation\n// and is simply and interface to get a consistent interface for cram-js.\n\n\"use strict\";\n\nvar r4x8    = require('./rans');\nvar r4x16   = require('./rans4x16');\nvar arith   = require('./arith_gen');\nvar fqzcomp = require('./fqzcomp');\nvar tok3    = require('./tok3');\n\nfunction r4x8_uncompress(inputBuffer, outputBuffer) {\n    r4x8.decode(inputBuffer).copy(outputBuffer, 0, 0);\n}\n\nfunction r4x16_uncompress(inputBuffer, outputBuffer) {\n    r4x16.decode(inputBuffer).copy(outputBuffer, 0, 0);\n}\n\nfunction arith_uncompress(inputBuffer, outputBuffer) {\n    arith.decode(inputBuffer).copy(outputBuffer, 0, 0);\n}\n\nfunction fqzcomp_uncompress(inputBuffer, outputBuffer) {\n    var q_lens = new Array\n    fqzcomp.decode(inputBuffer, q_lens).copy(outputBuffer, 0, 0);\n}\n\nfunction tok3_uncompress(inputBuffer, outputBuffer) {\n    // Returns in string form instead of buffer\n    var out = tok3.decode(inputBuffer, 0, '\\0');\n    Buffer.from(out, 'binary').copy(outputBuffer, 0, 0);\n}\n\nmodule.exports = {\n  r4x8_uncompress:    r4x8_uncompress,\n  r4x16_uncompress:   r4x16_uncompress,\n  arith_uncompress:   arith_uncompress,\n  fqzcomp_uncompress: fqzcomp_uncompress,\n  tok3_uncompress:    tok3_uncompress,\n};\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Turn a buffer into a fake stream with get / put commands.\n// This enables up to closely match the published pseudocode.\nmodule.exports = class IOStream {\n    constructor(buf, start_pos = 0, size = 0) {\n\tif (size != 0) {\n\t    this.buf = Buffer.allocUnsafe(size)\n\t    this.length = size\n\t} else {\n\t    this.buf = buf\n\t    this.length = buf.length\n\t}\n\tthis.pos = start_pos\n    }\n\n    // ----------\n    // Reading\n    EOF() {\n\treturn this.pos >= this.length\n    }\n\n    ReadData(len) {\n\tvar A = this.buf.slice(this.pos, this.pos+len)\n\tthis.pos += len;\n\treturn A\n    }\n\n    ReadByte() {\n\tconst b = this.buf[this.pos]\n\tthis.pos++\n\treturn b\n    }\n\n    ReadChar() {\n\tconst b = this.buf[this.pos]\n\tthis.pos++\n\treturn String.fromCharCode(b)\n    }\n\n    ReadUint16() {\n\tvar i = this.ReadByte()\n\ti |= this.ReadByte()<<8\n\treturn i\n    }\n\n    ReadUint32() {\n\tconst i = this.buf.readInt32LE(this.pos)\n\tthis.pos += 4\n\treturn i\n    }\n\n    // nul terminated string\n    ReadString() {\n\tvar s = \"\"\n\tdo {\n\t    var b = this.buf[this.pos++]\n\t    if (b)\n\t\ts += String.fromCharCode(b)\n\t} while (b)\n\treturn s\n    }\n\n//    ReadUint7() {\n//\t// Variable sized unsigned integers\n//\tvar i = 0;\n//\tvar s = 0;\n//\tdo {\n//\t    var c = this.ReadByte();\n//\t    i = i | ((c & 0x7f)<<s);\n//\t    s += 7;\n//\t} while ((c & 0x80))\n//\n//\treturn i;\n//    }\n\n    ReadUint7() {\n\t// Variable sized unsigned integers\n\tvar i = 0;\n\tdo {\n\t    var c = this.ReadByte();\n\t    i = (i<<7) | (c & 0x7f)\n\t} while ((c & 0x80))\n\n\treturn i;\n    }\n\n    ReadITF8() {\n\tvar i = this.buf[this.pos];\n\tthis.pos++;\n\n\t//process.stderr.write(\"i=\"+i+\"\\n\");\n\n\tif (i >= 0xf0) {\n\t    // 1111xxxx => +4 bytes\n\t    i = (i & 0x0f) << 28;\n\t    i += (this.buf[this.pos+0] << 20)\n\t      +  (this.buf[this.pos+1] << 12)\n\t      +  (this.buf[this.pos+2] <<  4)\n\t      +  (this.buf[this.pos+3] >>  4);\n\t    this.pos += 4;\n\t    //process.stderr.write(\"  4i=\"+i+\"\\n\");\n\t} else if (i >= 0xe0) {\n\t    // 1110xxxx => +3 bytes\n\t    i = (i & 0x0f) << 24;\n\t    i += (this.buf[this.pos+0] << 16)\n\t      +  (this.buf[this.pos+1] <<  8)\n\t      +  (this.buf[this.pos+2] <<  0);\n\t    this.pos += 3;\n\t    //process.stderr.write(\"  3i=\"+i+\"\\n\");\n\t} else if (i >= 0xc0) {\n\t    // 110xxxxx => +2 bytes\n\t    i = (i & 0x1f) << 16;\n\t    i += (this.buf[this.pos+0] << 8)\n\t      +  (this.buf[this.pos+1] << 0);\n\t    this.pos += 2;\n\t    //process.stderr.write(\"  2i=\"+i+\"\\n\");\n\t} else if (i >= 0x80) {\n\t    // 10xxxxxx => +1 bytes\n\t    i = (i & 0x3f) << 8;\n\t    i += this.buf[this.pos];\n\t    this.pos++;;\n\t    //process.stderr.write(\"  1i=\"+i+\"\\n\");\n\t} else {\n\t    // 0xxxxxxx => +0 bytes\n\t}\n\n\treturn i;\n    }\n\n    // ----------\n    // Writing\n    WriteByte(b) {\n\tthis.buf[this.pos++] = b\n    }\n\n    WriteChar(b) {\n\tthis.buf[this.pos++] = b.charCodeAt(0)\n    }\n\n    WriteString(str) {\n\tfor (var i = 0; i < str.length; i++)\n\t    this.buf[this.pos++] = str.charCodeAt(i)\n\tthis.buf[this.pos++] = 0\n    }\n\n    WriteData(buf, len) {\n\tfor (var i = 0; i < len; i++)\n\t    this.buf[this.pos++] = buf[i]\n    }\n\n    WriteStream(stream) {\n\tthis.WriteData(stream.buf, stream.pos)\n    }\n\n    WriteUint16(u) {\n\t//this.buf.writeInt16LE(u, this.pos);\n\tthis.WriteByte(u&0xff)\n\tthis.WriteByte((u>>8)&0xff)\n    }\n\n    WriteUint32(u) {\n\tthis.buf.writeInt32LE(u, this.pos);\n\tthis.pos += 4;\n    }\n\n//    WriteUint7(i) {\n//\tdo {\n//\t    this.WriteByte((i & 0x7f) | ((i > 0x80) << 7));\n//\t    i >>= 7;\n//\t} while (i > 0);\n//    }\n\n    WriteUint7(i) {\n\tvar s = 0;\n\tvar X = i;\n\tdo {\n\t    s += 7;\n\t    X >>= 7;\n\t} while (X > 0);\n\n\tdo {\n\t    s -= 7;\n\t    this.WriteByte(((i >> s) & 0x7f) + ((s > 0) << 7))\n\t} while (s > 0);\n    }\n\n    WriteITF8(i) {\n\t// Horrid, ITF8 is unsigned, but we still write signed into it\n\tif (i < 0)\n\t    i = (1<<32) + i\n\n\tif (i <= 0x0000007f) {\n\t    // 1 byte\n\t    this.buf[this.pos++] = i\n\t} else if (i <= 0x00003fff) {\n\t    // 2 bytes\n\t    this.buf[this.pos++] = 0x80 | Math.floor(i / 256)\n\t    this.buf[this.pos++] = i & 0xff;\n\t} else if (i < 0x0001ffff) {\n\t    // 3 bytes\n\t    this.buf[this.pos++] = 0xc0 | Math.floor(i / 65536)\n\t    this.buf[this.pos++] = Math.floor(i / 256) & 0xff\n\t    this.buf[this.pos++] = i & 0xff;\n\t} else if (i < 0x0fffffff) {\n\t    // 4 bytes\n\t    this.buf[this.pos++] = 0xe0 | Math.floor(i / 16777216)\n\t    this.buf[this.pos++] = Math.floor(i / 65536) & 0xff\n\t    this.buf[this.pos++] = Math.floor(i /   256) & 0xff\n\t    this.buf[this.pos++] = i & 0xff;\n\t} else {\n\t    // 5 bytes; oddly using 4.5 bytes\n\t    this.buf[this.pos++] = 0xf0 | Math.floor(i / 268435456)\n\t    this.buf[this.pos++] = Math.floor(i / 1048576) & 0xff\n\t    this.buf[this.pos++] = Math.floor(i /    4096) & 0xff\n\t    this.buf[this.pos++] = Math.floor(i /       4) & 0xff\n\t    this.buf[this.pos++] = i & 0x0f;\n\t}\n    }\n\n    // ----------\n    // Writing from end of buffer going backwards.\n    // Needed by rANS codec.\n    WriteByteNeg(b) {\n\tthis.buf[--this.pos] = b;\n    }\n};\n","/*\n * Copyright (c) 2019-2020 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst IOStream = require(\"./iostream\");\n\n//----------------------------------------------------------------------\n// rANS primitives itself\n//\n// RansGet* is decoder side\n\nfunction RansGetCumulativeFreq(R) {\n    return R & 0xfff;\n}\n\nfunction RansGetSymbolFromFreq(C, f) {\n    // NOTE: Inefficient.\n    // In practice we would implement this via a precomputed\n    // lookup table C2S[f]; see RansBuildC2S below.\n    var s = 0;\n    while (f >= C[s+1])\n\ts++;\n\n    return s;\n}\n\nfunction RansBuildC2S(C) {\n    var C2S = new Array(0x1000);\n    var s = 0;\n    for (var f = 0; f < 0x1000; f++) {\n\twhile (f >= C[s+1])\n\t    s++;\n\tC2S[f] = s;\n    }\n    return C2S;\n}\n\nfunction RansAdvanceStep(R, c, f) {\n    return f * (R >> 12) + (R & 0xfff) - c;\n}\n\nfunction RansRenorm(src, R) {\n    while (R < (1<<23))\n\tR = (R << 8) + src.ReadByte();\n\n    return R;\n}\n\n\n// RanEnc* is for encoder\nfunction RansEncInit() {\n    return 1<<23;\n}\n\nfunction RansEncFlush(R, dst) {\n    dst.WriteByteNeg((R >> 24) & 0xff);\n    dst.WriteByteNeg((R >> 16) & 0xff);\n    dst.WriteByteNeg((R >>  8) & 0xff);\n    dst.WriteByteNeg((R >>  0) & 0xff);\n}\n\nfunction RansEncRenorm(R, dst, freq, scale_bits) {\n    var R_max = (((1 << 23) >> scale_bits) << 8) * freq;\n\n    while (R >= R_max) {\n\tdst.WriteByteNeg(R & 0xff);\n\tR >>= 8;\n    }\n    return R;\n}\n\n// Puts a symbol with frequency freq, cumulative freq start\n// and total freq 1<<scale_bits.\n//\n// Note with static probabilities, /freq and %freq could be\n// precomputed via multiplies and shifts.\nfunction RansEncPut(R, dst, start, freq, scale_bits) {\n    var scale = 1<<scale_bits;\n    R = RansEncRenorm(R, dst, freq, scale_bits);\n    R = (Math.floor(R / freq) << scale_bits) + (R % freq) + start;\n    return R;\n}\n\n//----------------------------------------------------------------------\n// Main rANS entry function: decodes a compressed src and\n// returns the uncompressed buffer.\nfunction decode(src) {\n    var stream = new IOStream(src);\n    var order = stream.ReadByte();\n    var n_in  = stream.ReadUint32();\n    var n_out = stream.ReadUint32();\n\n    if (order == 0) {\n\treturn RansDecode0(stream, n_out)\n    } else {\n\treturn RansDecode1(stream, n_out)\n    }\n}\n\nfunction encode(src, order) {\n    //var stream = new IOStream(src);\n    //var n_in  = stream.ReadUint32();\n    //var n_out = stream.ReadUint32();\n\n    if (order == 0) {\n\treturn RansEncode0(src)\n    } else {\n\treturn RansEncode1(src)\n    }\n}\n\n//----------------------------------------------------------------------\n// Order-0 decoder\n\n// Decode a single table of order-0 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies0(src, F, C) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    var sym = src.ReadByte();\n    var last_sym = sym;\n    var rle = 0;\n\n    // Read F[]\n    do {\n\tvar f = src.ReadITF8();\n\tF[sym] = f;\n\tif (rle > 0) {\n\t    rle--;\n\t    sym++;\n\t} else {\n\t    sym = src.ReadByte();\n\t    if (sym == last_sym+1)\n\t\trle = src.ReadByte();\n\t}\n\tlast_sym = sym;\n    } while (sym != 0);\n\n    // Compute C[] from F[]\n    C[0] = 0;\n    for (var i = 0; i <= 255; i++)\n\tC[i+1] = C[i] + F[i];\n}\n\nfunction RansDecode0(src, nbytes) {\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies0(src, F, C);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = RansBuildC2S(C);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = src.ReadUint32();\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    for (var i = 0; i < nbytes; i++) {\n\tvar i4 = i%4;\n\tvar f = RansGetCumulativeFreq(R[i4]);\n\tvar s = C2S[f]; // Equiv to RansGetSymbolFromFreq(C, f);\n\n\toutput[i] = s;\n\tR[i4] = RansAdvanceStep(R[i4], C[s], F[s]);\n\tR[i4] = RansRenorm(src, R[i4]);\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-0 encoder\n\nfunction BuildFrequencies0(src, F) {\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    for (var i = 0; i < src.length; i++)\n\tF[src[i]]++;\n}\n\nfunction NormaliseFrequencies0(F) {\n    // Compute total\n    var tot = 0;\n    for (var i = 0; i < 256; i++)\n\ttot += F[i];\n\n    // Scale total of frequencies to max\n    const max = (1<<12);\n    var scale = max / tot;\n    do {\n\tvar max_val = 0;\n\tvar max_idx = 0;\n\tvar renorm = 0;\n\ttot = 0;\n\tfor (var i = 0; i < 256; i++) {\n\t    if (F[i] == 0)\n\t\tcontinue\n\n\t    if (max_val < F[i]) {\n\t\tmax_val = F[i]\n\t\tmax_idx = i\n\t    }\n\n\t    F[i] = Math.floor(F[i] * scale);\n\t    if (F[i] == 0)\n\t\tF[i] = 1;\n\n\t    tot += F[i];\n\t}\n\n\t// Adjust new tot to ensure it matches.\n\tif (tot < max) {\n\t    // Too low, boost the most common symbol\n\t    F[max_idx] += max-tot;\n\t} else if (tot-max < F[max_idx]/2 && F[max_idx] > 2) {\n\t    // Too high, reduce the common symbol\n\t    F[max_idx] -= tot-max;\n\t} else if (tot != max) {\n\t    // Much too high, fudge scale and try again.\n\t    scale = scale * 0.99\n\t    renorm = 1;\n\t}\n    } while (renorm)\n}\n\nfunction WriteFrequencies0(out, F) {\n    var rle = 0;\n    for (var i = 0; i < 256; i++) {\n\tif (!F[i])\n\t    continue\n\n\t// Output Symbol if needed and Frequency\n\tif (rle > 0)\n\t    rle--\n\telse {\n\t    out.WriteByte(i)\n\n\t    if (i > 0 && F[i-1] > 0) {\n\t\t// We've encoded two symbol frequencies in a row.\n\t\t// How many more are there?  Store that count so\n\t\t// we can avoid writing consecutive symbols.\n\t\tfor (rle = i+1; rle<256 && F[rle]; rle++)\n\t\t    ;\n\t\trle -= i+1;\n\n\t\tout.WriteByte(rle);\n\t    }\n\t}\n\n\tout.WriteITF8(F[i])\n    }\n    out.WriteByte(0);\n}\n\nfunction RansEncode0(src) {\n    const nbytes = src.length\n    var output = new IOStream(\"\", 0, 257*3+9);\n\n    output.WriteByte(0);   // Order 0\n    output.WriteUint32(0); // compressed size: correct later\n    output.WriteUint32(0); // uncompressed size: correct later\n\n    // Compute frequencies\n    var F = new Array(256)\n    BuildFrequencies0(src, F)\n    NormaliseFrequencies0(F);\n    WriteFrequencies0(output, F);\n\n    // Compute cumulative frequencies\n    var C = new Array(256)\n    C[0] = 0;\n    for (var i = 1; i < 256; i++)\n\tC[i] = C[i-1] + F[i-1];\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = RansEncInit();\n\n    var alloc = Math.floor(nbytes*1.05+100)\n    var rans_out = new IOStream(\"\", alloc, alloc)\n\n    // Main encode loop\n    for (var i = nbytes-1; i >= 0; i--)\n\tR[i%4] = RansEncPut(R[i%4], rans_out, C[src[i]], F[src[i]], 12);\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    var freq_tab = output.pos\n    output.buf.writeInt32LE(freq_tab-9 + (rans_out.length - rans_out.pos), 1);\n    output.buf.writeInt32LE(nbytes, 5);\n\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\n//----------------------------------------------------------------------\n// Order-1 decoder\n\n// Decode a table of order-1 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies1(src, F, C) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    var sym = src.ReadByte();\n    var last_sym = sym;\n    var rle = 0;\n\n    // Read F[]\n    do {\n\tReadFrequencies0(src, F[sym], C[sym]);\n\n\tif (rle > 0) {\n\t    rle--;\n\t    sym++;\n\t} else {\n\t    sym = src.ReadByte();\n\t    if (sym == last_sym+1)\n\t\trle = src.ReadByte();\n\t}\n\tlast_sym = sym;\n    } while (sym != 0);\n}\n\nfunction RansDecode1(src, nbytes) {\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies1(src, F, C);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = new Array(256);\n    for (var i = 0; i < 256; i++)\n\tC2S[i] = RansBuildC2S(C[i]);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = src.ReadUint32();\n\tL[j] = 0;\n    }\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    var nbytes4 = Math.floor(nbytes/4);\n    for (var i = 0; i < nbytes4; i++) {\n\tfor (var j = 0; j < 4; j++) {\n\t    var f = RansGetCumulativeFreq(R[j]);\n\n\t    //var s = RansGetSymbolFromFreq(C[L[j]], f);\n\t    var s = C2S[L[j]][f]; // Precomputed version of above\n\n\t    output[i+j*nbytes4] = s;\n\t    R[j] = RansAdvanceStep(R[j], C[L[j]][s], F[L[j]][s]);\n\t    R[j] = RansRenorm(src, R[j]);\n\t    L[j] = s;\n\t}\n    }\n\n    // Now deal with the remainder if buffer size is not a multiple of 4,\n    // using rANS state 3 exclusively.  (It'd have been nice to have\n    // designed this to just act as if we kept going with a bail out.)\n    i = 4*i;\n    while (i < nbytes) {\n\tvar f = RansGetCumulativeFreq(R[3]);\n\tvar s = RansGetSymbolFromFreq(C[L[3]], f);\n\toutput[i++] = s;\n\tR[3] = RansAdvanceStep(R[3], C[L[3]][s], F[L[3]][s]);\n\tR[3] = RansRenorm(src, R[3]);\n\tL[3] = s;\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-1 encoder\n\nfunction BuildFrequencies1(src, F, F0) {\n    for (var i = 0; i < 256; i++) {\n\tF0[i] = 0;\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    var last = 0;\n    for (var i = 0; i < src.length; i++) {\n\tF0[src[i]]++;\n\tF[last][src[i]]++;\n\t//F[last][src[i]]++;\n\tlast = src[i];\n    }\n\n    // Also accept we'll be starting at 4 points, not just byte 0\n    F[0][src[1*(src.length >> 2)]]++;\n    F[0][src[2*(src.length >> 2)]]++;\n    F[0][src[3*(src.length >> 2)]]++;\n    F0[0] += 3;\n}\n\nfunction NormaliseFrequencies1(F, F0) {\n    for (var i = 0; i < 256; i++)\n\tif (F0[i])\n\t    NormaliseFrequencies0(F[i])\n}\n\nfunction WriteFrequencies1(out, F, F0) {\n    var rle = 0;\n    var last_sym = 0;\n\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue\n\n\t// Output Symbol if needed and Frequency\n\tif (rle > 0)\n\t    rle--\n\telse {\n\t    out.WriteByte(i)\n\n\t    if (i > 0 && F0[i-1] > 0) {\n\t\tfor (rle = i+1; rle<256 && F0[rle]; rle++)\n\t\t    ;\n\t\trle -= i+1;\n\t\tout.WriteByte(rle);\n\t    }\n\t}\n\n\tWriteFrequencies0(out, F[i]);\n    }\n    out.WriteByte(0);\n}\n\nfunction RansEncode1(src) {\n    const nbytes = src.length;\n    var output = new IOStream(\"\", 0, 257*257*3+9);\n\n    output.WriteByte(1);   // Order 0\n    output.WriteUint32(0); // compressed size: correct later\n    output.WriteUint32(0); // uncompressed size: correct later\n\n    // Compute frequencies\n    var F0 = new Array(256)\n    var F = new Array(256)\n    var C = new Array(256)\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n    }\n\n    BuildFrequencies1(src, F, F0)\n    NormaliseFrequencies1(F, F0);\n    WriteFrequencies1(output, F, F0);\n\n    // Compute cumulative frequencies\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue;\n\n\tC[i][0] = 0;\n\tfor (var j = 1; j < 256; j++)\n\t    C[i][j] = C[i][j-1] + F[i][j-1];\n    }\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = RansEncInit();\n\tL[j] = 0;\n    }\n    var rans_out = new IOStream(\"\", nbytes, nbytes);\n\n    // We have 4 rans codecs running in parallel on its own 1/4tr of buffer\n    var nbytes4 = Math.floor(nbytes/4);\n    var idx = new Array(4);\n    var last = new Array(4)\n    for (var j = 0; j < 4; j++) {\n\tidx[j] = (j+1)*nbytes4 - 2;\n\tlast[j] = src[idx[j]+1]\n    }\n\n    // Deal with the remainder if not a multiple of 4\n    last[3] = src[nbytes-1];\n    for (var i = nbytes-2; i > 4*nbytes4-2; i--) {\n\tR[3] = RansEncPut(R[3], rans_out, C[src[i]][last[3]], F[src[i]][last[3]], 12);\n\tlast[3] = src[i];\n    }\n\n    // Main encode loop\n    while (idx[0] >= 0) {\n\tfor (var j = 3; j >= 0; j--) {\n\t    var s = src[idx[j]]\n\t    R[j] = RansEncPut(R[j], rans_out, C[s][last[j]], F[s][last[j]], 12);\n\t    last[j] = s;\n\t    idx[j]--;\n\t}\n    }\n\n    for (var j = 3; j >= 0; j--) {\n        R[j] = RansEncPut(R[j], rans_out, C[0][last[j]], F[0][last[j]], 12)\n    }\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    var freq_tab = output.pos;\n    output.buf.writeInt32LE(freq_tab-9 + (rans_out.length - rans_out.pos), 1);\n    output.buf.writeInt32LE(nbytes, 5);\n\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\nmodule.exports = { decode, encode }\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\nconst IOStream = require(\"./iostream\");\n\n//----------------------------------------------------------------------\n// rANS primitives itself\n//\n// RansGet* is decoder side\n\nfunction RansGetCumulativeFreq(R, bits) {\n    return R & ((1<<bits)-1)\n}\n\nfunction RansGetSymbolFromFreq(C, f) {\n    // NOTE: Inefficient.\n    // In practice we would implement this via a precomputed\n    // lookup table C2S[f]; see RansBuildC2S below.\n    var s = 0;\n    while (f >= C[s+1])\n\ts++;\n\n    //console.error(f, C, s)\n\n    return s;\n}\n\nfunction RansBuildC2S(C, bits) {\n    var max = 1<<bits\n    var C2S = new Array(max);\n    var s = 0;\n    for (var f = 0; f < max; f++) {\n\twhile (f >= C[s+1])\n\t    s++;\n\tC2S[f] = s;\n    }\n    return C2S;\n}\n\nfunction RansAdvanceStep(R, c, f, bits) {\n    return f * (R >> bits) + (R & ((1<<bits)-1)) - c;\n}\n\nfunction RansRenorm(src, R) {\n    if (R < (1<<15))\n\tR = (R << 16) + src.ReadUint16();\n\n    return R;\n}\n\n\n// RanEnc* is for encoder\nfunction RansEncInit() {\n    return 1<<15;\n}\n\nfunction RansEncFlush(R, dst) {\n    dst.WriteByteNeg((R >> 24) & 0xff);\n    dst.WriteByteNeg((R >> 16) & 0xff);\n    dst.WriteByteNeg((R >>  8) & 0xff);\n    dst.WriteByteNeg((R >>  0) & 0xff);\n}\n\nfunction RansEncRenorm(R, dst, freq, scale_bits) {\n    //var R_max = (((1 << 15) >> scale_bits) << 16) * freq;\n    var R_max = (1 << (31-scale_bits)) * freq\n\n    while (R >= R_max) {\n\tdst.WriteByteNeg((R>>8) & 0xff);\n\tdst.WriteByteNeg(R & 0xff);\n\tR >>= 16;\n    }\n    return R;\n}\n\n// Puts a symbol with frequency freq, cumulative freq start\n// and total freq 1<<scale_bits.\n//\n// Note with static probabilities, /freq and %freq could be\n// precomputed via multiplies and shifts.\nfunction RansEncPut(R, dst, start, freq, scale_bits) {\n    var scale = 1<<scale_bits;\n    R = RansEncRenorm(R, dst, freq, scale_bits);\n    R = (Math.floor(R / freq) << scale_bits) + (R % freq) + start;\n    return R;\n}\n\n\n//----------------------------------------------------------------------\n// Run length encoding\nfunction EncodeRLE(src) {\n    // Step 1: find which symbols benefit from RLE\n    var L = new Array(256)\n    for (var i = 0; i < 256; i++)\n\tL[i] = 0\n\n    var last = -1\n    for (var i = 0; i < src.length; i++) {\n\tL[src[i]] += src[i] == last ? 1 : -1\n\tlast = src[i]\n    }\n\n    var nrle = 0;\n    for (var i = 0; i < 256; i++)\n\tif (L[i] > 0)\n\t    nrle++\n\n    if (!nrle) {\n\t// Format cannot cope with zero RLE symbols, so pick one!\n\tnrle = 1;\n\tL[0] = 1;\n    }\n\n    // Start meta-data as list of symbols to RLE\n    var meta = new IOStream(\"\", 0, nrle+1 + src.length)\n    meta.WriteByte(nrle)\n    for (var i = 0; i < 256; i++)\n\tif (L[i] > 0)\n\t    meta.WriteByte(i)\n\n    // Step 2: Now apply RLE itself\n    var data = new Buffer.allocUnsafe(src.length)\n    var dpos = 0\n    for (var i = 0; i < src.length; i++) {\n\tdata[dpos++] = src[i]\n\tif (L[src[i]] > 0) {\n\t    last = src[i];\n\t    var run = 0;\n\t    while (i+run+1 < src.length && src[i+run+1] == last)\n\t\trun++;\n\t    meta.WriteUint7(run)\n\t    i += run\n\t}\n    }\n\n    // Compress the meta-data\n    var cmeta = RansEncode0(meta.buf.slice(0, meta.pos))\n    var hdr = new IOStream(\"\", 0, 16)\n    hdr.WriteUint7(meta.pos*2)   // Uncompressed meta-data length + compressed-bit-flag(0)\n    hdr.WriteUint7(dpos)         // Length of RLE encoded data\n    hdr.WriteUint7(cmeta.length) // Compressed meta-data length\n    var meta = Buffer.concat([hdr.buf.slice(0,hdr.pos), cmeta])\n\n    return [meta, data.slice(0, dpos)]\n}\n\nfunction DecodeRLEMeta(src) {\n    var u_meta_len = src.ReadUint7()\n    var rle_len = src.ReadUint7()\n\n    // Decode RLE lengths\n    if (u_meta_len & 1) {\n\tvar rle_meta = src.ReadData((u_meta_len-1)/2)\n    } else {\n\tvar comp_meta_len = src.ReadUint7()\n\tvar rle_meta = src.ReadData(comp_meta_len)\n\trle_meta = RansDecode0(new IOStream(rle_meta), u_meta_len/2)\n    }\n\n    // Decode list of symbols for which RLE lengths are applied\n    var rle_meta = new IOStream(rle_meta)\n    var L = new Array(256)\n    var n = rle_meta.ReadByte()\n    if (n == 0)\n\tn = 256;\n    for (var i = 0; i < n; i++)\n\tL[rle_meta.ReadByte()] = 1\n\n    return [L, rle_meta, rle_len]\n}\n\nfunction DecodeRLE(buf, L, rle_meta, len) {\n    var src = new IOStream(buf);\n\n    var out = new Buffer.allocUnsafe(len)\n\n    // Expand up buf+meta to out; i = buf index, j = out index\n    var j = 0;\n    for (var i = 0; j < len; i++) {\n\tvar sym = buf[i];\n\tif (L[sym]) {\n\t    var run = rle_meta.ReadUint7()\n\t    for (var r = 0; r <= run; r++)\n\t\tout[j++] = sym\n\t} else {\n\t    out[j++] = sym\n\t}\n    }\n\n    return out\n}\n\n//----------------------------------------------------------------------\n// Bit packing\n\nfunction EncodePack(src) {\n    // Step 1: identify number of distinct symbols\n    var F = new Array(256)\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0\n\n    for (var i = 0; i < src.length; i++)\n\tF[src[i]]++\n\n    var P = new Array(256)\n    var nsym = 0;\n    for (var i = 0; i < 256; i++)\n\tif (F[i] > 0)\n\t    P[i] = nsym++\n\n    if (nsym > 16) {\n\t//console.error(\"Too many symbols to pack:\",nsym)\n\treturn\n    }\n\n\n    // Pack data\n    if (nsym <= 1) {\n\t// Constant\n\tvar data = new Buffer.allocUnsafe(0)\n    }\n\n    else if (nsym <= 2) {\n\t// 1 bit per value\n\tvar data = new Buffer.allocUnsafe(Math.ceil(src.length/8))\n\tvar j = -1\n\tfor (i = 0; i < src.length; i++) {\n\t    if (i % 8 == 0)\n\t\tdata[++j] = 0\n\t    data[j] += P[src[i]] << (i % 8)\n\t}\n    }\n\n    else if (nsym <= 4) {\n\t// 2 bits per value\n\tvar data = new Buffer.allocUnsafe(Math.ceil(src.length/4))\n\tvar j = -1\n\tfor (i = 0; i < src.length; i++) {\n\t    if (i % 4 == 0)\n\t\tdata[++j] = 0\n\t    data[j] += P[src[i]] << ((i % 4) * 2)\n\t}\n    }\n\n    else {\n\t// 4 bits per value\n\tvar data = new Buffer.allocUnsafe(Math.ceil(src.length/2))\n\tvar j = -1\n\tfor (i = 0; i < src.length; i++) {\n\t    if (i % 2 == 0)\n\t\tdata[++j] = 0\n\t    data[j] += P[src[i]] << ((i % 2) * 4)\n\t}\n    }\n\n\n    // Produce pack meta-data\n    var meta = new IOStream(\"\", 0, nsym+5)\n    meta.WriteByte(nsym)\n    var j = 0\n    for (var i = 0; i < 256; i++) {\n\tif (F[i] > 0) {\n\t    F[i] = j++;\n\t    meta.WriteByte(i)\n\t}\n    }\n    meta.WriteUint7(data.length)\n\n    return [meta.buf.slice(0, meta.pos), data]\n}\n\n\n// Pack meta data is the number and value of distinct symbols plus\n// the length of the packed byte stream.\nfunction DecodePackMeta(src) {\n    var nsym = src.ReadByte()\n    var P = new Array(nsym)\n\n    for (var i = 0; i < nsym; i++)\n\tP[i] = src.ReadByte()\n\n    var len = src.ReadUint7()\n\n    return [P, nsym, len]\n}\n\n// Extract bits from src producing output of length len.\n// Nsym is number of distinct symbols used.\nfunction DecodePack(data, P, nsym, len) {\n    var out = new Buffer.allocUnsafe(len)\n    var j = 0;\n\n    // Constant value\n    if (nsym <= 1) {\n\tfor (var i = 0; i < len; i++)\n\t    out[i] = P[0]\n    }\n\n    // 1 bit per value\n    else if (nsym <= 2) {\n\tfor (i = 0; i < len; i++) {\n\t    if (i % 8 == 0)\n\t\tvar v = data[j++];\n\n\t    out[i] = P[v & 1]\n\t    v >>= 1\n\t}\n    }\n\n    // 2 bits per value\n    else if (nsym <= 4) {\n\tfor (i = 0; i < len; i++) {\n\t    if (i % 4 == 0)\n\t\tvar v = data[j++];\n\n\t    out[i] = P[v & 3]\n\t    v >>= 2\n\t}\n    }\n\n    // 4 bits per value\n    else if (nsym <= 16) {\n\tfor (i = 0; i < len; i++) {\n\t    if (i % 2 == 0)\n\t\tvar v = data[j++];\n\n\t    out[i] = P[v & 15]\n\t    v >>= 4\n\t}\n    }\n\n    return out\n}\n\n\n//----------------------------------------------------------------------\n// 4 way interleaving.\n// This is simply 4 rANS streams interleaved to form bytes 0,4,8...,\n// 1,5,9..., 2,6,10... and 3,7,11...\n//\n// It works well when the distributions differ for each of the 4 bytes,\n// for example when compressing a series of 32-bit integers.\n//\n// Maybe make this more general purpose of X* where we specify the stripe\n// size instead of fixing it at 4?\nfunction RansEncodeStripe(hdr, src, N) {\n    if (N == 0)\n\tN = 4; // old default\n\n    // Split into multiple streams\n    var part = new Array(N)\n    var ulen = new Array(N)\n    for (var s = 0; s < N; s++) {\n\tulen[s] = Math.floor(src.length / N) + ((src.length % N) > s);\n\tpart[s] = new Array(ulen[s])\n    }\n\n    for (var x = 0, i = 0; i < src.length; i+=N, x++) {\n\tfor (var j = 0; j < N; j++)\n\t    if (x < part[j].length)\n\t\tpart[j][x] = src[i+j]\n    }\n\n    // Compress each part\n    var comp = new Array(N)\n    var total = 0\n    for (var s = 0; s < N; s++) {\n\t// Example: try O0 and O1 and choose best\n\tvar comp0 = encode(part[s], 0)\n\tvar comp1 = encode(part[s], 1)\n\tcomp[s] = (comp1.length < comp0.length) ? comp1 : comp0\n\ttotal += comp[s].length\n    }\n\n    // Serialise\n    var out = new IOStream(\"\", 0, total+5*N+1)\n    out.WriteByte(N)\n    for (var s = 0; s < N; s++)\n\tout.WriteUint7(comp[s].length)\n\n    for (var s = 0; s < N; s++)\n\tout.WriteData(comp[s], comp[s].length)\n\n    return out.buf.slice(0, out.buf.pos)\n}\n\nfunction RansDecodeStripe(src, len) {\n    var N = src.ReadByte()\n\n    // Retrieve lengths\n    var clen = new Array(N)\n    var ulen = new Array(N)\n    for (var j = 0; j < N; j++)\n\tclen[j] = src.ReadUint7()\n\n    // Decode streams\n    var T = new Array(N);\n    for (var j = 0; j < N; j++) {\n\tulen[j] = Math.floor(len / N) + ((len % N) > j)\n\tT[j] = RansDecodeStream(src, ulen[j])\n    }\n\n    // Transpose\n    var out = new Buffer.allocUnsafe(len)\n    for (var j = 0; j < N; j++) {\n\tfor (var i = 0; i < ulen[j]; i++) {\n\t    out[i*N + j] = T[j][i];\n\t}\n    }\n\n    return out;\n}\n\n\n//----------------------------------------------------------------------\n// Main rANS entry function: decodes a compressed src and\n// returns the uncompressed buffer.\nfunction decode(src) {\n    var stream = new IOStream(src)\n    return RansDecodeStream(stream, 0)\n}\n\nfunction RansDecodeStream(stream, n_out) {\n    var format = stream.ReadByte();\n    var order  = format & 1\n    var stripe = format & 8\n    var nosz   = format & 16\n    var cat    = format & 32\n    var rle    = format & 64\n    var pack   = format & 128\n\n    if (!nosz)\n\tn_out = stream.ReadUint7();\n\n    // N-way interleaving\n    if (stripe)\n\treturn RansDecodeStripe(stream, n_out)\n\n    // Bit packing\n    if (pack) {\n\tvar pack_len = n_out\n\tvar [P, nsym, n_out] = DecodePackMeta(stream)\n    }\n\n    // Run length encoding\n    if (rle) {\n\tvar rle_len = n_out\n\tvar [L, rle_meta, n_out] = DecodeRLEMeta(stream)\n    }\n\n    // Uncompress data (all, packed or run literals)\n    if (cat)\n\tvar buf = stream.ReadData(n_out)\n    else if (order == 0)\n\tvar buf = RansDecode0(stream, n_out)\n    else\n\tvar buf = RansDecode1(stream, n_out)\n\n    // Apply expansion transforms\n    if (rle)\n\tbuf = DecodeRLE(buf, L, rle_meta, rle_len)\n\n    if (pack)\n\tbuf = DecodePack(buf, P, nsym, pack_len)\n\n    return buf\n}\n\nfunction encode(src, format) {\n    var hdr = new IOStream(\"\", 0, 10);\n    hdr.WriteByte(format);\n\n    var order = format & 1\n    var stripe= format & 8\n    var nosz  = format & 16\n    var cat   = format & 32\n    var rle   = format & 64\n    var pack  = format & 128\n\n    var N     = format>>8\n\n    if (!nosz)\n\thdr.WriteUint7(src.length);\n\n    if (stripe)\n\treturn Buffer.concat([hdr.buf.slice(0, hdr.pos), RansEncodeStripe(hdr, src, N)])\n\n    var pack_meta = new Buffer.alloc(0)\n    if (pack)\n\t[pack_meta, src] = EncodePack(src)\n\n    var rle_meta = new Buffer.alloc(0)\n    if (rle)\n\t[rle_meta, src] = EncodeRLE(src)\n\n    if (src.length < 4 && order == 1) {\n\t// Protect against short order-1 data due to RLE/Pack\n\torder = 0\n\thdr.buf[0] &= ~1\n    }\n\n    if (cat)\n\tvar comp = src\n    else if (order == 0)\n\tvar comp = RansEncode0(src)\n    else\n\tvar comp = RansEncode1(src)\n\n    return Buffer.concat([hdr.buf.slice(0,hdr.pos), pack_meta, rle_meta, comp])\n}\n\n//----------------------------------------------------------------------\n// Order-0 decoder\n\nfunction ReadAlphabet(src) {\n    var A = new Array(256)\n    for (var i = 0; i < 256; i++)\n\tA[i] = 0;\n\n    var rle = 0\n    var sym = src.ReadByte()\n    var last_sym = sym\n\n    do {\n\tA[sym] = 1;\n\tif (rle > 0) {\n\t    rle--\n\t    sym++\n\t} else {\n\t    sym = src.ReadByte()\n\t    if (sym == last_sym+1)\n\t\trle = src.ReadByte()\n\t}\n\tlast_sym = sym\n    } while (sym != 0)\n\n    return A\n}\n\n// Decode a single table of order-0 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies0(src, F, C) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    // Fetch alphabet\n    var A = ReadAlphabet(src);\n\n    // Fetch frequencies for the symbols listed in our alphabet\n    for (var i = 0; i < 256; i++) {\n\tif (A[i] > 0)\n\t    F[i] = src.ReadUint7()\n    }\n\n    NormaliseFrequencies0_Shift(F, 12)\n\n    // Compute C[] from F[]\n    C[0] = 0;\n    for (var i = 0; i <= 255; i++)\n\tC[i+1] = C[i] + F[i];\n}\n\nfunction RansDecode0(src, nbytes) {\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies0(src, F, C);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = RansBuildC2S(C, 12);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = src.ReadUint32();\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    for (var i = 0; i < nbytes; i++) {\n\tvar i4 = i%4;\n\tvar f = RansGetCumulativeFreq(R[i4], 12);\n\tvar s = C2S[f]; // Equiv to RansGetSymbolFromFreq(C, f);\n\n\toutput[i] = s;\n\tR[i4] = RansAdvanceStep(R[i4], C[s], F[s], 12);\n\tR[i4] = RansRenorm(src, R[i4]);\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-0 encoder\n\nfunction BuildFrequencies0(src, F) {\n    for (var i = 0; i < 256; i++)\n\tF[i] = 0;\n\n    for (var i = 0; i < src.length; i++)\n\tF[src[i]]++;\n}\n\nfunction NormaliseFrequencies0(F, bits) {\n    // Compute total\n    var tot = 0;\n    for (var i = 0; i < 256; i++)\n\ttot += F[i];\n\n    // Scale total of frequencies to max\n    const max = (1<<bits);\n    var scale = max / tot;\n    do {\n\tvar max_val = 0;\n\tvar max_idx = 0;\n\tvar renorm = 0;\n\ttot = 0;\n\tfor (var i = 0; i < 256; i++) {\n\t    if (F[i] == 0)\n\t\tcontinue\n\n\t    if (max_val < F[i]) {\n\t\tmax_val = F[i]\n\t\tmax_idx = i\n\t    }\n\n\t    F[i] = Math.floor(F[i] * scale);\n\t    if (F[i] == 0)\n\t\tF[i] = 1;\n\n\t    tot += F[i];\n\t}\n\n\t// Adjust new tot to ensure it matches.\n\tif (tot < max) {\n\t    // Too low, boost the most common symbol\n\t    F[max_idx] += max-tot;\n\t} else if (tot-max < F[max_idx]/2 && F[max_idx] > 2) {\n\t    // Too high, reduce the common symbol\n\t    F[max_idx] -= tot-max;\n\t} else if (tot != max) {\n\t    // Much too high, fudge scale and try again.\n\t    scale = max / tot;\n\t    renorm = 1;\n\t}\n    } while (renorm)\n}\n\nfunction NormaliseFrequencies0_Shift(F, bits) {\n    // Compute total and number of bits to shift by\n    var tot = 0;\n    for (var i = 0; i < 256; i++)\n\ttot += F[i];\n\n    if (tot == 0 || tot == (1<<bits))\n\treturn\n\n    var shift = 0;\n    while (tot < (1<<bits)) {\n\ttot *= 2;\n\tshift++;\n    }\n\n    // Scale total of frequencies to (1<<bits)\n    for (var i = 0; i < 256; i++)\n\tF[i] <<= shift;\n}\n\nfunction WriteAlphabet(out, F) {\n    var rle = 0;\n    for (var i = 0; i < 256; i++) {\n\tif (!F[i])\n\t    continue\n\n\tif (rle > 0)\n\t    rle--\n\telse {\n\t    out.WriteByte(i)\n\n\t    if (i > 0 && F[i-1] > 0) {\n\t\t// We've encoded two symbol frequencies in a row.\n\t\t// How many more are there?  Store that count so\n\t\t// we can avoid writing consecutive symbols.\n\t\tfor (rle = i+1; rle<256 && F[rle]; rle++)\n\t\t    ;\n\t\trle -= i+1;\n\n\t\tout.WriteByte(rle);\n\t    }\n\t}\n    }\n    out.WriteByte(0)\n}\n\nfunction WriteFrequencies0(out, F) {\n    WriteAlphabet(out, F)\n\n    for (var i = 0; i < 256; i++) {\n\tif (F[i])\n\t    out.WriteUint7(F[i])\n    }\n}\n\nfunction RansEncode0(src) {\n    const nbytes = src.length;\n    var output = new IOStream(\"\", 0, 257*3+9);\n\n    // Compute frequencies\n    var F = new Array(256)\n    BuildFrequencies0(src, F)\n    var bit_size = Math.ceil(Math.log2(nbytes));\n    if (bit_size > 12)\n\tbit_size = 12;\n    NormaliseFrequencies0(F, bit_size);\n    WriteFrequencies0(output, F);\n    NormaliseFrequencies0(F, 12);\n\n    // Compute cumulative frequencies\n    var C = new Array(256)\n    C[0] = 0;\n    for (var i = 1; i < 256; i++)\n\tC[i] = C[i-1] + F[i-1];\n\n    // Initialise rANS state\n    var R = new Array(4);\n    for (var i = 0; i < 4; i++)\n\tR[i] = RansEncInit();\n\n    // Allow expansion room if trying to compress random data.\n    var rans_out = new IOStream(\"\", (nbytes*1.05+100)>>0, (nbytes*1.05+100)>>0);\n\n    // Main encode loop\n    for (var i = nbytes-1; i >= 0; i--)\n\tR[i%4] = RansEncPut(R[i%4], rans_out, C[src[i]], F[src[i]], 12);\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    //console.error(\"pos=\",rans_out.pos, \" len=\",rans_out.length)\n    //console.error(rans_out.buf.slice(rans_out.pos, rans_out.length))\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\n//----------------------------------------------------------------------\n// Order-1 decoder\n\n// Decode a table of order-1 frequences,\n// filling out the F and C arrays.\nfunction ReadFrequencies1(src, F, C, shift) {\n    // Initialise; not in the specification - implicit?\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    // Fetch alphabet\n    var A = ReadAlphabet(src);\n\n    // Read F[]\n    for (var i = 0; i < 256; i++) {\n\tif (!A[i])\n\t    continue\n\n\tvar run = 0;\n\tfor (var j = 0; j < 256; j++) {\n\t    if (!A[j])\n\t\tcontinue\n\n\t    if (run > 0) {\n\t\trun--\n\t    } else {\n\t\tF[i][j] = src.ReadUint7();\n\t\tif (F[i][j] == 0)\n\t\t    run = src.ReadByte();\n\t    }\n\t}\n\n\tNormaliseFrequencies0_Shift(F[i], shift)\n\n\t// Compute C[] from F[]\n\tC[i][0] = 0;\n\tfor (var j = 0; j < 256; j++)\n\t    C[i][j+1] = C[i][j] + F[i][j];\n    }\n}\n\nfunction RansDecode1(src, nbytes) {\n    // FIXME: this bit is missing from the RansDecode0 pseudocode.\n\n    var comp = src.ReadByte();\n    var shift = comp >> 4;\n\n    var freq_src = src\n    if (comp & 1) {\n\tvar ulen = src.ReadUint7()\n\tvar clen = src.ReadUint7()\n\tvar comp = new IOStream(src.ReadData(clen))\n\tvar freq_src = new IOStream(RansDecode0(comp, ulen));\n    }\n\n    // Decode frequencies\n    var F = new Array(256);\n    var C = new Array(256);\n    ReadFrequencies1(freq_src, F, C, shift);\n\n    // Fast lookup to avoid slow RansGetSymbolFromFreq\n    var C2S = new Array(256);\n    for (var i = 0; i < 256; i++)\n\t// Could do only for symbols in alphabet?\n\tC2S[i] = RansBuildC2S(C[i], shift);\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = src.ReadUint32();\n\tL[j] = 0;\n    }\n\n    // Main decode loop\n    var output = new Buffer.allocUnsafe(nbytes);\n    var nbytes4 = Math.floor(nbytes/4);\n    for (var i = 0; i < nbytes4; i++) {\n\tfor (var j = 0; j < 4; j++) {\n\t    var f = RansGetCumulativeFreq(R[j], shift);\n\n\t    //var s = RansGetSymbolFromFreq(C[L[j]], f);\n\t    var s = C2S[L[j]][f]; // Precomputed version of above\n\n\t    output[i+j*nbytes4] = s;\n\t    R[j] = RansAdvanceStep(R[j], C[L[j]][s], F[L[j]][s], shift);\n\t    R[j] = RansRenorm(src, R[j]);\n\t    L[j] = s;\n\t}\n    }\n\n    // Now deal with the remainder if buffer size is not a multiple of 4,\n    // using rANS state 3 exclusively.  (It'd have been nice to have\n    // designed this to just act as if we kept going with a bail out.)\n    i = 4*i;\n    while (i < nbytes) {\n\tvar f = RansGetCumulativeFreq(R[3], shift);\n\tvar s = RansGetSymbolFromFreq(C[L[3]], f);\n\toutput[i++] = s;\n\tR[3] = RansAdvanceStep(R[3], C[L[3]][s], F[L[3]][s], shift);\n\tR[3] = RansRenorm(src, R[3]);\n\tL[3] = s;\n    }\n\n    return output;\n}\n\n//----------------------------------------------------------------------\n// Order-1 encoder\n\nfunction BuildFrequencies1(src, F, F0) {\n    for (var i = 0; i < 256; i++) {\n\tF0[i] = 0;\n\tfor (var j = 0; j < 256; j++)\n\t    F[i][j] = 0;\n    }\n\n    var last = 0;\n    for (var i = 0; i < src.length; i++) {\n\tF0[last]++;\n\tF[last][src[i]]++;\n\tlast = src[i];\n    }\n    F0[last]++;\n\n    // Also accept we'll be starting at 4 points, not just byte 0\n    F[0][src[1*(src.length >> 2)]]++;\n    F[0][src[2*(src.length >> 2)]]++;\n    F[0][src[3*(src.length >> 2)]]++;\n    F0[0] += 3;\n}\n\nfunction NormaliseFrequencies1(F, F0, shift) {\n\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue;\n\n\tvar bit_size = Math.ceil(Math.log2(F0[i]));\n\tif (bit_size > shift)\n\t    bit_size = shift;\n\n\tNormaliseFrequencies0(F[i], bit_size)\n    }\n}\n\nfunction NormaliseFrequencies1_Shift(F, F0, shift) {\n    for (var i = 0; i < 256; i++)\n\tif (F0[i])\n\t    NormaliseFrequencies0_Shift(F[i], shift)\n}\n\nfunction WriteFrequencies1(out, F, F0) {\n    WriteAlphabet(out, F0)\n\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue\n\n\tvar run = 0\n\tfor (var j = 0; j < 256; j++) {\n\t    if (!F0[j])\n\t\tcontinue\n\n\t    if (run) {\n\t\trun--\n\t    } else {\n\t\tout.WriteUint7(F[i][j])\n\n\t\tif (!F[i][j]) {\n\t\t    // Count how many more zero-freqs we have\n\t\t    for (var k = j+1; k < 256; k++) {\n\t\t\tif (!F0[k])\n\t\t\t    continue\n\n\t\t\tif (F[i][k] == 0)\n\t\t\t    run++\n\t\t\telse\n\t\t\t    break\n\t\t    }\n\t\t    out.WriteByte(run)\n\t\t}\n\t    }\n\t}\n    }\n}\n\nfunction RansEncode1(src) {\n    const nbytes = src.length;\n    var output = new IOStream(\"\", 0, 257*257*3+9);\n\n    // Compute frequencies\n    var F0 = new Array(256)\n    var F = new Array(256)\n    var C = new Array(256)\n    for (var i = 0; i < 256; i++) {\n\tF[i] = new Array(256);\n\tC[i] = new Array(256);\n    }\n\n    // Frequency precision\n    var shift = 12;\n\n    BuildFrequencies1(src, F, F0)\n    NormaliseFrequencies1(F, F0, shift);\n\n    // Store frequencies, possibly compressed\n    var freq = new IOStream(\"\", 0, 257*257*3+9);\n\n    WriteFrequencies1(freq, F, F0);\n\n    var cfreq = RansEncode0(freq.buf.slice(0, freq.pos))\n    if (cfreq.length < freq.pos) {\n\toutput.WriteByte(1 | (shift<<4));\n\toutput.WriteUint7(freq.pos)\n\toutput.WriteUint7(cfreq.length)\n\toutput.WriteData(cfreq, cfreq.length);\n    } else {\n\toutput.WriteByte(0 | (shift<<4));\n\toutput.WriteData(freq.buf, freq.pos);\n    }\n\n    // Normalise and compute cumulative frequencies\n    NormaliseFrequencies1_Shift(F, F0, shift);\n    for (var i = 0; i < 256; i++) {\n\tif (!F0[i])\n\t    continue;\n\n\tC[i][0] = 0;\n\tfor (var j = 1; j < 256; j++)\n\t    C[i][j] = C[i][j-1] + F[i][j-1];\n    }\n\n    // Initialise rANS state\n    var R = new Array(4);\n    var L = new Array(4);\n    for (var j = 0; j < 4; j++) {\n\tR[j] = RansEncInit();\n\tL[j] = 0;\n    }\n    var rans_out = new IOStream(\"\", (nbytes*1.05+100)>>0, (nbytes*1.05+100)>>0);\n\n    // We have 4 rans codecs running in parallel on its own 1/4tr of buffer\n    var nbytes4 = Math.floor(nbytes/4);\n    var idx = new Array(4);\n    var last = new Array(4)\n    for (var j = 0; j < 4; j++) {\n\tidx[j] = (j+1)*nbytes4 - 2;\n\tlast[j] = src[idx[j]+1]\n    }\n\n    // Deal with the remainder if not a multiple of 4\n    last[3] = src[nbytes-1];\n    for (var i = nbytes-2; i > 4*nbytes4-2; i--) {\n\tR[3] = RansEncPut(R[3], rans_out, C[src[i]][last[3]], F[src[i]][last[3]], shift);\n\tlast[3] = src[i];\n    }\n\n    // Main encode loop\n    while (idx[0] >= 0) {\n\tfor (var j = 3; j >= 0; j--) {\n\t    var s = src[idx[j]]\n\t    R[j] = RansEncPut(R[j], rans_out, C[s][last[j]], F[s][last[j]], shift);\n\t    last[j] = s;\n\t    idx[j]--;\n\t}\n    }\n\n    for (var j = 3; j >= 0; j--) {\n        R[j] = RansEncPut(R[j], rans_out, C[0][last[j]], F[0][last[j]], shift)\n    }\n\n    for (var i = 3; i >= 0; i--)\n\tRansEncFlush(R[i], rans_out);\n\n    // Stitch blocks together into final output buffer\n    return Buffer.concat([output.buf.slice(0, output.pos),\n\t\t\t  rans_out.buf.slice(rans_out.pos, rans_out.length)],\n\t\t\t output.pos + rans_out.length - rans_out.pos);\n}\n\nmodule.exports = { decode, encode }\n","/*\n * Copyright (c) 2019 Genome Research Ltd.\n * Author(s): James Bonfield\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice,\n *       this list of conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above\n *       copyright notice, this list of conditions and the following\n *       disclaimer in the documentation and/or other materials provided\n *       with the distribution.\n *\n *    3. Neither the names Genome Research Ltd and Wellcome Trust Sanger\n *       Institute nor the names of its contributors may be used to endorse\n *       or promote products derived from this software without specific\n *       prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY GENOME RESEARCH LTD AND CONTRIBUTORS \"AS\n * IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GENOME RESEARCH\n * LTD OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n// Name tokeniser\n//\n// This is a reference implementation designed to match the\n// written specification as closely as possible.  It is *NOT*\n// an efficient implementation, but see comments below.\n\nconst IOStream  = require(\"./iostream\");\nconst rans      = require(\"./rans4x16\");\nconst arith_gen = require(\"./arith_gen\");\n\nvar arith = new arith_gen()\n\nconst TOK_TYPE    = 0\nconst TOK_STRING  = 1\nconst TOK_CHAR    = 2\nconst TOK_DIGITS0 = 3\nconst TOK_DZLEN   = 4\nconst TOK_DUP     = 5\nconst TOK_DIFF    = 6\nconst TOK_DIGITS  = 7\nconst TOK_DELTA   = 8\nconst TOK_DELTA0  = 9\nconst TOK_MATCH   = 10\nconst TOK_NOP     = 11\nconst TOK_END     = 12\n\n//----------------------------------------------------------------------\n// Token byte streams\nfunction DecodeTokenByteStreams(src, in_size, use_arith, nnames) {\n    var t = -1\n\n    var B = new Array(256)\n\n    while (!src.EOF()) {\n\tvar ttype = src.ReadByte()\n\tvar tok_new = ttype & 128\n\tvar tok_dup = ttype & 64\n\tvar type    = ttype & 63\n\n\tif (tok_new) {\n\t    t++\n\t    B[t] = new Array(13)\n\t}\n\n\tif (type != TOK_TYPE && tok_new) {\n\t    var M = new Array(nnames-1).fill(TOK_MATCH)\n\t    B[t][TOK_TYPE] = new IOStream(Buffer.from([type].concat(M)))\n        }\n\n\tif (tok_dup) {\n\t    var dup_pos  = src.ReadByte()\n\t    var dup_type = src.ReadByte()\n\t    B[t][type] = new IOStream(B[dup_pos][dup_type].buf)\n\t} else {\n\t    var clen = src.ReadUint7()\n\t    var data = src.ReadData(clen)\n\n\t    if (use_arith)\n\t\tB[t][type] = arith.decode(data)\n\t    else\n\t\tB[t][type] = rans.decode(data)\n\t    B[t][type] = new IOStream(B[t][type])\n\t}\n    }\n\n    return B\n}\n\n//----------------------------------------------------------------------\n// Token decode\nfunction LeftPadNumber(val, len) {\n    var str = val+\"\"\n    while (str.length < len)\n\tstr = \"0\" + str\n\n    return str\n}\n\nfunction DecodeSingleName(B, N, T, n) {\n    var type = B[0][TOK_TYPE].ReadByte()\n    var dist = B[0][type].ReadUint32()\n    var m = n - dist\n\n    if (type == TOK_DUP) {\n\tN[n] = N[m]\n\tT[n] = T[m]\n\treturn N[n]\n    }\n    \n    var t = 1\n    N[n] = \"\"\n    T[n] = new Array(256)\n    do {\n\ttype = B[t][TOK_TYPE].ReadByte()\n\n\tswitch(type) {\n\tcase TOK_CHAR:\n\t    T[n][t] = B[t][TOK_CHAR].ReadChar()\n\t    break\n\n\tcase TOK_STRING:\n\t    T[n][t] = B[t][TOK_STRING].ReadString()\n\t    break\n\t\n\tcase TOK_DIGITS:\n\t    T[n][t] = B[t][TOK_DIGITS].ReadUint32()\n\t    break\n\n\tcase TOK_DIGITS0:\n\t    var d = B[t][TOK_DIGITS0].ReadUint32()\n\t    var l = B[t][TOK_DZLEN].ReadByte()\n\t    T[n][t] = LeftPadNumber(d, l)\n\t    break\n\n\tcase TOK_DELTA:\n\t    T[n][t] = (T[m][t]>>0) + B[t][TOK_DELTA].ReadByte()\n\t    break\n\n\tcase TOK_DELTA0:\n\t    var d = (T[m][t]>>0) + B[t][TOK_DELTA0].ReadByte()\n\t    var l = T[m][t].length\n\t    T[n][t] = LeftPadNumber(d, l)\n\t    break\n\n\tcase TOK_MATCH:\n\t    T[n][t] = T[m][t]\n\t    break\n\n\tdefault:\n\t    T[n][t] = \"\"\n\t    break\n\t}\n\n\tN[n] += T[n][t++]\n    } while (type != TOK_END)\n\n    return N[n]\n}\n\n//----------------------------------------------------------------------\n// Main tokeniser decode entry function: decodes a compressed src and\n// returns the uncompressed buffer.\nfunction decode(src, len, separator) {\n    var src = new IOStream(src)\n    var ulen = src.ReadUint32()\n    var nnames = src.ReadUint32()\n    var use_arith = src.ReadByte()\n\n    var B = DecodeTokenByteStreams(src, len, use_arith, nnames)\n    var N = new Array(nnames)\n    var T = new Array(nnames)\n\n    var str = \"\"\n    if (typeof separator === 'undefined')\n\tseparator = '\\n'\n    for (var i = 0; i < nnames; i++)\n\tstr += DecodeSingleName(B, N, T, i) + separator\n\n    return str\n}\n\n//----------------------------------------------------------------------\n// Main tokeniser encode function\n\n// Encoder is trickier than decode as we have a lot of decisions to make.\n// However here we just make a simple guess without anything complex,\n// to demonstrate the basic idea.  See the C implementation for further\n// expansion on this.\nfunction encode(src, use_arith) {\n    // Convert buffer to array of names\n    var str = src.toString()\n    if (str[str.length-1] == '\\n')\n\tstr = str.substring(0,str.length-1)\n    var names = str.split(\"\\n\")\n\n    var out = new IOStream(\"\", 0, str.length*2 + 10000) // guess max size\n    out.WriteUint32(str.length)\n    out.WriteUint32(names.length)\n    out.WriteByte(use_arith)\n\n    // Tokenise names\n    var T = new Array(names.length)\n    var H = {}\n    var F = new Array(256).fill(0) // DELTA vs DIGIT frequency\n    var max_tok = 0\n    var max_len = 0\n    for (var i = 0; i < names.length; i++) {\n\tvar [ntok,len] = TokeniseName(T, H, F, names[i], i)\n\tif (max_tok < ntok)\n\t    max_tok = ntok\n\tif (max_len < len)\n\t    max_len = len\n    }\n\n    // Convert tokens to byte streams and serialise\n    for (var tnum = 0; tnum < max_tok; tnum++) {\n\tvar B = new Array(TOK_END+1)\n\tfor (var type = 0; type <= TOK_END; type++)\n\t    B[type] = new IOStream(\"\", 0, names.length * max_len)\n\n\tFillByteStreams(B, T, tnum, names, max_tok, max_len)\n\tSerialiseByteStreams(B, tnum, use_arith, out)\n    }\n\n    return out.buf.slice(0, out.pos)\n}\n\nfunction FillByteStreams(B, T, tnum, names, max_tok, max_len) {\n    // Create byte streams B[]\n    for (var n = 0; n < names.length; n++) {\n\tif (tnum > 0 && T[n][0].type == TOK_DUP)\n\t    continue\n\n\tif (!T[n][tnum])\n\t    continue\n\n\tB[TOK_TYPE].WriteByte(T[n][tnum].type)\n\n\tswitch (T[n][tnum].type) {\n\tcase TOK_DIFF:\n\t    B[TOK_DIFF].WriteUint32(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DUP:\n\t    B[TOK_DUP].WriteUint32(T[n][tnum].val)\n\t    break\n\n\tcase TOK_STRING:\n\t    B[TOK_STRING].WriteString(T[n][tnum].val)\n\t    break\n\n\tcase TOK_CHAR:\n\t    B[TOK_CHAR].WriteChar(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DIGITS:\n\t    B[TOK_DIGITS].WriteUint32(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DIGITS0:\n\t    B[TOK_DIGITS0].WriteUint32(T[n][tnum].val)\n\t    B[TOK_DZLEN].WriteByte(T[n][tnum].val.length)\n\t    break\n\n\tcase TOK_DELTA:\n\t    B[T[n][tnum].type].WriteByte(T[n][tnum].val)\n\t    break\n\n\tcase TOK_DELTA0:\n\t    B[T[n][tnum].type].WriteByte(T[n][tnum].val)\n\t    break\n\t}\n    }\n}\n\nfunction SerialiseByteStreams(B, tnum, use_arith, out) {\n    // Compress and serialise byte streams B[]\n    for (var type = 0; type <= TOK_END; type++) {\n\tif (B[type].pos <= 0)\n\t    continue\n\n\tout.WriteByte(type + ((type == 0) ? 128 : 0))\n\n\t// IOStream to sized buffer\n\tB[type] = B[type].buf.slice(0, B[type].pos)\n\tvar comp = try_compress(B[type], use_arith)\n\n\tout.WriteUint7(comp.length)\n\tout.WriteData(comp, comp.length)\n    }\n}\n\nfunction try_compress(src, use_arith) {\n    var best = 1<<30\n    var comp\n\n    var methods = [0, 1, 64, 65, 128, 129, 193+8]\n    for (var i in methods) {\n\tvar lvl = methods[i]\n\tif ((lvl & 1) && src.length < 100)\n\t    continue\n\n\tif ((lvl & 8) && (src.length % 4) != 0)\n\t    continue\n\n\ttry {\n\t    var tmp = use_arith\n\t\t? arith.encode(src, lvl)\n\t\t: rans.encode(src, lvl)\n\t} catch (e) {\n\t    var tmp = 0\n\t}\n\tif (tmp && best > tmp.length) {\n\t    best = tmp.length\n\t    comp = tmp\n\t}\n    }\n\n    return comp\n}\n\nfunction TokeniseName(T, H, F, name, n) {\n    var max_len = 0\n\n    // Always compare against last name only\n    var p = n-1\n    T[n] = new Array(256)\n\n    if (H[name]) {\n\t//console.error(name,H[name],n)\n\tT[n][0] = {\n\t    type: TOK_DUP,\n\t    val:  n - H[name]\n\t}\n    } else {\n\tT[n][0] = {\n\t    type: TOK_DIFF,\n\t    val:  n == 0 ? 0 : 1\n\t}\n    }\n\n    H[name] = n\n\n    // Splits on alphanumerics, punctuation\n    var tok = name.match(/([a-zA-Z0-9]{1,9})|([^a-zA-Z0-9]+)/g)\n    for (var i = 0; i < tok.length; i++) {\n\tvar t = i+1 // token 0 = DIFF vs DUP\n\tvar type = TOK_STRING\n\tvar val = tok[i]\n\tif (tok[i].match(/^0+[0-9]*$/g))\n\t    type = TOK_DIGITS0\n\telse if (tok[i].match(/^[0-9]+$/g))\n\t    type = TOK_DIGITS\n\telse if (tok[i].length == 1)\n\t    type = TOK_CHAR\n\n\tif (p >= 0 && T[p][t]) {\n\t    if (T[p][t].str == tok[i]) {\n\t\ttype = TOK_MATCH\n\t\tval = \"\"\n\t    } else if (T[p][t].type == TOK_DIGITS || T[p][t].type == TOK_DELTA) {\n\t\tvar d = val - T[p][t].str;\n\t\tF[t]++\n\t\tif (d >= 0 && d < 256 && F[t] > n/2) {\n\t\t    type = TOK_DELTA\n\t\t    val = d\n\t\t}\n\t    } else if ((T[p][t].type == TOK_DIGITS0 || T[p][t].type == TOK_DELTA0)\n\t\t       && T[p][t].str.length == val.length) {\n\t\tvar d = val - T[p][t].str;\n\t\tF[t]++\n\t\tif (d >= 0 && d < 256 && F[t] > n/2) {\n\t\t    type = TOK_DELTA0\n\t\t    val = d\n\t\t}\n\t    }\n\t}\n\n\tT[n][t] = {\n\t    str:  tok[i],\n\t    val:  val,\n\t    type: type\n\t}\n\n\tif (max_len < T[n][t].val.length+3)  // +3 for integers; 5 -> (Uint32)5\n\t    max_len = T[n][t].val.length+3\n\n\t//console.error(t,T[n][t])\n    }\n    T[n][++t] = {\n\ttype: TOK_END\n    }\n\n    return [t+1, max_len]\n}\n\nmodule.exports = { encode, decode }\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n","/*\nbzip2.js - a small bzip2 decompression implementation\n\nCopyright 2011 by antimatter15 (antimatter15@gmail.com)\n\nBased on micro-bunzip by Rob Landley (rob@landley.net).\n\nBased on bzip2 decompression code by Julian R Seward (jseward@acm.org),\nwhich also acknowledges contributions by Mike Burrows, David Wheeler,\nPeter Fenwick, Alistair Moffat, Radford Neal, Ian H. Witten,\nRobert Sedgewick, and Jon L. Bentley.\n\nI hereby release this code under the GNU Library General Public License\n(LGPL) version 2, available at http://www.gnu.org/copyleft/lgpl.html\n*/\n\nvar bzip2 = {};\n\nbzip2.array = function (bytes) {\n    var bit = 0,\n        byte = 0;\n    var BITMASK = [0, 0x01, 0x03, 0x07, 0x0F, 0x1F, 0x3F, 0x7F, 0xFF];\n    return function (n) {\n        var result = 0;\n        while (n > 0) {\n            var left = 8 - bit;\n            if (n >= left) {\n                result <<= left;\n                result |= (BITMASK[left] & bytes[byte++]);\n                bit = 0;\n                n -= left;\n            } else {\n                result <<= n;\n                result |= ((bytes[byte] & (BITMASK[n] << (8 - n - bit))) >> (8 - n - bit));\n                bit += n;\n                n = 0;\n            }\n        }\n        return result\n    }\n}\n\nbzip2.simple = function (bits) {\n    var size = bzip2.header(bits);\n    var all, chunk, chunks = [];\n    var index = 0;\n    do {\n        //all += chunk;\n        chunk = bzip2.decompress(bits, size);\n        //all.set(chunk, index);\n        if (chunk != -1) {\n            chunks.push(chunk);\n            index += chunk.byteLength;\n        }\n    } while (chunk != -1);\n    all = new Uint8Array(index);\n    index = 0;\n    for (var i = 0; i < chunks.length; ++i) {\n        chunk = chunks[i];\n        all.set(chunk, index);\n        index += chunk.byteLength;\n    }\n    return all;\n}\n\nbzip2.header = function (bits) {\n    if (bits(8 * 3) != 4348520)\n        throw \"No magic number found\";\n    var i = bits(8) - 48;\n    if (i < 1 || i > 9)\n        throw \"Not a BZIP archive\";\n    return i;\n};\n\n//takes a function for reading the block data (starting with 0x314159265359)\n//a block size (0-9) (optional, defaults to 9)\n//a length at which to stop decompressing and return the output\nbzip2.decompress = function (bits, size, len) {\n    var MAX_HUFCODE_BITS = 20;\n    var MAX_SYMBOLS = 258;\n    var SYMBOL_RUNA = 0;\n    var SYMBOL_RUNB = 1;\n    var GROUP_SIZE = 50;\n\n    var bufsize = 100000 * 9;\n    for (var h = '', i = 0; i < 6; i++)\n        h += bits(8).toString(16);\n    if (h == \"177245385090\")\n        return -1; //last block\n    if (h != \"314159265359\")\n        throw \"eek not valid bzip data\";\n    bits(32); //ignore CRC codes\n    if (bits(1))\n        throw \"unsupported obsolete version\";\n    var origPtr = bits(24);\n    if (origPtr > bufsize)\n        throw \"Initial position larger than buffer size\";\n    var t = bits(16);\n    var symToByte = new Uint8Array(256),\n        symTotal = 0;\n    for (i = 0; i < 16; i++) {\n        if (t & (1 << (15 - i))) {\n            var k = bits(16);\n            for (j = 0; j < 16; j++) {\n                if (k & (1 << (15 - j))) {\n                    symToByte[symTotal++] = (16 * i) + j;\n                }\n            }\n        }\n    }\n\n    var groupCount = bits(3);\n    if (groupCount < 2 || groupCount > 6)\n        throw \"another error\";\n    var nSelectors = bits(15);\n    if (nSelectors == 0)\n        throw \"meh\";\n    var mtfSymbol = []; //TODO: possibly replace JS array with typed arrays\n    for (var i = 0; i < groupCount; i++)\n        mtfSymbol[i] = i;\n    var selectors = new Uint8Array(32768);\n\n    for (var i = 0; i < nSelectors; i++) {\n        for (var j = 0; bits(1); j++)\n            if (j >= groupCount)\n                throw \"whoops another error\";\n        var uc = mtfSymbol[j];\n        mtfSymbol.splice(j, 1); //this is a probably inefficient MTF transform\n        mtfSymbol.splice(0, 0, uc);\n        selectors[i] = uc;\n    }\n\n    var symCount = symTotal + 2;\n    var groups = [];\n    for (var j = 0; j < groupCount; j++) {\n        var length = new Uint8Array(MAX_SYMBOLS),\n            temp = new Uint8Array(MAX_HUFCODE_BITS + 1);\n        t = bits(5); //lengths\n        for (var i = 0; i < symCount; i++) {\n            while (true) {\n                if (t < 1 || t > MAX_HUFCODE_BITS)\n                    throw \"I gave up a while ago on writing error messages\";\n                if (!bits(1))\n                    break;\n                if (!bits(1))\n                    t++;\n                else\n                    t--;\n            }\n            length[i] = t;\n        }\n        var minLen, maxLen;\n        minLen = maxLen = length[0];\n        for (var i = 1; i < symCount; i++) {\n            if (length[i] > maxLen)\n                maxLen = length[i];\n            else if (length[i] < minLen)\n                minLen = length[i];\n        }\n        var hufGroup;\n        hufGroup = groups[j] = {};\n        hufGroup.permute = new Uint32Array(MAX_SYMBOLS);\n        hufGroup.limit = new Uint32Array(MAX_HUFCODE_BITS + 1);\n        hufGroup.base = new Uint32Array(MAX_HUFCODE_BITS + 1);\n        hufGroup.minLen = minLen;\n        hufGroup.maxLen = maxLen;\n        var base = hufGroup.base.subarray(1);\n        var limit = hufGroup.limit.subarray(1);\n        var pp = 0;\n        for (var i = minLen; i <= maxLen; i++)\n            for (var t = 0; t < symCount; t++)\n                if (length[t] == i)\n                    hufGroup.permute[pp++] = t;\n        for (i = minLen; i <= maxLen; i++)\n            temp[i] = limit[i] = 0;\n        for (i = 0; i < symCount; i++)\n            temp[length[i]]++;\n        pp = t = 0;\n        for (i = minLen; i < maxLen; i++) {\n            pp += temp[i];\n            limit[i] = pp - 1;\n            pp <<= 1;\n            base[i + 1] = pp - (t += temp[i]);\n        }\n        limit[maxLen] = pp + temp[maxLen] - 1;\n        base[minLen] = 0;\n    }\n    var byteCount = new Uint32Array(256);\n    for (var i = 0; i < 256; i++)\n        mtfSymbol[i] = i;\n    var runPos, count, symCount, selector;\n    runPos = count = symCount = selector = 0;\n    var buf = new Uint32Array(bufsize);\n    while (true) {\n        if (!(symCount--)) {\n            symCount = GROUP_SIZE - 1;\n            if (selector >= nSelectors)\n                throw \"meow i'm a kitty, that's an error\";\n            hufGroup = groups[selectors[selector++]];\n            base = hufGroup.base.subarray(1);\n            limit = hufGroup.limit.subarray(1);\n        }\n        i = hufGroup.minLen;\n        j = bits(i);\n        while (true) {\n            if (i > hufGroup.maxLen)\n                throw \"rawr i'm a dinosaur\";\n            if (j <= limit[i])\n                break;\n            i++;\n            j = (j << 1) | bits(1);\n        }\n        j -= base[i];\n        if (j < 0 || j >= MAX_SYMBOLS)\n            throw \"moo i'm a cow\";\n        var nextSym = hufGroup.permute[j];\n        if (nextSym == SYMBOL_RUNA || nextSym == SYMBOL_RUNB) {\n            if (!runPos) {\n                runPos = 1;\n                t = 0;\n            }\n            if (nextSym == SYMBOL_RUNA)\n                t += runPos;\n            else\n                t += 2 * runPos;\n            runPos <<= 1;\n            continue;\n        }\n        if (runPos) {\n            runPos = 0;\n            if (count + t >= bufsize)\n                throw \"Boom.\";\n            uc = symToByte[mtfSymbol[0]];\n            byteCount[uc] += t;\n            while (t--)\n                buf[count++] = uc;\n        }\n        if (nextSym > symTotal)\n            break;\n        if (count >= bufsize)\n            throw \"I can't think of anything. Error\";\n        i = nextSym - 1;\n        uc = mtfSymbol[i];\n        mtfSymbol.splice(i, 1);\n        mtfSymbol.splice(0, 0, uc);\n        uc = symToByte[uc];\n        byteCount[uc]++;\n        buf[count++] = uc;\n    }\n    if (origPtr < 0 || origPtr >= count)\n        throw \"I'm a monkey and I'm throwing something at someone, namely you\";\n    var j = 0;\n    for (var i = 0; i < 256; i++) {\n        k = j + byteCount[i];\n        byteCount[i] = j;\n        j = k;\n    }\n    for (var i = 0; i < count; i++) {\n        uc = buf[i] & 0xff;\n        buf[byteCount[uc]] |= (i << 8);\n        byteCount[uc]++;\n    }\n    var pos = 0,\n        current = 0,\n        run = 0;\n    if (count) {\n        pos = buf[origPtr];\n        current = (pos & 0xff);\n        pos >>= 8;\n        run = -1;\n    }\n    count = count;\n    var output = new Uint8Array(bufsize);\n    var copies, previous, outbyte;\n    var index = 0;\n    if (!len)\n        len = Infinity;\n    while (count) {\n        count--;\n        previous = current;\n        pos = buf[pos];\n        current = pos & 0xff;\n        pos >>= 8;\n        if (run++ == 3) {\n            copies = current;\n            outbyte = previous;\n            current = -1;\n        } else {\n            copies = 1;\n            outbyte = current;\n        }\n        while (copies--) {\n            //output += (String.fromCharCode(outbyte));\n            output[index++] = outbyte;\n            //index++;\n            if (!--len)\n                return output;\n        }\n        if (current != previous)\n            run = 0;\n    }\n    //return output;\n    //return output.subarray(0,index-1);\n    return output.subarray(0, index);\n}\n\nmodule.exports = bzip2;\n","var charenc = {\n  // UTF-8 encoding\n  utf8: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      return charenc.bin.stringToBytes(unescape(encodeURIComponent(str)));\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      return decodeURIComponent(escape(charenc.bin.bytesToString(bytes)));\n    }\n  },\n\n  // Binary encoding\n  bin: {\n    // Convert a string to a byte array\n    stringToBytes: function(str) {\n      for (var bytes = [], i = 0; i < str.length; i++)\n        bytes.push(str.charCodeAt(i) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a string\n    bytesToString: function(bytes) {\n      for (var str = [], i = 0; i < bytes.length; i++)\n        str.push(String.fromCharCode(bytes[i]));\n      return str.join('');\n    }\n  }\n};\n\nmodule.exports = charenc;\n","var global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n","(function() {\n  var base64map\n      = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n\n  crypt = {\n    // Bit-wise rotation left\n    rotl: function(n, b) {\n      return (n << b) | (n >>> (32 - b));\n    },\n\n    // Bit-wise rotation right\n    rotr: function(n, b) {\n      return (n << (32 - b)) | (n >>> b);\n    },\n\n    // Swap big-endian to little-endian and vice versa\n    endian: function(n) {\n      // If number given, swap endian\n      if (n.constructor == Number) {\n        return crypt.rotl(n, 8) & 0x00FF00FF | crypt.rotl(n, 24) & 0xFF00FF00;\n      }\n\n      // Else, assume array and swap all items\n      for (var i = 0; i < n.length; i++)\n        n[i] = crypt.endian(n[i]);\n      return n;\n    },\n\n    // Generate an array of any length of random bytes\n    randomBytes: function(n) {\n      for (var bytes = []; n > 0; n--)\n        bytes.push(Math.floor(Math.random() * 256));\n      return bytes;\n    },\n\n    // Convert a byte array to big-endian 32-bit words\n    bytesToWords: function(bytes) {\n      for (var words = [], i = 0, b = 0; i < bytes.length; i++, b += 8)\n        words[b >>> 5] |= bytes[i] << (24 - b % 32);\n      return words;\n    },\n\n    // Convert big-endian 32-bit words to a byte array\n    wordsToBytes: function(words) {\n      for (var bytes = [], b = 0; b < words.length * 32; b += 8)\n        bytes.push((words[b >>> 5] >>> (24 - b % 32)) & 0xFF);\n      return bytes;\n    },\n\n    // Convert a byte array to a hex string\n    bytesToHex: function(bytes) {\n      for (var hex = [], i = 0; i < bytes.length; i++) {\n        hex.push((bytes[i] >>> 4).toString(16));\n        hex.push((bytes[i] & 0xF).toString(16));\n      }\n      return hex.join('');\n    },\n\n    // Convert a hex string to a byte array\n    hexToBytes: function(hex) {\n      for (var bytes = [], c = 0; c < hex.length; c += 2)\n        bytes.push(parseInt(hex.substr(c, 2), 16));\n      return bytes;\n    },\n\n    // Convert a byte array to a base-64 string\n    bytesToBase64: function(bytes) {\n      for (var base64 = [], i = 0; i < bytes.length; i += 3) {\n        var triplet = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n        for (var j = 0; j < 4; j++)\n          if (i * 8 + j * 6 <= bytes.length * 8)\n            base64.push(base64map.charAt((triplet >>> 6 * (3 - j)) & 0x3F));\n          else\n            base64.push('=');\n      }\n      return base64.join('');\n    },\n\n    // Convert a base-64 string to a byte array\n    base64ToBytes: function(base64) {\n      // Remove non-base-64 characters\n      base64 = base64.replace(/[^A-Z0-9+\\/]/ig, '');\n\n      for (var bytes = [], i = 0, imod4 = 0; i < base64.length;\n          imod4 = ++i % 4) {\n        if (imod4 == 0) continue;\n        bytes.push(((base64map.indexOf(base64.charAt(i - 1))\n            & (Math.pow(2, -2 * imod4 + 8) - 1)) << (imod4 * 2))\n            | (base64map.indexOf(base64.charAt(i)) >>> (6 - imod4 * 2)));\n      }\n      return bytes;\n    }\n  };\n\n  module.exports = crypt;\n})();\n","/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n","(function(){\r\n  var crypt = require('crypt'),\r\n      utf8 = require('charenc').utf8,\r\n      isBuffer = require('is-buffer'),\r\n      bin = require('charenc').bin,\r\n\r\n  // The core\r\n  md5 = function (message, options) {\r\n    // Convert to byte array\r\n    if (message.constructor == String)\r\n      if (options && options.encoding === 'binary')\r\n        message = bin.stringToBytes(message);\r\n      else\r\n        message = utf8.stringToBytes(message);\r\n    else if (isBuffer(message))\r\n      message = Array.prototype.slice.call(message, 0);\r\n    else if (!Array.isArray(message) && message.constructor !== Uint8Array)\r\n      message = message.toString();\r\n    // else, assume byte array already\r\n\r\n    var m = crypt.bytesToWords(message),\r\n        l = message.length * 8,\r\n        a =  1732584193,\r\n        b = -271733879,\r\n        c = -1732584194,\r\n        d =  271733878;\r\n\r\n    // Swap endian\r\n    for (var i = 0; i < m.length; i++) {\r\n      m[i] = ((m[i] <<  8) | (m[i] >>> 24)) & 0x00FF00FF |\r\n             ((m[i] << 24) | (m[i] >>>  8)) & 0xFF00FF00;\r\n    }\r\n\r\n    // Padding\r\n    m[l >>> 5] |= 0x80 << (l % 32);\r\n    m[(((l + 64) >>> 9) << 4) + 14] = l;\r\n\r\n    // Method shortcuts\r\n    var FF = md5._ff,\r\n        GG = md5._gg,\r\n        HH = md5._hh,\r\n        II = md5._ii;\r\n\r\n    for (var i = 0; i < m.length; i += 16) {\r\n\r\n      var aa = a,\r\n          bb = b,\r\n          cc = c,\r\n          dd = d;\r\n\r\n      a = FF(a, b, c, d, m[i+ 0],  7, -680876936);\r\n      d = FF(d, a, b, c, m[i+ 1], 12, -389564586);\r\n      c = FF(c, d, a, b, m[i+ 2], 17,  606105819);\r\n      b = FF(b, c, d, a, m[i+ 3], 22, -1044525330);\r\n      a = FF(a, b, c, d, m[i+ 4],  7, -176418897);\r\n      d = FF(d, a, b, c, m[i+ 5], 12,  1200080426);\r\n      c = FF(c, d, a, b, m[i+ 6], 17, -1473231341);\r\n      b = FF(b, c, d, a, m[i+ 7], 22, -45705983);\r\n      a = FF(a, b, c, d, m[i+ 8],  7,  1770035416);\r\n      d = FF(d, a, b, c, m[i+ 9], 12, -1958414417);\r\n      c = FF(c, d, a, b, m[i+10], 17, -42063);\r\n      b = FF(b, c, d, a, m[i+11], 22, -1990404162);\r\n      a = FF(a, b, c, d, m[i+12],  7,  1804603682);\r\n      d = FF(d, a, b, c, m[i+13], 12, -40341101);\r\n      c = FF(c, d, a, b, m[i+14], 17, -1502002290);\r\n      b = FF(b, c, d, a, m[i+15], 22,  1236535329);\r\n\r\n      a = GG(a, b, c, d, m[i+ 1],  5, -165796510);\r\n      d = GG(d, a, b, c, m[i+ 6],  9, -1069501632);\r\n      c = GG(c, d, a, b, m[i+11], 14,  643717713);\r\n      b = GG(b, c, d, a, m[i+ 0], 20, -373897302);\r\n      a = GG(a, b, c, d, m[i+ 5],  5, -701558691);\r\n      d = GG(d, a, b, c, m[i+10],  9,  38016083);\r\n      c = GG(c, d, a, b, m[i+15], 14, -660478335);\r\n      b = GG(b, c, d, a, m[i+ 4], 20, -405537848);\r\n      a = GG(a, b, c, d, m[i+ 9],  5,  568446438);\r\n      d = GG(d, a, b, c, m[i+14],  9, -1019803690);\r\n      c = GG(c, d, a, b, m[i+ 3], 14, -187363961);\r\n      b = GG(b, c, d, a, m[i+ 8], 20,  1163531501);\r\n      a = GG(a, b, c, d, m[i+13],  5, -1444681467);\r\n      d = GG(d, a, b, c, m[i+ 2],  9, -51403784);\r\n      c = GG(c, d, a, b, m[i+ 7], 14,  1735328473);\r\n      b = GG(b, c, d, a, m[i+12], 20, -1926607734);\r\n\r\n      a = HH(a, b, c, d, m[i+ 5],  4, -378558);\r\n      d = HH(d, a, b, c, m[i+ 8], 11, -2022574463);\r\n      c = HH(c, d, a, b, m[i+11], 16,  1839030562);\r\n      b = HH(b, c, d, a, m[i+14], 23, -35309556);\r\n      a = HH(a, b, c, d, m[i+ 1],  4, -1530992060);\r\n      d = HH(d, a, b, c, m[i+ 4], 11,  1272893353);\r\n      c = HH(c, d, a, b, m[i+ 7], 16, -155497632);\r\n      b = HH(b, c, d, a, m[i+10], 23, -1094730640);\r\n      a = HH(a, b, c, d, m[i+13],  4,  681279174);\r\n      d = HH(d, a, b, c, m[i+ 0], 11, -358537222);\r\n      c = HH(c, d, a, b, m[i+ 3], 16, -722521979);\r\n      b = HH(b, c, d, a, m[i+ 6], 23,  76029189);\r\n      a = HH(a, b, c, d, m[i+ 9],  4, -640364487);\r\n      d = HH(d, a, b, c, m[i+12], 11, -421815835);\r\n      c = HH(c, d, a, b, m[i+15], 16,  530742520);\r\n      b = HH(b, c, d, a, m[i+ 2], 23, -995338651);\r\n\r\n      a = II(a, b, c, d, m[i+ 0],  6, -198630844);\r\n      d = II(d, a, b, c, m[i+ 7], 10,  1126891415);\r\n      c = II(c, d, a, b, m[i+14], 15, -1416354905);\r\n      b = II(b, c, d, a, m[i+ 5], 21, -57434055);\r\n      a = II(a, b, c, d, m[i+12],  6,  1700485571);\r\n      d = II(d, a, b, c, m[i+ 3], 10, -1894986606);\r\n      c = II(c, d, a, b, m[i+10], 15, -1051523);\r\n      b = II(b, c, d, a, m[i+ 1], 21, -2054922799);\r\n      a = II(a, b, c, d, m[i+ 8],  6,  1873313359);\r\n      d = II(d, a, b, c, m[i+15], 10, -30611744);\r\n      c = II(c, d, a, b, m[i+ 6], 15, -1560198380);\r\n      b = II(b, c, d, a, m[i+13], 21,  1309151649);\r\n      a = II(a, b, c, d, m[i+ 4],  6, -145523070);\r\n      d = II(d, a, b, c, m[i+11], 10, -1120210379);\r\n      c = II(c, d, a, b, m[i+ 2], 15,  718787259);\r\n      b = II(b, c, d, a, m[i+ 9], 21, -343485551);\r\n\r\n      a = (a + aa) >>> 0;\r\n      b = (b + bb) >>> 0;\r\n      c = (c + cc) >>> 0;\r\n      d = (d + dd) >>> 0;\r\n    }\r\n\r\n    return crypt.endian([a, b, c, d]);\r\n  };\r\n\r\n  // Auxiliary functions\r\n  md5._ff  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & c | ~b & d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._gg  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b & d | c & ~d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._hh  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (b ^ c ^ d) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n  md5._ii  = function (a, b, c, d, x, s, t) {\r\n    var n = a + (c ^ (b | ~d)) + (x >>> 0) + t;\r\n    return ((n << s) | (n >>> (32 - s))) + b;\r\n  };\r\n\r\n  // Package private blocksize\r\n  md5._blocksize = 16;\r\n  md5._digestsize = 16;\r\n\r\n  module.exports = function (message, options) {\r\n    if (message === undefined || message === null)\r\n      throw new Error('Illegal argument ' + message);\r\n\r\n    var digestbytes = crypt.wordsToBytes(md5(message, options));\r\n    return options && options.asBytes ? digestbytes :\r\n        options && options.asString ? bin.bytesToString(digestbytes) :\r\n        crypt.bytesToHex(digestbytes);\r\n  };\r\n\r\n})();\r\n"],"names":["unzip","input","Buffer","from","inflate","CramError","Error","CramUnimplementedError","CramMalformedError","CramBufferOverrunError","CramSizeLimitError","CramArgumentError","TF_SHIFT","TOTFREQ","RANS_BYTE_L","FC","this","F","undefined","C","AriDecoder","fc","Array","i","length","R","advanceStep","r","start","freq","scaleBits","Symbol","symbolInit","sym","advanceSymbolStep","get","advanceSymbol","pptr","advance","renormalize","assert","result","uncompressOrder0Way4","out","D","Decoding","syms","cp","decoder","rle","x","j","fill","getByteAt","position","readStatsO0","c","rans0","getInt","rans1","rans2","rans3","outputSize","remaining","outputEnd","c0","c1","c2","c3","putAt","setPosition","put","D04","uncompressOrder1Way4","output","rlei","rlej","readStatsO1","rans7","isz4","i0","i1","i2","i7","l0","l1","l2","l7","c7","D14","ByteBuffer","nodeBuffer","initialInputPosition","_buffer","_position","b","val","pos","readInt32LE","singleItf8","Parser","itf8","cramFileDefinition","parser","string","uint8","stripNull","maxLength","cramBlockHeader","formatter","method","type","cramBlockCrc32","uint32","cramTagDictionary","buffer","makeTagSet","stringStart","stringEnd","str","toString","tags","push","substr","tagSets","parseByteAsBool","cramPreservationMap","array","choice","tag","choices","MI","UI","PI","RN","AP","RR","SM","TD","nest","data","ents","formatMap","map","key","value","console","warn","unversionedParsers","versionedParsers","cramUnmappedSliceHeader","majorVersion","ltf8","numContentIds","cramMappedSliceHeader","cramEncoding","namely","cramDataSeriesEncodingMap","cramTagEncodingMap","integerRepresentation","String","fromCharCode","cramCompressionHeader","cramContainerHeader1","int32","cramContainerHeader2","crcLength","numLandmarks","getSectionParsers","parsers","Object","assign","keys","forEach","parserName","parseItem","startBufferPosition","startFilePosition","parse","offset","_endPosition","_size","tinyMemoize","_class","methodName","prototype","memoAttrName","res","call","Promise","resolve","catch","sequenceMD5","seq","md5","toUpperCase","replace","CRAM_FLAG_PRESERVE_QUAL_SCORES","CRAM_FLAG_DETACHED","CRAM_FLAG_MATE_DOWNSTREAM","CRAM_FLAG_NO_SEQ","CRAM_FLAG_MASK","CRAM_M_REVERSE","CRAM_M_UNMAP","BAM_FPAIRED","BAM_FPROPER_PAIR","BAM_FUNMAP","BAM_FMUNMAP","BAM_FREVERSE","BAM_FMREVERSE","BAM_FREAD1","BAM_FREAD2","BAM_FSECONDARY","BAM_FQCFAIL","BAM_FDUP","BAM_FSUPPLEMENTARY","BAM_CMATCH","BAM_CINS","BAM_CDEL","BAM_CREF_SKIP","BAM_CSOFT_CLIP","BAM_CHARD_CLIP","BAM_CPAD","BAM_CEQUAL","BAM_CDIFF","BAM_CBACK","BAM_CIGAR_STR","BAM_CIGAR_SHIFT","BAM_CIGAR_MASK","BAM_CIGAR_TYPE","baseNumbers","a","A","g","G","t","T","n","N","CramRecord","flags","Constants","cramFlags","readBases","_refRegion","cramRecord","refRegion","lengthOnRef","readLength","isUnknownBases","regionSeqOffset","alignmentStart","readFeatures","bases","regionPos","currentReadFeature","feature","code","ret","split","added","sub","chunk","decodeReadSequence","isSegmentUnmapped","isPaired","isMateUnmapped","mate","sequenceId","s1","isReverseComplemented","s2","isMateReverseComplemented","o1","o2","isRead1","isRead2","tmp","isize","templateLength","templateSize","join","compressionScheme","readFeature","refCoord","refPos","refBase","charAt","ref","baseNumber","base","substitutionMatrix","decodeBaseSubstitution","end","k","getReadBases","readNullTerminatedStringFromBuffer","zeroOffset","indexOf","parseTagData","tagType","Long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","readInt16LE","readUInt16LE","readInt8","readUInt8","readFloatLE","hex","parseInt","arrayType","schema","s","S","I","f","getMethod","itemSize","parseTagValueArray","thingToString","thing","termIndex","slice","decodeRecord","decodeDataSeries","sliceHeader","coreDataBlock","blocksByContentId","cursors","recordNumber","content","refSeqId","APdelta","lastAlignmentStart","readGroupId","readNamesIncluded","readName","isDetached","hasMateDownStream","mateRecordNumber","TLindex","TN","getTagNames","ntags","tagId","tagName","tagCodec","getCodecForTag","tagData","decode","qualityScores","isPreservingQualityScores","readFeatureCount","currentReadPos","currentRefPos","decodeRFData","dataSeriesName","toArray","readPosDelta","data1Schema","B","X","q","Q","H","P","data2Schema","decodeReadFeatures","isNaN","mappingQuality","associateIntraSliceMate","allRecords","currentRecordNumber","thisRecord","mateRecord","complicatedMultiSegment","uniqueId","matedRecords","getAllMatedRecords","startRecord","records","starts","ends","estimatedTemplateLength","Math","max","min","calculateMultiSegmentMatedTemplateLength","lengthEstimate","calculateIntraSliceMatePairTemplateLength","CramSlice","container","file","containerPosition","sectionParsers","getHeader","containerHeader","readBlock","header","contentType","_contentType","blockPosition","blocks","numBlocks","getBlocks","block","contentId","id","_getBlocksContentIdIndex","getCompressionScheme","refBaseBlockId","refBlock","getBlockByContentId","span","uncompressedSize","refSeqStart","refSeqSpan","referenceRequired","fetchReferenceSequenceCallback","getRecords","getDefinition","options","checkSequenceMD5","getReferenceRegion","seqMd5","storedMd5","byte","getCoreDataBlock","coreBlock","bitPosition","bytePosition","externalBlocks","getCursor","codec","getCodecForDataSeries","numRecords","contentPosition","recordCounter","filter","filterFunction","cacheKey","filePosition","recordsPromise","featureCache","_fetchRecords","set","singleRefId","refRegions","seqId","Infinity","all","values","addReferenceSequence","validDataTypes","int","long","byteArray","byteArrayBlock","CramCodec","parameters","dataType","TypeError","cursor","numBits","dlen","HuffmanIntCodec","includes","buildCodeBook","buildCodes","buildCaches","sortedCodes","bitLength","_decode","_decodeZeroLengthCode","codes","numCodes","symbol","symbols","bitLengths","sort","codeBook","codeLength","codeValue","entries","delta","bitCode","ii","numberOfSetBits","sortedByValue","sortedValuesByBitCode","sortedBitCodes","sortedBitLengthsByBitCode","maxBitCode","bitCodeToValue","coreCursor","prevLen","bits","_getBits","index","ExternalCodec","_decodeData","_decodeInt","_decodeByte","blockContentId","contentBlock","initialOffset","countFlags","parseItf8","bytesRead","ByteArrayStopCodec","_decodeByteArray","dataBuffer","stopByte","startPosition","stopPosition","instantiateCodec","arrayLength","_getLengthCodec","dataCodec","_getDataCodec","encodingParams","lengthsEncoding","valuesEncoding","BetaCodec","GammaCodec","SubexpCodec","numLeadingOnes","K","codecClasses","ByteArrayLengthCodec","encodingData","CodecClass","codecId","dataSeriesTypes","BF","CF","RI","RL","RG","MF","NS","NP","TS","NF","TC","FN","FP","BS","IN","SC","DL","BA","BB","RS","PD","HC","MQ","QS","QQ","TL","TM","TV","CramContainerCompressionScheme","preservation","tagIdsDictionary","matrix","parseSubstitutionMatrix","dataSeriesCodecCache","tagCodecCache","tagEncoding","tagListId","dataSeriesEncoding","test","CramContainer","cramFile","_readContainerHeader","getFirstBlock","getCompressionHeaderBlock","slicePosition","sliceSize","stat","fileSize","size","bytes1","allocUnsafe","read","header1","v","numLandmarksSize","bytes2","header2","validateChecksums","crc32","checkCrc32","completeHeader","BufferCache","fetch","chunkSize","lruCache","LRU","maxSize","floor","outputBuffer","firstChunk","lastChunk","fetches","_getChunk","then","chunkNumber","chunks","chunksOffset","chunkPositionStart","copyStart","copyEnd","copyOffset","copy","cachedPromise","freshPromise","RemoteFile","source","url","cache","_fetch","headers","range","redirect","mode","response","status","arrayBuffer","sizeMatch","exec","_stat","readPosition","buf","open","maybeUrl","maybePath","maybeFilehandle","protocol","pathname","LocalFile","unescape","fromUrl","parseHeaderText","text","lines","line","parsedFields","CramFile","args","path","filehandle","seqFetch","cacheSize","filename","headbytes","cramFileDefinitionParser","definition","getContainerById","firstContainer","headerLength","getSamHeader","containerNumber","currentContainer","getContainerAtPosition","currentHeader","recordedCrc32","description","calculatedCrc32","containerCount","section","preReadBuffer","compressionMethod","inputBuffer","bzip2","decompress","order","ransuncompress","htscodecs","readBlockHeader","blockContentPosition","uncompressedData","compressedData","compressedSize","_uncompress","_parseSection","crc","IndexedCramFile","cram","cramUrl","cramPath","cramFilehandle","getEntriesForRange","fetchSizeLimit","opts","viewAsPairs","pairAcrossChr","maxInsertSize","slices","totalSize","sliceBytes","reduce","toLocaleString","getRecordsInSlice","sliceResults","concat","readNames","readIds","name","unmatedPairs","matePromises","abs","mateSlices","mateBlocks","mateChunks","localeCompare","item","ary","mateRecordPromises","mateFeatPromises","mateTotalSize","recordPromise","featPromise","feats","mateRecs","newMateFeats","newMates","current","containerStart","sliceStart","getSlice","hasDataForReferenceSequence","Slice","addRecordToIndex","record","some","el","CraiIndex","_parseCache","AbortablePromiseCache","QuickLRU","signal","parseIndex","readFile","bind","uncompressedBuffer","readUInt32LE","currentRecord","currentString","charCode","ent","getIndex","queryStart","queryEnd","seqEntries","compare","entry","entryStart","entryEnd","bins","Map","oldCache","has","_set","deleted","delete","clear","oldCacheSize","iterator","module","exports","RangeCoder","require","IOStream","ByteModel","ARITH_PACK","src","stream","decodeStream","n_out","ReadByte","ReadUint7","e_len","decodeStripe","decodePackMeta","decodeCat","decodeExt","decodeRLE1","decodeRLE0","decode1","decode0","decodePack","WriteByte","WriteUint7","encodeStripe","pack_meta","encodePack","WriteStream","encodeRLE1","encodeRLE0","encode1","encode0","max_sym","byte_model","rc","RangeStartDecode","ModelDecode","n_in","ModelEncode","RangeFinishEncode","last","model_lit","model_run","part","run","rctx","nsym","M","len","meta","packMeta","hdr","ulen","comp","total","comp0","encode","comp1","WriteData","clen","low","FFnum","carry","tot_freq","sym_low","sym_freq","dst","old_low","log","RangeShiftLow","total_freq","RangeGetFrequency","acc","RangeDecode","ModelRenormalise","RangeEncode","read_array","tab","z","run_len","fqz_update_ctx","params","state","context","qctx","qshift","qtab","qbits","qloc","do_pos","ptab","p","ploc","do_delta","dtab","dloc","prevq","do_sel","sloc","decode_fqz_single_param","ReadUint16","pflags","do_dedup","fixed_len","do_qmap","do_qtab","qmap","decode_fqz_new_record","gparams","model","rev","max_sel","sel","stab","do_rev","rec","is_dup","dup","decode_fqz","q_lens","gflags","nparam","error","decode_fqz_params","qual","fqz_create_models","qual_len","reverse_qualities","store_array","tmp1","sz1","i_start","tmp2","sz2","curr","q_dirs","qhist","qd_last","qd_fixed","pbits","pshift","dbits","dshift","sbits","do_stab","pick_fqz_params","dsqr","WriteUint16","encode_fqz_params","model_qual","model_len","model_sel","process","exit","qlast","q1","encode_fqz","r4x8","r4x16","arith","fqzcomp","tok3","r4x8_uncompress","r4x16_uncompress","arith_uncompress","fqzcomp_uncompress","tok3_uncompress","start_pos","charCodeAt","u","writeInt32LE","RansGetCumulativeFreq","RansGetSymbolFromFreq","RansBuildC2S","C2S","RansAdvanceStep","RansRenorm","RansEncFlush","WriteByteNeg","RansEncPut","scale_bits","R_max","RansEncRenorm","ReadFrequencies0","last_sym","ReadITF8","NormaliseFrequencies0","tot","scale","max_val","max_idx","renorm","WriteFrequencies0","WriteITF8","ReadUint32","nbytes","i4","RansDecode0","ReadFrequencies1","L","nbytes4","RansDecode1","WriteUint32","BuildFrequencies0","alloc","rans_out","freq_tab","RansEncode0","F0","BuildFrequencies1","NormaliseFrequencies1","WriteFrequencies1","idx","RansEncode1","RansEncodeStripe","RansDecodeStream","format","stripe","cat","pack","RansDecodeStripe","pack_len","DecodePackMeta","rle_len","u_meta_len","rle_meta","ReadData","comp_meta_len","DecodeRLEMeta","shift","freq_src","ReadAlphabet","NormaliseFrequencies0_Shift","DecodeRLE","DecodePack","ceil","EncodePack","nrle","dpos","cmeta","EncodeRLE","bit_size","log2","WriteAlphabet","cfreq","NormaliseFrequencies1_Shift","rans","LeftPadNumber","DecodeSingleName","m","ReadChar","ReadString","d","l","FillByteStreams","tnum","names","max_tok","max_len","WriteString","WriteChar","SerialiseByteStreams","use_arith","try_compress","best","methods","lvl","e","TokeniseName","tok","match","substring","ntok","TOK_END","separator","nnames","in_size","EOF","ttype","tok_new","tok_dup","dup_pos","dup_type","DecodeTokenByteStreams","__importDefault","mod","__esModule","defineProperty","abortcontroller_ponyfill_1","AggregateAbortController_1","AggregateStatusReporter_1","fillCallback","statusCallback","aborter","default","statusReporter","addCallback","newEntry","promise","message","callback","settled","aborted","addSignal","addEventListener","evict","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","next","done","exception","checkForSingleAbort","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","AggregateStatusReporter","callbacks","currentMessage","elt","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1","bytes","bit","BITMASK","left","byteLength","Uint8Array","bufsize","h","origPtr","symToByte","symTotal","groupCount","nSelectors","mtfSymbol","selectors","uc","splice","symCount","groups","minLen","maxLen","hufGroup","temp","MAX_HUFCODE_BITS","permute","Uint32Array","limit","subarray","pp","runPos","count","selector","byteCount","GROUP_SIZE","nextSym","copies","previous","outbyte","charenc","utf8","stringToBytes","bin","encodeURIComponent","bytesToString","decodeURIComponent","escape","__self__","DOMException","support","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","obj","normalizeName","toLowerCase","normalizeValue","iteratorFor","items","Headers","append","isArray","getOwnPropertyNames","consumed","body","bodyUsed","reject","fileReaderReady","reader","onload","onerror","readBlobAsArrayBuffer","blob","FileReader","readAsArrayBuffer","bufferClone","view","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","readAsText","readBlobAsText","chars","readArrayBufferAsText","formData","json","JSON","oldValue","hasOwnProperty","thisArg","Request","credentials","upcased","normalizeMethod","referrer","form","trim","parseHeaders","rawHeaders","parts","Response","bodyInit","ok","statusText","clone","redirectStatuses","RangeError","location","err","stack","create","constructor","init","request","xhr","XMLHttpRequest","abortXhr","getAllResponseHeaders","responseURL","responseText","ontimeout","onabort","withCredentials","responseType","setRequestHeader","onreadystatechange","readyState","removeEventListener","send","polyfill","ponyfill","ctx","base64map","crypt","rotl","rotr","endian","randomBytes","random","bytesToWords","words","wordsToBytes","bytesToHex","hexToBytes","bytesToBase64","base64","triplet","base64ToBytes","imod4","pow","isBuffer","isSlowBuffer","_isBuffer","encoding","FF","_ff","GG","_gg","HH","_hh","II","_ii","aa","bb","cc","dd","_blocksize","_digestsize","digestbytes","asBytes","asString"],"sourceRoot":""}