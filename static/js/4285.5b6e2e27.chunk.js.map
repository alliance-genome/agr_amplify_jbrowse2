{"version":3,"file":"static/js/4285.5b6e2e27.chunk.js","mappings":"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","sources":["../../../node_modules/@babel/runtime/helpers/asyncToGenerator.js","../../../node_modules/@babel/runtime/helpers/toArray.js","../../../node_modules/@gmod/indexedfasta/esm/bgzipIndexedFasta.js","../../../node_modules/@gmod/indexedfasta/esm/index.js","../../../node_modules/@gmod/indexedfasta/esm/indexedFasta.js","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js"],"sourcesContent":["function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {\n  try {\n    var info = gen[key](arg);\n    var value = info.value;\n  } catch (error) {\n    reject(error);\n    return;\n  }\n\n  if (info.done) {\n    resolve(value);\n  } else {\n    Promise.resolve(value).then(_next, _throw);\n  }\n}\n\nfunction _asyncToGenerator(fn) {\n  return function () {\n    var self = this,\n        args = arguments;\n    return new Promise(function (resolve, reject) {\n      var gen = fn.apply(self, args);\n\n      function _next(value) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value);\n      }\n\n      function _throw(err) {\n        asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err);\n      }\n\n      _next(undefined);\n    });\n  };\n}\n\nmodule.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","var arrayWithHoles = require(\"./arrayWithHoles.js\");\n\nvar iterableToArray = require(\"./iterableToArray.js\");\n\nvar unsupportedIterableToArray = require(\"./unsupportedIterableToArray.js\");\n\nvar nonIterableRest = require(\"./nonIterableRest.js\");\n\nfunction _toArray(arr) {\n  return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();\n}\n\nmodule.exports = _toArray, module.exports.__esModule = true, module.exports[\"default\"] = module.exports;","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst bgzf_filehandle_1 = require(\"@gmod/bgzf-filehandle\");\nconst indexedFasta_1 = __importDefault(require(\"./indexedFasta\"));\nclass BgzipIndexedFasta extends indexedFasta_1.default {\n    constructor({ fasta, path, fai, faiPath, gzi, gziPath, chunkSizeLimit, }) {\n        super({ fasta, path, fai, faiPath, chunkSizeLimit });\n        if (fasta && gzi) {\n            this.fasta = new bgzf_filehandle_1.BgzfFilehandle({\n                filehandle: fasta,\n                gziFilehandle: gzi,\n            });\n        }\n        else if (path && gziPath) {\n            this.fasta = new bgzf_filehandle_1.BgzfFilehandle({ path, gziPath });\n        }\n    }\n}\nexports.default = BgzipIndexedFasta;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BgzipIndexedFasta = exports.IndexedFasta = exports.FetchableSmallFasta = exports.parseSmallFasta = void 0;\nconst object_fromentries_1 = __importDefault(require(\"object.fromentries\"));\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nconst bgzipIndexedFasta_1 = __importDefault(require(\"./bgzipIndexedFasta\"));\nexports.BgzipIndexedFasta = bgzipIndexedFasta_1.default;\nconst indexedFasta_1 = __importDefault(require(\"./indexedFasta\"));\nexports.IndexedFasta = indexedFasta_1.default;\nif (!Object.fromEntries) {\n    // @ts-ignore\n    object_fromentries_1.default.shim();\n}\nfunction parseSmallFasta(text) {\n    return text\n        .split('>')\n        .filter(t => /\\S/.test(t))\n        .map(entryText => {\n        const [defLine, ...seqLines] = entryText.split('\\n');\n        const [id, ...description] = defLine.split(' ');\n        const sequence = seqLines.join('').replace(/\\s/g, '');\n        return {\n            id,\n            description: description.join(' '),\n            sequence,\n        };\n    });\n}\nexports.parseSmallFasta = parseSmallFasta;\n// memoized\nclass FetchableSmallFasta {\n    constructor({ fasta, path }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass fasta or path');\n        }\n        this.data = this.fasta.readFile().then(buffer => {\n            const text = buffer.toString('utf8');\n            return parseSmallFasta(text);\n        });\n    }\n    async fetch(id, start, end) {\n        const data = await this.data;\n        const entry = data.find(iter => iter.id === id);\n        const length = end - start;\n        if (!entry) {\n            throw new Error(`no sequence with id ${id} exists`);\n        }\n        return entry.sequence.substr(start, length);\n    }\n    async getSequenceNames() {\n        const data = await this.data;\n        return data.map(entry => entry.id);\n    }\n}\nexports.FetchableSmallFasta = FetchableSmallFasta;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst generic_filehandle_1 = require(\"generic-filehandle\");\nfunction _faiOffset(idx, pos) {\n    return (idx.offset +\n        idx.lineBytes * Math.floor(pos / idx.lineLength) +\n        (pos % idx.lineLength));\n}\nasync function readFAI(fai, opts) {\n    const text = await fai.readFile(opts);\n    if (!(text && text.length)) {\n        throw new Error('No data read from FASTA index (FAI) file');\n    }\n    let idCounter = 0;\n    let currSeq;\n    const data = text\n        .toString('utf8')\n        .split(/\\r?\\n/)\n        .filter(line => /\\S/.test(line))\n        .map(line => line.split('\\t'))\n        .filter(row => row[0] !== '')\n        .map(row => {\n        if (!currSeq || currSeq.name !== row[0]) {\n            currSeq = { name: row[0], id: idCounter };\n            idCounter += 1;\n        }\n        return {\n            id: currSeq.id,\n            name: row[0],\n            length: +row[1],\n            start: 0,\n            end: +row[1],\n            offset: +row[2],\n            lineLength: +row[3],\n            lineBytes: +row[4],\n        };\n    });\n    return {\n        name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n        id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n    };\n}\nclass IndexedFasta {\n    constructor({ fasta, fai, path, faiPath, chunkSizeLimit = 1000000, }) {\n        if (fasta) {\n            this.fasta = fasta;\n        }\n        else if (path) {\n            this.fasta = new generic_filehandle_1.LocalFile(path);\n        }\n        else {\n            throw new Error('Need to pass filehandle for fasta or path to localfile');\n        }\n        if (fai) {\n            this.fai = fai;\n        }\n        else if (faiPath) {\n            this.fai = new generic_filehandle_1.LocalFile(faiPath);\n        }\n        else if (path) {\n            this.fai = new generic_filehandle_1.LocalFile(`${path}.fai`);\n        }\n        else {\n            throw new Error('Need to pass filehandle for  or path to localfile');\n        }\n        this.chunkSizeLimit = chunkSizeLimit;\n    }\n    async _getIndexes(opts) {\n        if (!this.indexes) {\n            this.indexes = readFAI(this.fai, opts);\n        }\n        return this.indexes;\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceNames(opts) {\n        return Object.keys((await this._getIndexes(opts)).name);\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceSizes(opts) {\n        const returnObject = {};\n        const idx = await this._getIndexes(opts);\n        const vals = Object.values(idx.id);\n        for (let i = 0; i < vals.length; i += 1) {\n            returnObject[vals[i].name] = vals[i].length;\n        }\n        return returnObject;\n    }\n    /**\n     * @returns {array[string]} array of string sequence\n     * names that are present in the index, in which the\n     * array index indicates the sequence ID, and the value\n     * is the sequence name\n     */\n    async getSequenceSize(seqName, opts) {\n        var _a;\n        const idx = await this._getIndexes(opts);\n        return (_a = idx.name[seqName]) === null || _a === void 0 ? void 0 : _a.length;\n    }\n    /**\n     *\n     * @param {string} name\n     * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n     */\n    async hasReferenceSequence(name, opts) {\n        return !!(await this._getIndexes(opts)).name[name];\n    }\n    /**\n     *\n     * @param {number} seqId\n     * @param {number} min\n     * @param {number} max\n     */\n    async getResiduesById(seqId, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts)).id[seqId];\n        if (!indexEntry) {\n            return undefined;\n        }\n        return this._fetchFromIndexEntry(indexEntry, min, max, opts);\n    }\n    /**\n     * @param {string} seqName\n     * @param {number} min\n     * @param {number} max\n     */\n    async getResiduesByName(seqName, min, max, opts) {\n        const indexEntry = (await this._getIndexes(opts)).name[seqName];\n        if (!indexEntry) {\n            return undefined;\n        }\n        return this._fetchFromIndexEntry(indexEntry, min, max, opts);\n    }\n    //alias for getResiduesByName\n    async getSequence(seqName, min, max, opts) {\n        return this.getResiduesByName(seqName, min, max, opts);\n    }\n    async _fetchFromIndexEntry(indexEntry, min = 0, max, opts) {\n        let end = max;\n        if (min < 0) {\n            throw new TypeError('regionStart cannot be less than 0');\n        }\n        if (end === undefined || end > indexEntry.length) {\n            end = indexEntry.length;\n        }\n        if (min >= end) {\n            return '';\n        }\n        const position = _faiOffset(indexEntry, min);\n        const readlen = _faiOffset(indexEntry, end) - position;\n        if (readlen > this.chunkSizeLimit) {\n            throw new Error(`data size of ${readlen.toLocaleString()} bytes exceeded chunk size limit of ${this.chunkSizeLimit.toLocaleString()} bytes`);\n        }\n        const residues = Buffer.allocUnsafe(readlen);\n        await this.fasta.read(residues, 0, readlen, position, opts);\n        return residues.toString('utf8').replace(/\\s+/g, '');\n    }\n}\nexports.default = IndexedFasta;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n"],"names":["asyncGeneratorStep","gen","resolve","reject","_next","_throw","key","arg","info","value","error","done","Promise","then","module","exports","fn","self","this","args","arguments","apply","err","undefined","__esModule","arrayWithHoles","iterableToArray","unsupportedIterableToArray","nonIterableRest","arr","__importDefault","mod","Object","defineProperty","bgzf_filehandle_1","require","BgzipIndexedFasta","fasta","path","fai","faiPath","gzi","gziPath","chunkSizeLimit","BgzfFilehandle","filehandle","gziFilehandle","default","IndexedFasta","FetchableSmallFasta","parseSmallFasta","object_fromentries_1","generic_filehandle_1","bgzipIndexedFasta_1","indexedFasta_1","text","split","filter","t","test","map","entryText","defLine","seqLines","id","description","sequence","join","replace","fromEntries","shim","Error","LocalFile","data","readFile","buffer","toString","start","end","entry","find","iter","length","substr","_faiOffset","idx","pos","offset","lineBytes","Math","floor","lineLength","readFAI","opts","idCounter","line","row","currSeq","name","indexes","_getIndexes","keys","returnObject","vals","values","i","seqName","_a","seqId","min","max","indexEntry","_fetchFromIndexEntry","getResiduesByName","TypeError","position","readlen","toLocaleString","residues","Buffer","allocUnsafe","read","abortcontroller_ponyfill_1","AggregateAbortController_1","AggregateStatusReporter_1","AbortablePromiseCache","fill","cache","get","set","delete","fillCallback","signal","statusCallback","aborter","statusReporter","addCallback","newEntry","promise","message","callback","settled","aborted","addSignal","addEventListener","evict","catch","e","console","has","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","result","next","exception","code","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","size","AggregateStatusReporter","callbacks","currentMessage","forEach","elt","cjs_ponyfill_1","getGlobal","window","global","AbortablePromiseCache_1"],"sourceRoot":""}