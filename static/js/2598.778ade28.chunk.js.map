{"version":3,"file":"static/js/2598.778ade28.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/gff/src/util.ts","../../../node_modules/@gmod/gff/src/parse.ts","../../../node_modules/@gmod/gff/src/api.ts","../../../node_modules/@gmod/gff/src/index.ts"],"sourcesContent":["// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\nexport function unescape(stringVal: string): string {\n  return stringVal.replace(/%([0-9A-Fa-f]{2})/g, (_match, seq) =>\n    String.fromCharCode(parseInt(seq, 16)),\n  )\n}\n\nfunction _escape(regex: RegExp, s: string | number) {\n  return String(s).replace(regex, (ch) => {\n    const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0')\n    return `%${hex}`\n  })\n}\n\n/**\n * Escape a value for use in a GFF3 attribute value.\n *\n * @param rawVal - Raw GFF3 attribute value\n * @returns An escaped string value\n */\nexport function escape(rawVal: string | number): string {\n  return _escape(/[\\n;\\r\\t=%&,\\x00-\\x1f\\x7f-\\xff]/g, rawVal)\n}\n\n/**\n * Escape a value for use in a GFF3 column value.\n *\n * @param rawVal - Raw GFF3 column value\n * @returns An escaped column value\n */\nexport function escapeColumn(rawVal: string | number): string {\n  return _escape(/[\\n\\r\\t%\\x00-\\x1f\\x7f-\\xff]/g, rawVal)\n}\n\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString: string): GFF3Attributes {\n  if (!(attrString && attrString.length) || attrString === '.') return {}\n\n  const attrs: GFF3Attributes = {}\n\n  attrString\n    .replace(/\\r?\\n$/, '')\n    .split(';')\n    .forEach((a) => {\n      const nv = a.split('=', 2)\n      if (!(nv[1] && nv[1].length)) return\n\n      nv[0] = nv[0].trim()\n      let arec = attrs[nv[0].trim()]\n      if (!arec) {\n        arec = []\n        attrs[nv[0]] = arec\n      }\n\n      arec.push(\n        ...nv[1]\n          .split(',')\n          .map((s) => s.trim())\n          .map(unescape),\n      )\n    })\n  return attrs\n}\n\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line: string): GFF3FeatureLine {\n  // split the line into columns and replace '.' with null in each column\n  const f = line.split('\\t').map((a) => (a === '.' || a === '' ? null : a))\n\n  // unescape only the ref, source, and type columns\n  const parsed: GFF3FeatureLine = {\n    seq_id: f[0] && unescape(f[0]),\n    source: f[1] && unescape(f[1]),\n    type: f[2] && unescape(f[2]),\n    start: f[3] === null ? null : parseInt(f[3], 10),\n    end: f[4] === null ? null : parseInt(f[4], 10),\n    score: f[5] === null ? null : parseFloat(f[5]),\n    strand: f[6],\n    phase: f[7],\n    attributes: f[8] === null ? null : parseAttributes(f[8]),\n  }\n  return parsed\n}\n\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(\n  line: string,\n):\n  | GFF3Directive\n  | GFF3SequenceRegionDirective\n  | GFF3GenomeBuildDirective\n  | null {\n  const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line)\n  if (!match) return null\n\n  const [, name] = match\n  let [, , contents] = match\n\n  const parsed: GFF3Directive = { directive: name }\n  if (contents.length) {\n    contents = contents.replace(/\\r?\\n$/, '')\n    parsed.value = contents\n  }\n\n  // do a little additional parsing for sequence-region and genome-build directives\n  if (name === 'sequence-region') {\n    const c = contents.split(/\\s+/, 3)\n    return {\n      ...parsed,\n      seq_id: c[0],\n      start: c[1] && c[1].replace(/\\D/g, ''),\n      end: c[2] && c[2].replace(/\\D/g, ''),\n    } as GFF3SequenceRegionDirective\n  } else if (name === 'genome-build') {\n    const [source, buildName] = contents.split(/\\s+/, 2)\n    return {\n      ...parsed,\n      source,\n      buildName,\n    } as GFF3GenomeBuildDirective\n  }\n\n  return parsed\n}\n\n/**\n * Format an attributes object into a string suitable for the 9th column of GFF3.\n *\n * @param attrs - Attributes\n * @returns GFF3 9th column string\n */\nexport function formatAttributes(attrs: GFF3Attributes): string {\n  const attrOrder: string[] = []\n  Object.entries(attrs).forEach(([tag, val]) => {\n    if (!val) return\n    let valstring\n    if (val.hasOwnProperty('toString')) {\n      valstring = escape(val.toString())\n      // } else if (Array.isArray(val.values)) {\n      //   valstring = val.values.map(escape).join(',')\n    } else if (Array.isArray(val)) {\n      valstring = val.map(escape).join(',')\n    } else {\n      valstring = escape(val)\n    }\n    attrOrder.push(`${escape(tag)}=${valstring}`)\n  })\n  return attrOrder.length ? attrOrder.join(';') : '.'\n}\n\nfunction _formatSingleFeature(\n  f: GFF3FeatureLine | GFF3FeatureLineWithRefs,\n  seenFeature: Record<string, boolean | undefined>,\n) {\n  const attrString =\n    f.attributes === null || f.attributes === undefined\n      ? '.'\n      : formatAttributes(f.attributes)\n\n  const fields = [\n    f.seq_id === null ? '.' : escapeColumn(f.seq_id),\n    f.source === null ? '.' : escapeColumn(f.source),\n    f.type === null ? '.' : escapeColumn(f.type),\n    f.start === null ? '.' : escapeColumn(f.start),\n    f.end === null ? '.' : escapeColumn(f.end),\n    f.score === null ? '.' : escapeColumn(f.score),\n    f.strand === null ? '.' : escapeColumn(f.strand),\n    f.phase === null ? '.' : escapeColumn(f.phase),\n    attrString,\n  ]\n\n  const formattedString = `${fields.join('\\t')}\\n`\n\n  // if we have already output this exact feature, skip it\n  if (seenFeature[formattedString]) {\n    return ''\n  }\n\n  seenFeature[formattedString] = true\n  return formattedString\n}\n\nfunction _formatFeature(\n  feature:\n    | GFF3FeatureLine\n    | GFF3FeatureLineWithRefs\n    | (GFF3FeatureLine | GFF3FeatureLineWithRefs)[],\n  seenFeature: Record<string, boolean | undefined>,\n): string {\n  if (Array.isArray(feature)) {\n    return feature.map((f) => _formatFeature(f, seenFeature)).join('')\n  }\n\n  const strings = [_formatSingleFeature(feature, seenFeature)]\n  if (_isFeatureLineWithRefs(feature)) {\n    strings.push(\n      ...feature.child_features.map((f) => _formatFeature(f, seenFeature)),\n      ...feature.derived_features.map((f) => _formatFeature(f, seenFeature)),\n    )\n  }\n  return strings.join('')\n}\n\n/**\n * Format a feature object or array of feature objects into one or more lines of\n * GFF3.\n *\n * @param featureOrFeatures - A feature object or array of feature objects\n * @returns A string of one or more GFF3 lines\n */\nexport function formatFeature(\n  featureOrFeatures:\n    | GFF3FeatureLine\n    | GFF3FeatureLineWithRefs\n    | (GFF3FeatureLine | GFF3FeatureLineWithRefs)[],\n): string {\n  const seen = {}\n  return _formatFeature(featureOrFeatures, seen)\n}\n\n/**\n * Format a directive into a line of GFF3.\n *\n * @param directive - A directive object\n * @returns A directive line string\n */\nexport function formatDirective(directive: GFF3Directive): string {\n  let str = `##${directive.directive}`\n  if (directive.value) str += ` ${directive.value}`\n  str += '\\n'\n  return str\n}\n\n/**\n * Format a comment into a GFF3 comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param comment - A comment object\n * @returns A comment line string\n */\nexport function formatComment(comment: GFF3Comment): string {\n  return `# ${comment.comment}\\n`\n}\n\n/**\n * Format a sequence object as FASTA\n *\n * @param seq - A sequence object\n * @returns Formatted single FASTA sequence string\n */\nexport function formatSequence(seq: GFF3Sequence): string {\n  return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${\n    seq.sequence\n  }\\n`\n}\n\n/**\n * Format a directive, comment, sequence, or feature, or array of such items,\n * into one or more lines of GFF3.\n *\n * @param itemOrItems - A comment, sequence, or feature, or array of such items\n * @returns A formatted string or array of strings\n */\nexport function formatItem(\n  itemOrItems:\n    | GFF3FeatureLineWithRefs\n    | GFF3Directive\n    | GFF3Comment\n    | GFF3Sequence\n    | (GFF3FeatureLineWithRefs | GFF3Directive | GFF3Comment | GFF3Sequence)[],\n): string | string[] {\n  function formatSingleItem(\n    item: GFF3FeatureLineWithRefs | GFF3Directive | GFF3Comment | GFF3Sequence,\n  ) {\n    if ('attributes' in item) return formatFeature(item)\n    if ('directive' in item) return formatDirective(item)\n    if ('sequence' in item) return formatSequence(item)\n    if ('comment' in item) return formatComment(item)\n    return '# (invalid item found during format)\\n'\n  }\n\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.map(formatSingleItem)\n  }\n  return formatSingleItem(itemOrItems)\n}\n\n/** A record of GFF3 attribute identifiers and the values of those identifiers */\nexport type GFF3Attributes = Record<string, string[] | undefined>\n\n/** A representation of a single line of a GFF3 file */\nexport interface GFF3FeatureLine {\n  /** The ID of the landmark used to establish the coordinate system for the current feature */\n  seq_id: string | null\n  /** A free text qualifier intended to describe the algorithm or operating procedure that generated this feature */\n  source: string | null\n  /** The type of the feature */\n  type: string | null\n  /** The start coordinates of the feature */\n  start: number | null\n  /** The end coordinates of the feature */\n  end: number | null\n  /** The score of the feature */\n  score: number | null\n  /** The strand of the feature */\n  strand: string | null\n  /** For features of type \"CDS\", the phase indicates where the next codon begins relative to the 5' end of the current CDS feature */\n  phase: string | null\n  /** Feature attributes */\n  attributes: GFF3Attributes | null\n}\n\n/**\n * A GFF3 Feature line that includes references to other features defined in\n * their \"Parent\" or \"Derives_from\" attributes\n */\nexport interface GFF3FeatureLineWithRefs extends GFF3FeatureLine {\n  /** An array of child features */\n  child_features: GFF3Feature[]\n  /** An array of features derived from this feature */\n  derived_features: GFF3Feature[]\n}\n\nfunction _isFeatureLineWithRefs(\n  featureLine: GFF3FeatureLine | GFF3FeatureLineWithRefs,\n): featureLine is GFF3FeatureLineWithRefs {\n  return (\n    (featureLine as GFF3FeatureLineWithRefs).child_features !== undefined &&\n    (featureLine as GFF3FeatureLineWithRefs).derived_features !== undefined\n  )\n}\n\n/**\n * A GFF3 feature, which may include multiple individual feature lines\n */\nexport type GFF3Feature = GFF3FeatureLineWithRefs[]\n\n/** A GFF3 directive */\nexport interface GFF3Directive {\n  /** The name of the directive */\n  directive: string\n  /** The string value of the directive */\n  value?: string\n}\n\n/** A GFF3 sequence-region directive */\nexport interface GFF3SequenceRegionDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The sequence ID parsed from the directive */\n  seq_id: string\n  /** The sequence start parsed from the directive */\n  start: string\n  /** The sequence end parsed from the directive */\n  end: string\n}\n\n/** A GFF3 genome-build directive */\nexport interface GFF3GenomeBuildDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The genome build source parsed from the directive */\n  source: string\n  /** The genome build name parsed from the directive */\n  buildName: string\n}\n\n/** A GFF3 comment */\nexport interface GFF3Comment {\n  /** The text of the comment */\n  comment: string\n}\n\n/** A GFF3 FASTA single sequence */\nexport interface GFF3Sequence {\n  /** The ID of the sequence */\n  id: string\n  /** The description of the sequence */\n  description?: string\n  /** The sequence */\n  sequence: string\n}\n\nexport type GFF3Item = GFF3Feature | GFF3Directive | GFF3Comment | GFF3Sequence\n","import * as GFF3 from './util'\n\nconst containerAttributes = {\n  Parent: 'child_features' as const,\n  Derives_from: 'derived_features' as const,\n}\n\nexport class FASTAParser {\n  seqCallback: (sequence: GFF3.GFF3Sequence) => void\n  currentSequence:\n    | { id: string; sequence: string; description?: string }\n    | undefined\n\n  constructor(seqCallback: (sequence: GFF3.GFF3Sequence) => void) {\n    this.seqCallback = seqCallback\n    this.currentSequence = undefined\n  }\n\n  addLine(line: string): void {\n    const defMatch = /^>\\s*(\\S+)\\s*(.*)/.exec(line)\n    if (defMatch) {\n      this._flush()\n      this.currentSequence = { id: defMatch[1], sequence: '' }\n      if (defMatch[2]) this.currentSequence.description = defMatch[2].trim()\n    } else if (this.currentSequence && /\\S/.test(line)) {\n      this.currentSequence.sequence += line.replace(/\\s/g, '')\n    }\n  }\n\n  private _flush() {\n    if (this.currentSequence) this.seqCallback(this.currentSequence)\n  }\n\n  finish(): void {\n    this._flush()\n  }\n}\n\ninterface ParserArgs {\n  featureCallback?(feature: GFF3.GFF3Feature): void\n  endCallback?(): void\n  commentCallback?(comment: GFF3.GFF3Comment): void\n  errorCallback?(error: string): void\n  directiveCallback?(directive: GFF3.GFF3Directive): void\n  sequenceCallback?(sequence: GFF3.GFF3Sequence): void\n  bufferSize?: number\n  disableDerivesFromReferences?: boolean\n}\n\ninterface References {\n  Parent: GFF3.GFF3Feature[]\n  Derives_from: GFF3.GFF3Feature[]\n}\n\nexport default class Parser {\n  featureCallback: (feature: GFF3.GFF3Feature) => void\n  endCallback: () => void\n  commentCallback: (comment: GFF3.GFF3Comment) => void\n  errorCallback: (error: string) => void\n  disableDerivesFromReferences: boolean\n  directiveCallback: (directive: GFF3.GFF3Directive) => void\n  sequenceCallback: (sequence: GFF3.GFF3Sequence) => void\n  bufferSize: number\n  fastaParser: FASTAParser | undefined = undefined\n  // if this is true, the parser ignores the\n  // rest of the lines in the file.  currently\n  // set when the file switches over to FASTA\n  eof = false\n  lineNumber = 0\n  // features that we have to keep on hand for now because they\n  // might be referenced by something else\n  private _underConstructionTopLevel: GFF3.GFF3Feature[] = []\n  // index of the above by ID\n  private _underConstructionById: Record<string, GFF3.GFF3Feature | undefined> =\n    {}\n  private _completedReferences: Record<\n    string,\n    Record<string, boolean | undefined> | undefined\n  > = {}\n  // features that reference something we have not seen yet\n  // structured as:\n  // {  'some_id' : {\n  //     'Parent' : [ orphans that have a Parent attr referencing it ],\n  //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n  //    }\n  // }\n  private _underConstructionOrphans: Record<string, References | undefined> = {}\n\n  constructor(args: ParserArgs) {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const nullFunc = () => {}\n\n    this.featureCallback = args.featureCallback || nullFunc\n    this.endCallback = args.endCallback || nullFunc\n    this.commentCallback = args.commentCallback || nullFunc\n    this.errorCallback = args.errorCallback || nullFunc\n    this.directiveCallback = args.directiveCallback || nullFunc\n    this.sequenceCallback = args.sequenceCallback || nullFunc\n    this.disableDerivesFromReferences =\n      args.disableDerivesFromReferences || false\n\n    // number of lines to buffer\n    this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize\n  }\n\n  addLine(line: string): void {\n    // if we have transitioned to a fasta section, just delegate to that parser\n    if (this.fastaParser) {\n      this.fastaParser.addLine(line)\n      return\n    }\n    if (this.eof) {\n      // otherwise, if we are done, ignore this line\n      return\n    }\n\n    this.lineNumber += 1\n\n    if (/^\\s*[^#\\s>]/.test(line)) {\n      // feature line, most common case\n      this._bufferLine(line)\n      return\n    }\n\n    const match = /^\\s*(#+)(.*)/.exec(line)\n    if (match) {\n      // directive or comment\n      const [, hashsigns] = match\n      let [, , contents] = match\n\n      if (hashsigns.length === 3) {\n        // sync directive, all forward-references are resolved.\n        this._emitAllUnderConstructionFeatures()\n      } else if (hashsigns.length === 2) {\n        const directive = GFF3.parseDirective(line)\n        if (directive) {\n          if (directive.directive === 'FASTA') {\n            this._emitAllUnderConstructionFeatures()\n            this.eof = true\n            this.fastaParser = new FASTAParser(this.sequenceCallback)\n          } else {\n            this._emitItem(directive)\n          }\n        }\n      } else {\n        contents = contents.replace(/\\s*/, '')\n        this._emitItem({ comment: contents })\n      }\n    } else if (/^\\s*$/.test(line)) {\n      // blank line, do nothing\n    } else if (/^\\s*>/.test(line)) {\n      // implicit beginning of a FASTA section\n      this._emitAllUnderConstructionFeatures()\n      this.eof = true\n      this.fastaParser = new FASTAParser(this.sequenceCallback)\n      this.fastaParser.addLine(line)\n    } else {\n      // it's a parse error\n      const errLine = line.replace(/\\r?\\n?$/g, '')\n      throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`)\n    }\n  }\n\n  finish(): void {\n    this._emitAllUnderConstructionFeatures()\n    if (this.fastaParser) this.fastaParser.finish()\n    this.endCallback()\n  }\n\n  private _emitItem(\n    i: GFF3.GFF3Feature | GFF3.GFF3Directive | GFF3.GFF3Comment,\n  ) {\n    if (Array.isArray(i)) this.featureCallback(i)\n    else if ('directive' in i) this.directiveCallback(i)\n    else if ('comment' in i) this.commentCallback(i)\n  }\n\n  private _enforceBufferSizeLimit(additionalItemCount = 0) {\n    const _unbufferItem = (item?: GFF3.GFF3Feature) => {\n      if (\n        item &&\n        Array.isArray(item) &&\n        item[0].attributes &&\n        item[0].attributes.ID &&\n        item[0].attributes.ID[0]\n      ) {\n        const ids = item[0].attributes.ID\n        ids.forEach((id) => {\n          delete this._underConstructionById[id]\n          delete this._completedReferences[id]\n        })\n        item.forEach((i) => {\n          if (i.child_features)\n            i.child_features.forEach((c) => _unbufferItem(c))\n          if (i.derived_features)\n            i.derived_features.forEach((d) => _unbufferItem(d))\n        })\n      }\n    }\n\n    while (\n      this._underConstructionTopLevel.length + additionalItemCount >\n      this.bufferSize\n    ) {\n      const item = this._underConstructionTopLevel.shift()\n      if (item) {\n        this._emitItem(item)\n        _unbufferItem(item)\n      }\n    }\n  }\n\n  /**\n   * return all under-construction features, called when we know\n   * there will be no additional data to attach to them\n   */\n  private _emitAllUnderConstructionFeatures() {\n    this._underConstructionTopLevel.forEach(this._emitItem.bind(this))\n\n    this._underConstructionTopLevel = []\n    this._underConstructionById = {}\n    this._completedReferences = {}\n\n    // if we have any orphans hanging around still, this is a\n    // problem. die with a parse error\n    if (Array.from(Object.values(this._underConstructionOrphans)).length) {\n      throw new Error(\n        `some features reference other features that do not exist in the file (or in the same '###' scope). ${Object.keys(\n          this._underConstructionOrphans,\n        )}`,\n      )\n    }\n  }\n\n  // do the right thing with a newly-parsed feature line\n  private _bufferLine(line: string) {\n    const rawFeatureLine = GFF3.parseFeature(line)\n    const featureLine: GFF3.GFF3FeatureLineWithRefs = {\n      ...rawFeatureLine,\n      child_features: [],\n      derived_features: [],\n    }\n    // featureLine._lineNumber = this.lineNumber //< debugging aid\n\n    // NOTE: a feature is an arrayref of one or more feature lines.\n    const ids = featureLine.attributes?.ID || []\n    const parents = featureLine.attributes?.Parent || []\n    const derives = this.disableDerivesFromReferences\n      ? []\n      : featureLine.attributes?.Derives_from || []\n\n    if (!ids.length && !parents.length && !derives.length) {\n      // if it has no IDs and does not refer to anything, we can just\n      // output it\n      this._emitItem([featureLine])\n      return\n    }\n\n    let feature: GFF3.GFF3Feature | undefined = undefined\n    ids.forEach((id) => {\n      const existing = this._underConstructionById[id]\n      if (existing) {\n        // another location of the same feature\n        if (existing[existing.length - 1].type !== featureLine.type) {\n          this._parseError(\n            `multi-line feature \"${id}\" has inconsistent types: \"${\n              featureLine.type\n            }\", \"${existing[existing.length - 1].type}\"`,\n          )\n        }\n        existing.push(featureLine)\n        feature = existing\n      } else {\n        // haven't seen it yet, so buffer it so we can attach\n        // child features to it\n        feature = [featureLine]\n\n        this._enforceBufferSizeLimit(1)\n        if (!parents.length && !derives.length) {\n          this._underConstructionTopLevel.push(feature)\n        }\n        this._underConstructionById[id] = feature\n\n        // see if we have anything buffered that refers to it\n        this._resolveReferencesTo(feature, id)\n      }\n    })\n\n    // try to resolve all its references\n    this._resolveReferencesFrom(\n      feature || [featureLine],\n      { Parent: parents, Derives_from: derives },\n      ids,\n    )\n  }\n\n  private _resolveReferencesTo(feature: GFF3.GFF3Feature, id: string) {\n    const references = this._underConstructionOrphans[id]\n    //   references is of the form\n    //   {\n    //     'Parent' : [ orphans that have a Parent attr referencing this feature ],\n    //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],\n    //    }\n    if (!references) return\n    feature.forEach((loc) => {\n      loc.child_features.push(...references.Parent)\n    })\n    feature.forEach((loc) => {\n      loc.derived_features.push(...references.Derives_from)\n    })\n    delete this._underConstructionOrphans[id]\n  }\n\n  private _parseError(message: string) {\n    this.eof = true\n    this.errorCallback(`${this.lineNumber}: ${message}`)\n  }\n\n  private _resolveReferencesFrom(\n    feature: GFF3.GFF3Feature,\n    references: { Parent: string[]; Derives_from: string[] },\n    ids: string[],\n  ) {\n    // this is all a bit more awkward in javascript than it was in perl\n    function postSet(\n      obj: Record<string, Record<string, boolean | undefined> | undefined>,\n      slot1: string,\n      slot2: string,\n    ) {\n      let subObj = obj[slot1]\n      if (!subObj) {\n        subObj = {}\n        obj[slot1] = subObj\n      }\n      const returnVal = subObj[slot2] || false\n      subObj[slot2] = true\n      return returnVal\n    }\n\n    references.Parent.forEach((toId) => {\n      const otherFeature = this._underConstructionById[toId]\n      if (otherFeature) {\n        const pname = containerAttributes.Parent\n        if (\n          !ids.filter((id) =>\n            postSet(this._completedReferences, id, `Parent,${toId}`),\n          ).length\n        ) {\n          otherFeature.forEach((location) => {\n            location[pname].push(feature)\n          })\n        }\n      } else {\n        let ref = this._underConstructionOrphans[toId]\n        if (!ref) {\n          ref = {\n            Parent: [],\n            Derives_from: [],\n          }\n          this._underConstructionOrphans[toId] = ref\n        }\n        ref.Parent.push(feature)\n      }\n    })\n\n    references.Derives_from.forEach((toId) => {\n      const otherFeature = this._underConstructionById[toId]\n      if (otherFeature) {\n        const pname = containerAttributes.Derives_from\n        if (\n          !ids.filter((id) =>\n            postSet(this._completedReferences, id, `Derives_from,${toId}`),\n          ).length\n        ) {\n          otherFeature.forEach((location) => {\n            location[pname].push(feature)\n          })\n        }\n      } else {\n        let ref = this._underConstructionOrphans[toId]\n        if (!ref) {\n          ref = {\n            Parent: [],\n            Derives_from: [],\n          }\n          this._underConstructionOrphans[toId] = ref\n        }\n        ref.Derives_from.push(feature)\n      }\n    })\n  }\n}\n","import { Transform, TransformCallback, Readable, Writable } from 'stream'\nimport { StringDecoder as Decoder } from 'string_decoder'\n\nimport Parser from './parse'\nimport {\n  formatItem,\n  formatSequence,\n  GFF3Comment,\n  GFF3Directive,\n  GFF3Feature,\n  GFF3FeatureLine,\n  GFF3FeatureLineWithRefs,\n  GFF3Sequence,\n  GFF3Item,\n} from './util'\n\nexport type {\n  GFF3Comment,\n  GFF3Directive,\n  GFF3Feature,\n  GFF3FeatureLine,\n  GFF3FeatureLineWithRefs,\n  GFF3Sequence,\n  GFF3Item,\n}\n\n/** Parser options */\nexport interface ParseOptions {\n  /** Whether to resolve references to derives from features */\n  disableDerivesFromReferences?: boolean\n  /** Text encoding of the input GFF3. default 'utf8' */\n  encoding?: BufferEncoding\n  /** Whether to parse features, default true */\n  parseFeatures?: boolean\n  /** Whether to parse directives, default false */\n  parseDirectives?: boolean\n  /** Whether to parse comments, default false */\n  parseComments?: boolean\n  /** Whether to parse sequences, default true */\n  parseSequences?: boolean\n  /**\n   * Parse all features, directives, comments, and sequences. Overrides other\n   * parsing options. Default false.\n   */\n  parseAll?: boolean\n  /** Maximum number of GFF3 lines to buffer, default 1000 */\n  bufferSize?: number\n}\n\ntype ParseOptionsProcessed = Required<Omit<ParseOptions, 'parseAll'>>\n\n// call a callback on the next process tick if running in\n// an environment that supports it\nfunction _callback(callback: TransformCallback) {\n  if (process && process.nextTick) process.nextTick(callback)\n  else callback()\n}\n\n// shared arg processing for the parse routines\nfunction _processParseOptions(options: ParseOptions): ParseOptionsProcessed {\n  const out = {\n    encoding: 'utf8' as const,\n    parseFeatures: true,\n    parseDirectives: false,\n    parseSequences: true,\n    parseComments: false,\n    bufferSize: 1000,\n    disableDerivesFromReferences: false,\n    ...options,\n  }\n\n  if (options.parseAll) {\n    out.parseFeatures = true\n    out.parseDirectives = true\n    out.parseComments = true\n    out.parseSequences = true\n  }\n\n  return out\n}\n\nclass GFFTransform extends Transform {\n  encoding: BufferEncoding\n  decoder: Decoder\n  textBuffer = ''\n  parser: Parser\n\n  constructor(inputOptions: ParseOptions = {}) {\n    super({ objectMode: true })\n    const options = _processParseOptions(inputOptions)\n\n    this.encoding = inputOptions.encoding || 'utf8'\n\n    this.decoder = new Decoder()\n\n    const push = this.push.bind(this)\n    this.parser = new Parser({\n      featureCallback: options.parseFeatures ? push : undefined,\n      directiveCallback: options.parseDirectives ? push : undefined,\n      commentCallback: options.parseComments ? push : undefined,\n      sequenceCallback: options.parseSequences ? push : undefined,\n      errorCallback: (err) => this.emit('error', err),\n      bufferSize: options.bufferSize,\n      disableDerivesFromReferences: options.disableDerivesFromReferences,\n    })\n  }\n\n  private _addLine(data: string | undefined) {\n    if (data) {\n      this.parser.addLine(data)\n    }\n  }\n\n  private _nextText(buffer: string) {\n    const pieces = (this.textBuffer + buffer).split(/\\r?\\n/)\n    this.textBuffer = pieces.pop() || ''\n\n    pieces.forEach((piece) => this._addLine(piece))\n  }\n\n  _transform(\n    chunk: Buffer,\n    _encoding: BufferEncoding,\n    callback: TransformCallback,\n  ) {\n    this._nextText(this.decoder.write(chunk))\n    _callback(callback)\n  }\n\n  _flush(callback: TransformCallback) {\n    if (this.decoder.end) this._nextText(this.decoder.end())\n    if (this.textBuffer != null) this._addLine(this.textBuffer)\n    this.parser.finish()\n    _callback(callback)\n  }\n}\n\n/**\n * Parse a stream of text data into a stream of feature, directive, comment,\n * an sequence objects.\n *\n * @param options - Parsing options\n * @returns stream (in objectMode) of parsed items\n */\nexport function parseStream(options: ParseOptions = {}): GFFTransform {\n  return new GFFTransform(options)\n}\n\n/**\n * Synchronously parse a string containing GFF3 and return an array of the\n * parsed items.\n *\n * @param str - GFF3 string\n * @param inputOptions - Parsing options\n * @returns array of parsed features, directives, comments and/or sequences\n */\nexport function parseStringSync(\n  str: string,\n  inputOptions?:\n    | {\n        disableDerivesFromReferences?: boolean\n        encoding?: BufferEncoding\n        bufferSize?: number\n      }\n    | undefined,\n): (GFF3Feature | GFF3Sequence)[]\nexport function parseStringSync<T extends boolean>(\n  str: string,\n  inputOptions: {\n    parseAll?: T\n    disableDerivesFromReferences?: boolean\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): T extends true ? GFF3Item[] : never\nexport function parseStringSync<F extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true ? (GFF3Feature | GFF3Sequence)[] : GFF3Sequence[]\nexport function parseStringSync<D extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseDirectives: D\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): D extends true\n  ? (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n  : (GFF3Feature | GFF3Sequence)[]\nexport function parseStringSync<C extends boolean>(\n  str: string,\n  inputOptions: {\n    parseComments: C\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): C extends true\n  ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n  : (GFF3Feature | GFF3Sequence)[]\nexport function parseStringSync<S extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): S extends true ? (GFF3Feature | GFF3Sequence)[] : GFF3Feature[]\nexport function parseStringSync<F extends boolean, D extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseDirectives: D\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? D extends true\n    ? (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Sequence)[]\n  : D extends true\n  ? (GFF3Directive | GFF3Sequence)[]\n  : GFF3Sequence[]\nexport function parseStringSync<F extends boolean, C extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseComments: C\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? C extends true\n    ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Sequence)[]\n  : C extends true\n  ? (GFF3Comment | GFF3Sequence)[]\n  : GFF3Sequence[]\nexport function parseStringSync<F extends boolean, S extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? S extends true\n    ? (GFF3Feature | GFF3Sequence)[]\n    : GFF3Feature[]\n  : S extends true\n  ? GFF3Sequence[]\n  : []\nexport function parseStringSync<D extends boolean, C extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseDirectives: D\n    parseComments: C\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): D extends true\n  ? C extends true\n    ? (GFF3Feature | GFF3Directive | GFF3Comment | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n  : C extends true\n  ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n  : (GFF3Feature | GFF3Sequence)[]\nexport function parseStringSync<D extends boolean, S extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseDirectives: D\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): D extends true\n  ? S extends true\n    ? (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Directive)[]\n  : S extends true\n  ? (GFF3Feature | GFF3Sequence)[]\n  : GFF3Feature[]\nexport function parseStringSync<C extends boolean, S extends boolean>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseComments: C\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): C extends true\n  ? S extends true\n    ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Comment)[]\n  : S extends true\n  ? (GFF3Feature | GFF3Sequence)[]\n  : GFF3Feature[]\nexport function parseStringSync<\n  F extends boolean,\n  D extends boolean,\n  C extends boolean,\n>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseDirectives: D\n    parseComments: C\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? D extends true\n    ? C extends true\n      ? GFF3Item[]\n      : (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n    : C extends true\n    ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Sequence)[]\n  : D extends true\n  ? C extends true\n    ? (GFF3Directive | GFF3Comment | GFF3Sequence)[]\n    : (GFF3Directive | GFF3Sequence)[]\n  : C extends true\n  ? (GFF3Comment | GFF3Sequence)[]\n  : GFF3Sequence[]\nexport function parseStringSync<\n  F extends boolean,\n  D extends boolean,\n  S extends boolean,\n>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseDirectives: D\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? D extends true\n    ? S extends true\n      ? (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n      : (GFF3Feature | GFF3Directive)[]\n    : S extends true\n    ? (GFF3Feature | GFF3Sequence)[]\n    : GFF3Feature[]\n  : D extends true\n  ? S extends true\n    ? (GFF3Directive | GFF3Sequence)[]\n    : GFF3Directive[]\n  : S extends true\n  ? GFF3Sequence[]\n  : []\nexport function parseStringSync<\n  F extends boolean,\n  C extends boolean,\n  S extends boolean,\n>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseComments: C\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? C extends true\n    ? S extends true\n      ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n      : (GFF3Feature | GFF3Comment)[]\n    : S extends true\n    ? (GFF3Feature | GFF3Sequence)[]\n    : GFF3Feature[]\n  : C extends true\n  ? S extends true\n    ? (GFF3Comment | GFF3Sequence)[]\n    : GFF3Comment[]\n  : S extends true\n  ? GFF3Sequence[]\n  : []\nexport function parseStringSync<\n  D extends boolean,\n  C extends boolean,\n  S extends boolean,\n>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: D\n    parseComments: C\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): D extends true\n  ? C extends true\n    ? S extends true\n      ? GFF3Item[]\n      : (GFF3Feature | GFF3Directive | GFF3Comment)[]\n    : S extends true\n    ? (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Directive)[]\n  : C extends true\n  ? S extends true\n    ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n    : (GFF3Feature | GFF3Comment)[]\n  : S extends true\n  ? (GFF3Feature | GFF3Sequence)[]\n  : GFF3Feature[]\nexport function parseStringSync<\n  F extends boolean,\n  D extends boolean,\n  C extends boolean,\n  S extends boolean,\n>(\n  str: string,\n  inputOptions: {\n    disableDerivesFromReferences?: boolean\n    parseFeatures: F\n    parseDirectives: D\n    parseComments: C\n    parseSequences: S\n    encoding?: BufferEncoding\n    bufferSize?: number\n  },\n): F extends true\n  ? D extends true\n    ? C extends true\n      ? S extends true\n        ? GFF3Item[]\n        : (GFF3Feature | GFF3Directive | GFF3Comment)[]\n      : S extends true\n      ? (GFF3Feature | GFF3Directive | GFF3Sequence)[]\n      : (GFF3Feature | GFF3Directive)[]\n    : C extends true\n    ? S extends true\n      ? (GFF3Feature | GFF3Comment | GFF3Sequence)[]\n      : (GFF3Feature | GFF3Comment)[]\n    : S extends true\n    ? (GFF3Feature | GFF3Sequence)[]\n    : GFF3Feature[]\n  : D extends true\n  ? C extends true\n    ? S extends true\n      ? (GFF3Directive | GFF3Comment | GFF3Sequence)[]\n      : (GFF3Directive | GFF3Comment)[]\n    : S extends true\n    ? (GFF3Directive | GFF3Sequence)[]\n    : GFF3Directive[]\n  : C extends true\n  ? S extends true\n    ? (GFF3Comment | GFF3Sequence)[]\n    : GFF3Comment[]\n  : S extends true\n  ? GFF3Sequence[]\n  : []\nexport function parseStringSync(\n  str: string,\n  inputOptions: ParseOptions = {},\n): GFF3Item[] {\n  if (!str) return []\n\n  const options = _processParseOptions(inputOptions)\n\n  const items: GFF3Item[] = []\n  const push = items.push.bind(items)\n\n  const parser = new Parser({\n    featureCallback: options.parseFeatures ? push : undefined,\n    directiveCallback: options.parseDirectives ? push : undefined,\n    commentCallback: options.parseComments ? push : undefined,\n    sequenceCallback: options.parseSequences ? push : undefined,\n    disableDerivesFromReferences: options.disableDerivesFromReferences || false,\n    bufferSize: Infinity,\n    errorCallback: (err) => {\n      throw err\n    },\n  })\n\n  str.split(/\\r?\\n/).forEach(parser.addLine.bind(parser))\n  parser.finish()\n\n  return items\n}\n\n/**\n * Format an array of GFF3 items (features,directives,comments) into string of\n * GFF3. Does not insert synchronization (###) marks.\n *\n * @param items - Array of features, directives, comments and/or sequences\n * @returns the formatted GFF3\n */\nexport function formatSync(items: GFF3Item[]): string {\n  // sort items into seq and other\n  const other: (GFF3Feature | GFF3Directive | GFF3Comment)[] = []\n  const sequences: GFF3Sequence[] = []\n  items.forEach((i) => {\n    if ('sequence' in i) sequences.push(i)\n    else other.push(i)\n  })\n  let str = other.map(formatItem).join('')\n  if (sequences.length) {\n    str += '##FASTA\\n'\n    str += sequences.map(formatSequence).join('')\n  }\n  return str\n}\n\ninterface FormatOptions {\n  minSyncLines?: number\n  insertVersionDirective?: boolean\n  encoding?: BufferEncoding\n}\n\nclass FormattingTransform extends Transform {\n  linesSinceLastSyncMark = 0\n  haveWeEmittedData = false\n  fastaMode = false\n  minLinesBetweenSyncMarks: number\n  insertVersionDirective: boolean\n  constructor(options: FormatOptions = {}) {\n    super(Object.assign(options, { objectMode: true }))\n    this.minLinesBetweenSyncMarks = options.minSyncLines || 100\n    this.insertVersionDirective = options.insertVersionDirective || false\n  }\n\n  _transform(\n    chunk: GFF3Item[],\n    _encoding: BufferEncoding,\n    callback: TransformCallback,\n  ) {\n    // if we have not emitted anything yet, and this first\n    // chunk is not a gff-version directive, emit one\n    let str\n    if (!this.haveWeEmittedData && this.insertVersionDirective) {\n      const thisChunk = Array.isArray(chunk) ? chunk[0] : chunk\n      if ('directive' in thisChunk) {\n        if (thisChunk.directive !== 'gff-version') {\n          this.push('##gff-version 3\\n')\n        }\n      }\n    }\n\n    // if it's a sequence chunk coming down, emit a FASTA directive and\n    // change to FASTA mode\n    if ('sequence' in chunk && !this.fastaMode) {\n      this.push('##FASTA\\n')\n      this.fastaMode = true\n    }\n\n    if (Array.isArray(chunk)) str = chunk.map(formatItem).join('')\n    else str = formatItem(chunk)\n\n    this.push(str)\n\n    if (this.linesSinceLastSyncMark >= this.minLinesBetweenSyncMarks) {\n      this.push('###\\n')\n      this.linesSinceLastSyncMark = 0\n    } else {\n      // count the number of newlines in this chunk\n      let count = 0\n      for (let i = 0; i < str.length; i += 1) {\n        if (str[i] === '\\n') count += 1\n      }\n      this.linesSinceLastSyncMark += count\n    }\n\n    this.haveWeEmittedData = true\n    _callback(callback)\n  }\n}\n\n/**\n * Format a stream of features, directives, comments and/or sequences into a\n * stream of GFF3 text.\n *\n * Inserts synchronization (###) marks automatically.\n *\n * @param options - parser options\n */\nexport function formatStream(options: FormatOptions = {}): FormattingTransform {\n  return new FormattingTransform(options)\n}\n\n/**\n * Format a stream of features, directives, comments and/or sequences into a\n * GFF3 file and write it to the filesystem.\n\n * Inserts synchronization (###) marks and a ##gff-version\n * directive automatically (if one is not already present).\n *\n * @param stream - the stream to write to the file\n * @param filename - the file path to write to\n * @param options - parser options\n * @returns promise for null that resolves when the stream has been written\n */\nexport function formatFile(\n  stream: Readable,\n  writeStream: Writable,\n  options: FormatOptions = {},\n): Promise<null> {\n  const newOptions = {\n    insertVersionDirective: true,\n    ...options,\n  }\n\n  return new Promise((resolve, reject) => {\n    stream\n      .pipe(new FormattingTransform(newOptions))\n      .on('end', () => resolve(null))\n      .on('error', reject)\n      .pipe(writeStream)\n  })\n}\n","import {\n  parseStream,\n  parseStringSync,\n  formatSync,\n  formatStream,\n  formatFile,\n  GFF3Comment,\n  GFF3Directive,\n  GFF3Feature,\n  GFF3FeatureLine,\n  GFF3FeatureLineWithRefs,\n  GFF3Sequence,\n  GFF3Item,\n} from './api'\n\nimport * as util from './util'\n\nexport default {\n  parseStream,\n  parseStringSync,\n  formatSync,\n  formatStream,\n  formatFile,\n  util,\n}\n\nexport type {\n  GFF3Comment,\n  GFF3Directive,\n  GFF3Feature,\n  GFF3FeatureLine,\n  GFF3FeatureLineWithRefs,\n  GFF3Sequence,\n  GFF3Item,\n}\n"],"names":["unescape","stringVal","replace","_match","seq","String","fromCharCode","parseInt","_escape","regex","s","ch","hex","charCodeAt","toString","toUpperCase","padStart","concat","escape","rawVal","escapeColumn","parseAttributes","attrString","length","attrs","split","forEach","a","_arec","nv","trim","arec","push","apply","_toConsumableArray","map","parseFeature","line","f","seq_id","source","type","start","end","score","parseFloat","strand","phase","attributes","parseDirective","match","exec","name","_slicedToArray","contents","parsed","directive","value","c","_objectSpread","_contents$split","_contents$split2","buildName","formatAttributes","attrOrder","Object","entries","_ref","valstring","_ref2","tag","val","hasOwnProperty","Array","isArray","join","_formatSingleFeature","seenFeature","undefined","fields","formattedString","_formatFeature","feature","featureLine","strings","child_features","derived_features","formatFeature","featureOrFeatures","formatDirective","str","formatComment","comment","formatSequence","id","description","sequence","formatItem","itemOrItems","formatSingleItem","item","containerAttributes","FASTAParser","seqCallback","_classCallCheck","this","currentSequence","_createClass","key","defMatch","_flush","test","Parser","args","fastaParser","eof","lineNumber","_underConstructionTopLevel","_underConstructionById","_completedReferences","_underConstructionOrphans","nullFunc","featureCallback","endCallback","commentCallback","errorCallback","directiveCallback","sequenceCallback","disableDerivesFromReferences","bufferSize","addLine","_bufferLine","hashsigns","_emitAllUnderConstructionFeatures","GFF3","_emitItem","errLine","Error","finish","i","_this","additionalItemCount","arguments","_unbufferItem","ID","d","shift","bind","from","values","keys","_this2","rawFeatureLine","ids","_a","parents","_b","Parent","derives","_c","Derives_from","existing","_parseError","_enforceBufferSizeLimit","_resolveReferencesTo","_resolveReferencesFrom","references","loc","_loc$child_features","_loc$derived_features","message","_this3","postSet","obj","slot1","slot2","subObj","returnVal","toId","otherFeature","pname","filter","location","ref","_callback","callback","process","nextTick","_processParseOptions","options","out","encoding","parseFeatures","parseDirectives","parseSequences","parseComments","parseAll","GFFTransform","_Transform","_inherits","_super","_createSuper","inputOptions","call","objectMode","textBuffer","decoder","Decoder","_assertThisInitialized","parser","err","emit","data","buffer","pieces","pop","piece","_addLine","chunk","_encoding","_nextText","write","Transform","FormattingTransform","_Transform2","_super2","assign","linesSinceLastSyncMark","haveWeEmittedData","fastaMode","minLinesBetweenSyncMarks","minSyncLines","insertVersionDirective","thisChunk","count","parseStream","parseStringSync","items","Infinity","formatSync","other","sequences","formatStream","formatFile","stream","writeStream","newOptions","Promise","resolve","reject","pipe","on","util"],"sourceRoot":""}