{"version":3,"file":"static/js/1343.9e541994.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/bam/src/virtualOffset.ts","../../../node_modules/@gmod/bam/src/chunk.ts","../../../node_modules/@gmod/bam/src/util.ts","../../../node_modules/@gmod/bam/src/indexFile.ts","../../../node_modules/@gmod/bam/src/bai.ts","../../../node_modules/@gmod/bam/src/csi.ts","../../../node_modules/@gmod/bam/src/constants.ts","../../../node_modules/@gmod/bam/src/record.ts","../../../node_modules/@gmod/bam/src/sam.ts","../../../node_modules/@gmod/bam/src/bamFile.ts","../../../node_modules/@gmod/bam/src/htsget.ts","../../../node_modules/abortable-promise-cache/esm/AbortablePromiseCache.js","../../../node_modules/abortable-promise-cache/esm/AggregateAbortController.js","../../../node_modules/abortable-promise-cache/esm/AggregateStatusReporter.js","../../../node_modules/abortable-promise-cache/esm/abortcontroller-ponyfill.js","../../../node_modules/abortable-promise-cache/esm/index.js","../../../node_modules/@babel/runtime/helpers/esm/OverloadYield.js","../../../node_modules/@babel/runtime/helpers/esm/asyncGeneratorDelegate.js","../../../node_modules/@babel/runtime/helpers/esm/asyncIterator.js","../../../node_modules/@babel/runtime/helpers/esm/awaitAsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/AsyncGenerator.js","../../../node_modules/@babel/runtime/helpers/esm/wrapAsyncGenerator.js"],"sourcesContent":["export default class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n\n  static min(...args: VirtualOffset[]) {\n    let min\n    let i = 0\n    for (; !min; i += 1) {\n      min = args[i]\n    }\n    for (; i < args.length; i += 1) {\n      if (min.compareTo(args[i]) > 0) {\n        min = args[i]\n      }\n    }\n    return min\n  }\n}\nexport function fromBytes(bytes: Buffer, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7] * 0x10000000000 +\n      bytes[offset + 6] * 0x100000000 +\n      bytes[offset + 5] * 0x1000000 +\n      bytes[offset + 4] * 0x10000 +\n      bytes[offset + 3] * 0x100 +\n      bytes[offset + 2],\n    (bytes[offset + 1] << 8) | bytes[offset],\n  )\n}\n","import VirtualOffset from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public buffer?: Buffer\n\n  constructor(\n    public minv: VirtualOffset,\n    public maxv: VirtualOffset,\n    public bin: number,\n    public _fetchedSize?: number,\n  ) {}\n\n  toUniqueString() {\n    return `${this.minv}..${this.maxv} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import Long from 'long'\nimport Chunk from './chunk'\nimport VirtualOffset from './virtualOffset'\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\nexport function longToNumber(long: Long) {\n  if (\n    long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n    long.lessThan(Number.MIN_SAFE_INTEGER)\n  ) {\n    throw new Error('integer overflow')\n  }\n  return long.toNumber()\n}\n\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    // console.log('bam aborted!')\n    if (typeof DOMException === 'undefined') {\n      const e = new Error('aborted')\n      //@ts-ignore\n      e.code = 'ERR_ABORTED'\n      throw e\n    } else {\n      throw new DOMException('aborted', 'AbortError')\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : (obj as BaseOpts)\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest?: VirtualOffset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | undefined\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort((c0, c1) => {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif\n  })\n\n  for (const chunk of chunks) {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === undefined) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  }\n\n  return mergedChunks\n}\n\nexport function parsePseudoBin(bytes: Buffer, offset: number) {\n  const lineCount = longToNumber(\n    Long.fromBytesLE(\n      Array.prototype.slice.call(bytes, offset, offset + 8),\n      true,\n    ),\n  )\n  return { lineCount }\n}\n\nexport function findFirstData(\n  firstDataLine: VirtualOffset | undefined,\n  virtualOffset: VirtualOffset,\n) {\n  return firstDataLine\n    ? firstDataLine.compareTo(virtualOffset) > 0\n      ? virtualOffset\n      : firstDataLine\n    : virtualOffset\n}\n\nexport function parseNameBytes(\n  namesBytes: Buffer,\n  renameRefSeq: (arg: string) => string = s => s,\n) {\n  let currRefId = 0\n  let currNameStart = 0\n  const refIdToName = []\n  const refNameToId: { [key: string]: number } = {}\n  for (let i = 0; i < namesBytes.length; i += 1) {\n    if (!namesBytes[i]) {\n      if (currNameStart < i) {\n        let refName = namesBytes.toString('utf8', currNameStart, i)\n        refName = renameRefSeq(refName)\n        refIdToName[currRefId] = refName\n        refNameToId[refName] = currRefId\n      }\n      currNameStart = i + 1\n      currRefId += 1\n    }\n  }\n  return { refNameToId, refIdToName }\n}\n","import { GenericFilehandle } from 'generic-filehandle'\nimport Chunk from './chunk'\nimport { BaseOpts } from './util'\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (s: string) => string\n\n  /**\n   * @param {filehandle} filehandle\n   * @param {function} [renameRefSeqs]\n   */\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract lineCount(refId: number): Promise<number>\n  public abstract indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n\n  public abstract blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ): Promise<Chunk[]>\n}\n","import VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\n\nimport { optimizeChunks, parsePseudoBin, findFirstData, BaseOpts } from './util'\nimport IndexFile from './indexFile'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nfunction reg2bins(beg: number, end: number) {\n  end -= 1\n  return [\n    [0, 0],\n    [1 + (beg >> 26), 1 + (end >> 26)],\n    [9 + (beg >> 23), 9 + (end >> 23)],\n    [73 + (beg >> 20), 73 + (end >> 20)],\n    [585 + (beg >> 17), 585 + (end >> 17)],\n    [4681 + (beg >> 14), 4681 + (end >> 14)],\n  ]\n}\n\nexport default class BAI extends IndexFile {\n  public setupP?: ReturnType<BAI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices[refId]?.stats?.lineCount || 0\n  }\n\n  // fetch and parse the index\n  async _parse(opts?: BaseOpts) {\n    const bytes = (await this.filehandle.readFile(opts)) as Buffer\n\n    // check BAI magic numbers\n    if (bytes.readUInt32LE(0) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    const refCount = bytes.readInt32LE(4)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    let curr = 8\n    let firstDataLine: VirtualOffset | undefined\n\n    type BinIndex = { [key: string]: Chunk[] }\n    type LinearIndex = VirtualOffset[]\n    const indices = new Array<{\n      binIndex: BinIndex\n      linearIndex: LinearIndex\n      stats?: { lineCount: number }\n    }>(refCount)\n    for (let i = 0; i < refCount; i++) {\n      // the binning index\n      const binCount = bytes.readInt32LE(curr)\n      let stats\n\n      curr += 4\n      const binIndex: { [key: number]: Chunk[] } = {}\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(curr)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          stats = parsePseudoBin(bytes, curr + 16)\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = bytes.readInt32LE(curr)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k++) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = bytes.readInt32LE(curr)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n\n      indices[i] = { binIndex, linearIndex, stats }\n    }\n\n    return {\n      bai: true,\n      firstDataLine,\n      maxBlockSize: 1 << 16,\n      indices,\n      refCount,\n    }\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts: BaseOpts = {},\n  ): Promise<{ start: number; end: number; score: number }[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices[seqId]\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex = [], stats } = seqIdx\n    if (linearIndex.length === 0) {\n      return []\n    }\n    const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v)\n    const s = start === undefined ? 0 : roundDown(start, v)\n    const depths = range\n      ? new Array((e - s) / v)\n      : new Array(linearIndex.length - 1)\n    const totalSize = linearIndex[linearIndex.length - 1].blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v].blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1].blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1].blockPosition\n    }\n    return depths.map(d => ({\n      ...d,\n      score: (d.score * (stats?.lineCount || 0)) / totalSize,\n    }))\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    if (!ba) {\n      return []\n    }\n\n    // List of bin #s that overlap min, max\n    const overlappingBins = reg2bins(min, max)\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (const binChunk of binChunks) {\n            chunks.push(binChunk)\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest: VirtualOffset | undefined\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n      if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n        lowest = vp\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices[seqId]?.binIndex\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport {\n  optimizeChunks,\n  findFirstData,\n  parsePseudoBin,\n  parseNameBytes,\n  BaseOpts,\n} from './util'\n\nimport IndexFile from './indexFile'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber = 0\n  private depth = 0\n  private minShift = 0\n\n  public setupP?: ReturnType<CSI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices[refId]?.stats?.lineCount || 0\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Buffer, offset: number) {\n    const formatFlags = bytes.readInt32LE(offset)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const format = (\n      { 0: 'generic', 1: 'SAM', 2: 'VCF' } as {\n        [key: number]: string\n      }\n    )[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: bytes.readInt32LE(offset + 4),\n      start: bytes.readInt32LE(offset + 8),\n      end: bytes.readInt32LE(offset + 12),\n    }\n    const metaValue = bytes.readInt32LE(offset + 16)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : ''\n    const skipLines = bytes.readInt32LE(offset + 20)\n    const nameSectionLength = bytes.readInt32LE(offset + 24)\n\n    return {\n      columnNumbers,\n      coordinateType,\n      metaValue,\n      metaChar,\n      skipLines,\n      format,\n      formatFlags,\n      ...parseNameBytes(\n        bytes.subarray(offset + 28, offset + 28 + nameSectionLength),\n        this.renameRefSeq,\n      ),\n    }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const buffer = await this.filehandle.readFile(opts)\n    const bytes = await unzip(buffer)\n\n    let csiVersion\n    // check TBI magic numbers\n    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n      csiVersion = 1\n    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n      csiVersion = 2\n    } else {\n      throw new Error('Not a CSI file')\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = bytes.readInt32LE(4)\n    this.depth = bytes.readInt32LE(8)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const auxLength = bytes.readInt32LE(12)\n    const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined\n    const refCount = bytes.readInt32LE(16 + auxLength)\n\n    type BinIndex = { [key: string]: Chunk[] }\n\n    // read the indexes for each reference sequence\n    let curr = 16 + auxLength + 4\n    let firstDataLine: VirtualOffset | undefined\n    const indices = new Array<{\n      binIndex: BinIndex\n      stats?: { lineCount: number }\n    }>(refCount)\n    for (let i = 0; i < refCount; i++) {\n      // the binning index\n      const binCount = bytes.readInt32LE(curr)\n      curr += 4\n      const binIndex: { [key: string]: Chunk[] } = {}\n      let stats // < provided by parsing a pseudo-bin, if present\n      for (let j = 0; j < binCount; j++) {\n        const bin = bytes.readUInt32LE(curr)\n        curr += 4\n        if (bin > this.maxBinNumber) {\n          stats = parsePseudoBin(bytes, curr + 28)\n          curr += 28 + 16\n        } else {\n          firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr))\n          curr += 8\n          const chunkCount = bytes.readInt32LE(curr)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      indices[i] = { binIndex, stats }\n    }\n\n    return {\n      csiVersion,\n      firstDataLine,\n      indices,\n      refCount,\n      csi: true,\n      maxBlockSize: 1 << 16,\n      ...aux,\n    }\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    const ba = indexData?.indices[refId]\n    if (!ba) {\n      return []\n    }\n    const overlappingBins = this.reg2bins(min, max)\n\n    if (overlappingBins.length === 0) {\n      return []\n    }\n\n    const chunks = []\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (const c of binChunks) {\n            chunks.push(c)\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end)\n   * (zero-based half-open)\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e])\n    }\n    return bins\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices[seqId]?.binIndex\n  }\n}\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport Constants from './constants'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('')\n\n/**\n * Class of each BAM record returned by this API.\n */\nexport default class BamRecord {\n  private data = {} as { [key: string]: any }\n  private bytes: { start: number; end: number; byteArray: Buffer }\n  private _id: number\n  private _tagOffset: number | undefined\n  private _tagList: string[] = []\n  private _allTagsParsed = false\n\n  public flags: any\n  public _refID: number\n  constructor(args: any) {\n    const { bytes, fileOffset } = args\n    const { byteArray, start } = bytes\n    this.data = {}\n    this.bytes = bytes\n    this._id = fileOffset\n    this._refID = byteArray.readInt32LE(start + 4)\n    this.data.start = byteArray.readInt32LE(start + 8)\n    this.flags = (byteArray.readInt32LE(start + 16) & 0xffff0000) >> 16\n  }\n\n  get(field: string) {\n    //@ts-ignore\n    if (this[field]) {\n      //@ts-ignore\n      if (this.data[field]) {\n        return this.data[field]\n      }\n      //@ts-ignore\n      this.data[field] = this[field]()\n      return this.data[field]\n    }\n    return this._get(field.toLowerCase())\n  }\n\n  end() {\n    return this.get('start') + this.get('length_on_ref')\n  }\n\n  seq_id() {\n    return this._refID\n  }\n\n  // same as get(), except requires lower-case arguments.  used\n  // internally to save lots of calls to field.toLowerCase()\n  _get(field: string) {\n    if (field in this.data) {\n      return this.data[field]\n    }\n    this.data[field] = this._parseTag(field)\n    return this.data[field]\n  }\n\n  _tags() {\n    this._parseAllTags()\n\n    let tags = ['seq']\n\n    if (!this.isSegmentUnmapped()) {\n      tags.push(\n        'start',\n        'end',\n        'strand',\n        'score',\n        'qual',\n        'MQ',\n        'CIGAR',\n        'length_on_ref',\n        'template_length',\n      )\n    }\n    if (this.isPaired()) {\n      tags.push('next_segment_position', 'pair_orientation')\n    }\n    tags = tags.concat(this._tagList || [])\n\n    for (const k of Object.keys(this.data)) {\n      if (k[0] !== '_' && k !== 'next_seq_id') {\n        tags.push(k)\n      }\n    }\n\n    const seen: { [key: string]: boolean } = {}\n    return tags.filter(t => {\n      if (\n        (t in this.data && this.data[t] === undefined) ||\n        t === 'CG' ||\n        t === 'cg'\n      ) {\n        return false\n      }\n\n      const lt = t.toLowerCase()\n      const s = seen[lt]\n      seen[lt] = true\n      return !s\n    })\n  }\n\n  parent() {\n    return\n  }\n\n  children() {\n    return this.get('subfeatures')\n  }\n\n  id() {\n    return this._id\n  }\n\n  // special parsers\n  /**\n   * Mapping quality score.\n   */\n  mq() {\n    const mq = (this.get('_bin_mq_nl') & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  score() {\n    return this.get('mq')\n  }\n\n  qual() {\n    return this.qualRaw()?.join(' ')\n  }\n\n  qualRaw() {\n    if (this.isSegmentUnmapped()) {\n      return\n    }\n\n    const { start, byteArray } = this.bytes\n    const p =\n      start +\n      36 +\n      this.get('_l_read_name') +\n      this.get('_n_cigar_op') * 4 +\n      this.get('_seq_bytes')\n    const lseq = this.get('seq_length')\n    return byteArray.subarray(p, p + lseq)\n  }\n\n  strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  multi_segment_next_segment_strand() {\n    if (this.isMateUnmapped()) {\n      return\n    }\n    return this.isMateReverseComplemented() ? -1 : 1\n  }\n\n  name() {\n    return this.get('_read_name')\n  }\n\n  _read_name() {\n    const nl = this.get('_l_read_name')\n    const { byteArray, start } = this.bytes\n    return byteArray.toString('ascii', start + 36, start + 36 + nl - 1)\n  }\n\n  /**\n   * Get the value of a tag, parsing the tags as far as necessary.\n   * Only called if we have not already parsed that field.\n   */\n  _parseTag(tagName?: string) {\n    // if all of the tags have been parsed and we're still being\n    // called, we already know that we have no such tag, because\n    // it would already have been cached.\n    if (this._allTagsParsed) {\n      return\n    }\n\n    const { byteArray, start } = this.bytes\n    let p =\n      this._tagOffset ||\n      start +\n        36 +\n        this.get('_l_read_name') +\n        this.get('_n_cigar_op') * 4 +\n        this.get('_seq_bytes') +\n        this.get('seq_length')\n\n    const blockEnd = this.bytes.end\n    let lcTag\n    while (p < blockEnd && lcTag !== tagName) {\n      const tag = String.fromCharCode(byteArray[p], byteArray[p + 1])\n      lcTag = tag.toLowerCase()\n      const type = String.fromCharCode(byteArray[p + 2])\n      p += 3\n\n      let value\n      switch (type) {\n        case 'A': {\n          value = String.fromCharCode(byteArray[p])\n          p += 1\n          break\n        }\n        case 'i': {\n          value = byteArray.readInt32LE(p)\n          p += 4\n          break\n        }\n        case 'I': {\n          value = byteArray.readUInt32LE(p)\n          p += 4\n          break\n        }\n        case 'c': {\n          value = byteArray.readInt8(p)\n          p += 1\n          break\n        }\n        case 'C': {\n          value = byteArray.readUInt8(p)\n          p += 1\n          break\n        }\n        case 's': {\n          value = byteArray.readInt16LE(p)\n          p += 2\n          break\n        }\n        case 'S': {\n          value = byteArray.readUInt16LE(p)\n          p += 2\n          break\n        }\n        case 'f': {\n          value = byteArray.readFloatLE(p)\n          p += 4\n          break\n        }\n        case 'Z':\n        case 'H': {\n          value = ''\n          while (p <= blockEnd) {\n            const cc = byteArray[p++]\n            if (cc === 0) {\n              break\n            } else {\n              value += String.fromCharCode(cc)\n            }\n          }\n          break\n        }\n        case 'B': {\n          value = ''\n          const cc = byteArray[p++]\n          const Btype = String.fromCharCode(cc)\n          const limit = byteArray.readInt32LE(p)\n          p += 4\n          if (Btype === 'i') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 'I') {\n            if (tag === 'CG') {\n              for (let k = 0; k < limit; k++) {\n                const cigop = byteArray.readUInt32LE(p)\n                const lop = cigop >> 4\n                const op = CIGAR_DECODER[cigop & 0xf]\n                value += lop + op\n                p += 4\n              }\n            } else {\n              for (let k = 0; k < limit; k++) {\n                value += byteArray.readUInt32LE(p)\n                if (k + 1 < limit) {\n                  value += ','\n                }\n                p += 4\n              }\n            }\n          }\n          if (Btype === 's') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'S') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt16LE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 2\n            }\n          }\n          if (Btype === 'c') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'C') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readUInt8(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 1\n            }\n          }\n          if (Btype === 'f') {\n            for (let k = 0; k < limit; k++) {\n              value += byteArray.readFloatLE(p)\n              if (k + 1 < limit) {\n                value += ','\n              }\n              p += 4\n            }\n          }\n          break\n        }\n        default: {\n          console.warn(`Unknown BAM tag type '${type}', tags may be incomplete`)\n          value = undefined\n          p = blockEnd\n        } // stop parsing tags\n      }\n\n      this._tagOffset = p\n\n      this._tagList.push(tag)\n      if (lcTag === tagName) {\n        return value\n      }\n\n      this.data[lcTag] = value\n    }\n    this._allTagsParsed = true\n    return\n  }\n\n  _parseAllTags() {\n    this._parseTag('')\n  }\n\n  _parseCigar(cigar: string) {\n    return (\n      //@ts-ignore\n      cigar\n        .match(/\\d+\\D/g)\n        //@ts-ignore\n        .map(op => [op.match(/\\D/)[0].toUpperCase(), Number.parseInt(op, 10)])\n    )\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  cigar() {\n    if (this.isSegmentUnmapped()) {\n      return\n    }\n\n    const { byteArray, start } = this.bytes\n    const numCigarOps = this.get('_n_cigar_op')\n    let p = start + 36 + this.get('_l_read_name')\n    const seqLen = this.get('seq_length')\n    let cigar = ''\n    let lref = 0\n\n    // check for CG tag by inspecting whether the CIGAR field\n    // contains a clip that consumes entire seqLen\n    let cigop = byteArray.readInt32LE(p)\n    let lop = cigop >> 4\n    let op = CIGAR_DECODER[cigop & 0xf]\n    if (op === 'S' && lop === seqLen) {\n      // if there is a CG the second CIGAR field will\n      // be a N tag the represents the length on ref\n      p += 4\n      cigop = byteArray.readInt32LE(p)\n      lop = cigop >> 4\n      op = CIGAR_DECODER[cigop & 0xf]\n      if (op !== 'N') {\n        console.warn('CG tag with no N tag')\n      }\n      this.data.length_on_ref = lop\n      return this.get('CG')\n    } else {\n      for (let c = 0; c < numCigarOps; ++c) {\n        cigop = byteArray.readInt32LE(p)\n        lop = cigop >> 4\n        op = CIGAR_DECODER[cigop & 0xf]\n        cigar += lop + op\n\n        // soft clip, hard clip, and insertion don't count toward\n        // the length on the reference\n        if (op !== 'H' && op !== 'S' && op !== 'I') {\n          lref += lop\n        }\n\n        p += 4\n      }\n\n      this.data.length_on_ref = lref\n      return cigar\n    }\n  }\n\n  _flags() {}\n\n  length_on_ref() {\n    if (this.data.length_on_ref) {\n      return this.data.length_on_ref\n    } else {\n      this.get('cigar') // the length_on_ref is set as a side effect\n      return this.data.length_on_ref\n    }\n  }\n\n  _n_cigar_op() {\n    return this.get('_flag_nc') & 0xffff\n  }\n\n  _l_read_name() {\n    return this.get('_bin_mq_nl') & 0xff\n  }\n\n  /**\n   * number of bytes in the sequence field\n   */\n  _seq_bytes() {\n    return (this.get('seq_length') + 1) >> 1\n  }\n\n  getReadBases() {\n    return this.seq()\n  }\n\n  seq() {\n    const { byteArray, start } = this.bytes\n    const p =\n      start + 36 + this.get('_l_read_name') + this.get('_n_cigar_op') * 4\n    const seqBytes = this.get('_seq_bytes')\n    const len = this.get('seq_length')\n    let buf = ''\n    let i = 0\n    for (let j = 0; j < seqBytes; ++j) {\n      const sb = byteArray[p + j]\n      buf += SEQRET_DECODER[(sb & 0xf0) >> 4]\n      i++\n      if (i < len) {\n        buf += SEQRET_DECODER[sb & 0x0f]\n        i++\n      }\n    }\n    return buf\n  }\n\n  // adapted from igv.js\n  getPairOrientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      !this.isMateUnmapped() &&\n      this._refID === this._next_refid()\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      const isize = this.template_length()\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return ''\n  }\n\n  _bin_mq_nl() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 12)\n  }\n\n  _flag_nc() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 16)\n  }\n\n  seq_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 20)\n  }\n\n  _next_refid() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 24)\n  }\n\n  _next_pos() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 28)\n  }\n\n  template_length() {\n    return this.bytes.byteArray.readInt32LE(this.bytes.start + 32)\n  }\n\n  toJSON() {\n    const data: { [key: string]: any } = {}\n    for (const k of Object.keys(this)) {\n      if (k.charAt(0) === '_' || k === 'bytes') {\n        continue\n      }\n      //@ts-ignore\n      data[k] = this[k]\n    }\n\n    return data\n  }\n}\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  for (const line of lines) {\n    const [tag, ...fields] = line.split(/\\t/)\n    if (tag) {\n      data.push({\n        tag: tag.slice(1),\n        data: fields.map(f => {\n          const [fieldTag, value] = f.split(':', 2)\n          return { tag: fieldTag, value }\n        }),\n      })\n    }\n  }\n  return data\n}\n","import { Buffer } from 'buffer'\nimport crc32 from 'buffer-crc32'\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport { LocalFile, RemoteFile, GenericFilehandle } from 'generic-filehandle'\nimport AbortablePromiseCache from 'abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\n\n// locals\nimport BAI from './bai'\nimport CSI from './csi'\nimport Chunk from './chunk'\nimport BAMFeature from './record'\nimport { parseHeaderText } from './sam'\nimport { checkAbortSignal, timeout, makeOpts, BamOpts, BaseOpts } from './util'\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\n\nasync function gen2array<T>(gen: AsyncIterable<T[]>): Promise<T[]> {\n  let out: T[] = []\n  for await (const x of gen) {\n    out = out.concat(x)\n  }\n  return out\n}\n\ninterface Args {\n  chunk: Chunk\n  opts: BaseOpts\n}\n\nclass NullFilehandle {\n  public read(): Promise<any> {\n    throw new Error('never called')\n  }\n  public stat(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public readFile(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public close(): Promise<any> {\n    throw new Error('never called')\n  }\n}\nexport default class BamFile {\n  public renameRefSeq: (a: string) => string\n  public bam: GenericFilehandle\n  public header?: string\n  public chrToIndex?: Record<string, number>\n  public indexToChr?: { refName: string; length: number }[]\n  public yieldThreadTime: number\n  public index?: BAI | CSI\n  public htsget = false\n  public headerP?: ReturnType<BamFile['getHeaderPre']>\n\n  private featureCache = new AbortablePromiseCache<Args, BAMFeature[]>({\n    cache: new QuickLRU({\n      maxSize: 50,\n    }),\n    fill: async (args: Args, signal) => {\n      const { chunk, opts } = args\n      const { data, cpositions, dpositions } = await this._readChunk({\n        chunk,\n        opts: { ...opts, signal },\n      })\n      return this.readBamFeatures(data, cpositions, dpositions, chunk)\n    },\n  })\n\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    htsget,\n    yieldThreadTime = 100,\n    renameRefSeqs = n => n,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    renameRefSeqs?: (a: string) => string\n    yieldThreadTime?: number\n    htsget?: boolean\n  }) {\n    this.renameRefSeq = renameRefSeqs\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else if (htsget) {\n      this.htsget = true\n      this.bam = new NullFilehandle()\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else if (htsget) {\n      this.htsget = true\n    } else {\n      throw new Error('unable to infer index format')\n    }\n    this.yieldThreadTime = yieldThreadTime\n  }\n\n  async getHeaderPre(origOpts?: BaseOpts) {\n    const opts = makeOpts(origOpts)\n    if (!this.index) {\n      return\n    }\n    const indexData = await this.index.parse(opts)\n    const ret = indexData.firstDataLine\n      ? indexData.firstDataLine.blockPosition + 65535\n      : undefined\n    let buffer\n    if (ret) {\n      const s = ret + blockLen\n      const res = await this.bam.read(Buffer.alloc(s), 0, s, 0, opts)\n      if (!res.bytesRead) {\n        throw new Error('Error reading header')\n      }\n      buffer = res.buffer.subarray(0, Math.min(res.bytesRead, ret))\n    } else {\n      buffer = (await this.bam.readFile(opts)) as Buffer\n    }\n\n    const uncba = await unzip(buffer)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    this.header = uncba.toString('utf8', 8, 8 + headLen)\n    const { chrToIndex, indexToChr } = await this._readRefSeqs(\n      headLen + 8,\n      65535,\n      opts,\n    )\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n\n    return parseHeaderText(this.header)\n  }\n\n  getHeader(opts?: BaseOpts) {\n    if (!this.headerP) {\n      this.headerP = this.getHeaderPre(opts).catch(e => {\n        this.headerP = undefined\n        throw e\n      })\n    }\n    return this.headerP\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  // the full length of the refseq block is not given in advance so this grabs\n  // a chunk and doubles it if all refseqs haven't been processed\n  async _readRefSeqs(\n    start: number,\n    refSeqBytes: number,\n    opts?: BaseOpts,\n  ): Promise<{\n    chrToIndex: { [key: string]: number }\n    indexToChr: { refName: string; length: number }[]\n  }> {\n    if (start > refSeqBytes) {\n      return this._readRefSeqs(start, refSeqBytes * 2, opts)\n    }\n    const size = refSeqBytes + blockLen\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      refSeqBytes,\n      0,\n      opts,\n    )\n    if (!bytesRead) {\n      throw new Error('Error reading refseqs from header')\n    }\n    const uncba = await unzip(\n      buffer.subarray(0, Math.min(bytesRead, refSeqBytes)),\n    )\n    const nRef = uncba.readInt32LE(start)\n    let p = start + 4\n    const chrToIndex: { [key: string]: number } = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    for (let i = 0; i < nRef; i += 1) {\n      const lName = uncba.readInt32LE(p)\n      const refName = this.renameRefSeq(\n        uncba.toString('utf8', p + 4, p + 4 + lName - 1),\n      )\n      const lRef = uncba.readInt32LE(p + lName + 4)\n\n      chrToIndex[refName] = i\n      indexToChr.push({ refName, length: lRef })\n\n      p = p + 8 + lName\n      if (p > uncba.length) {\n        console.warn(\n          `BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`,\n        )\n        return this._readRefSeqs(start, refSeqBytes * 2, opts)\n      }\n    }\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    return gen2array(this.streamRecordsForRange(chr, min, max, opts))\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    await this.getHeader(opts)\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined || !this.index) {\n      yield []\n    } else {\n      const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n      yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts)\n    }\n  }\n\n  async *_fetchChunkFeatures(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts = {},\n  ) {\n    const { viewAsPairs } = opts\n    const feats = [] as BAMFeature[][]\n    let done = false\n\n    for (const chunk of chunks) {\n      const records = await this.featureCache.get(\n        chunk.toString(),\n        { chunk, opts },\n        opts.signal,\n      )\n\n      const recs = [] as BAMFeature[]\n      for (const feature of records) {\n        if (feature.seq_id() === chrId) {\n          if (feature.get('start') >= max) {\n            // past end of range, can stop iterating\n            done = true\n            break\n          } else if (feature.get('end') >= min) {\n            // must be in range\n            recs.push(feature)\n          }\n        }\n      }\n      feats.push(recs)\n      yield recs\n      if (done) {\n        break\n      }\n    }\n\n    checkAbortSignal(opts.signal)\n    if (viewAsPairs) {\n      yield this.fetchPairs(chrId, feats, opts)\n    }\n  }\n\n  async fetchPairs(chrId: number, feats: BAMFeature[][], opts: BamOpts) {\n    const { pairAcrossChr, maxInsertSize = 200000 } = opts\n    const unmatedPairs: { [key: string]: boolean } = {}\n    const readIds: { [key: string]: number } = {}\n    feats.map(ret => {\n      const readNames: { [key: string]: number } = {}\n      for (const element of ret) {\n        const name = element.name()\n        const id = element.id()\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name]++\n        readIds[id] = 1\n      }\n      for (const [k, v] of Object.entries(readNames)) {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      }\n    })\n\n    const matePromises: Promise<Chunk[]>[] = []\n    feats.map(ret => {\n      for (const f of ret) {\n        const name = f.name()\n        const start = f.get('start')\n        const pnext = f._next_pos()\n        const rnext = f._next_refid()\n        if (\n          this.index &&\n          unmatedPairs[name] &&\n          (pairAcrossChr ||\n            (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))\n        ) {\n          matePromises.push(\n            this.index.blocksForRange(rnext, pnext, pnext + 1, opts),\n          )\n        }\n      }\n    })\n\n    // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n    // concatenated, then filter dup chunks)\n    const map = new Map<string, Chunk>()\n    const res = await Promise.all(matePromises)\n    for (const m of res.flat()) {\n      if (!map.has(m.toString())) {\n        map.set(m.toString(), m)\n      }\n    }\n\n    const mateFeatPromises = await Promise.all(\n      [...map.values()].map(async c => {\n        const { data, cpositions, dpositions, chunk } = await this._readChunk({\n          chunk: c,\n          opts,\n        })\n        const mateRecs = [] as BAMFeature[]\n        for (const feature of await this.readBamFeatures(\n          data,\n          cpositions,\n          dpositions,\n          chunk,\n        )) {\n          if (unmatedPairs[feature.get('name')] && !readIds[feature.id()]) {\n            mateRecs.push(feature)\n          }\n        }\n        return mateRecs\n      }),\n    )\n    return mateFeatPromises.flat()\n  }\n\n  async _readRegion(position: number, size: number, opts: BaseOpts = {}) {\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      size,\n      position,\n      opts,\n    )\n\n    return buffer.subarray(0, Math.min(bytesRead, size))\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: Chunk; opts: BaseOpts }) {\n    const buffer = await this._readRegion(\n      chunk.minv.blockPosition,\n      chunk.fetchedSize(),\n      opts,\n    )\n\n    const {\n      buffer: data,\n      cpositions,\n      dpositions,\n    } = await unzipChunkSlice(buffer, chunk)\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(\n    ba: Buffer,\n    cpositions: number[],\n    dpositions: number[],\n    chunk: Chunk,\n  ) {\n    let blockStart = 0\n    const sink = [] as BAMFeature[]\n    let pos = 0\n    let last = +Date.now()\n\n    while (blockStart + 4 < ba.length) {\n      const blockSize = ba.readInt32LE(blockStart)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      // increment position to the current decompressed status\n      if (dpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) {}\n        pos--\n      }\n\n      // only try to read the feature if we have all the bytes for it\n      if (blockEnd < ba.length) {\n        const feature = new BAMFeature({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          // the below results in an automatically calculated file-offset based\n          // ID if the info for that is available, otherwise crc32 of the\n          // features\n          //\n          // cpositions[pos] refers to actual file offset of a bgzip block\n          // boundaries\n          //\n          // we multiply by (1 <<8) in order to make sure each block has a\n          // \"unique\" address space so that data in that block could never\n          // overlap\n          //\n          // then the blockStart-dpositions is an uncompressed file offset from\n          // that bgzip block boundary, and since the cpositions are multiplied\n          // by (1 << 8) these uncompressed offsets get a unique space\n          //\n          // this has an extra chunk.minv.dataPosition added on because it\n          // blockStart starts at 0 instead of chunk.minv.dataPosition\n          //\n          // the +1 is just to avoid any possible uniqueId 0 but this does not\n          // realistically happen\n          fileOffset:\n            cpositions.length > 0\n              ? cpositions[pos] * (1 << 8) +\n                (blockStart - dpositions[pos]) +\n                chunk.minv.dataPosition +\n                1\n              : // must be slice, not subarray for buffer polyfill on web\n                crc32.signed(ba.slice(blockStart, blockEnd)),\n        })\n\n        sink.push(feature)\n        if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n          await timeout(1)\n          last = +Date.now()\n        }\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? false : this.index?.hasRefSeq(seqId)\n  }\n\n  async lineCount(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? [] : this.index.indexCov(seqId, start, end)\n  }\n\n  async blocksForRange(\n    seqName: string,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined\n      ? []\n      : this.index.blocksForRange(seqId, start, end, opts)\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport { Buffer } from 'buffer'\nimport { BaseOpts, BamOpts } from './util'\nimport BamFile, { BAM_MAGIC } from './bamFile'\nimport Chunk from './chunk'\nimport { parseHeaderText } from './sam'\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\nasync function concat(arr: HtsgetChunk[], opts?: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async chunk => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        return Buffer.from(url.split(',')[1], 'base64')\n      } else {\n        //remove referer header, it is not even allowed to be specified\n        // @ts-expect-error\n        //eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { referer, ...rest } = headers\n        const res = await fetch(url, {\n          ...opts,\n          headers: { ...opts?.headers, ...rest },\n        })\n        if (!res.ok) {\n          throw new Error(\n            `HTTP ${res.status} fetching ${url}: ${await res.text()}`,\n          )\n        }\n        return Buffer.from(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return Buffer.concat(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile extends BamFile {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: { trackId: string; baseUrl: string }) {\n    super({ htsget: true })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined) {\n      yield []\n    } else {\n      const result = await fetch(url, { ...opts })\n      if (!result.ok) {\n        throw new Error(\n          `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n        )\n      }\n      const data = await result.json()\n      const uncba = await concat(data.htsget.urls.slice(1), opts)\n\n      yield* this._fetchChunkFeatures(\n        [\n          // fake stuff to pretend to be a Chunk\n          {\n            buffer: uncba,\n            _fetchedSize: undefined,\n            bin: 0,\n            compareTo() {\n              return 0\n            },\n            toUniqueString() {\n              return `${chr}_${min}_${max}`\n            },\n            fetchedSize() {\n              return 0\n            },\n            minv: {\n              dataPosition: 0,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            maxv: {\n              dataPosition: Number.MAX_SAFE_INTEGER,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            toString() {\n              return `${chr}_${min}_${max}`\n            },\n          },\n        ],\n        chrId,\n        min,\n        max,\n        opts,\n      )\n    }\n  }\n\n  async _readChunk({ chunk }: { chunk: Chunk; opts: BaseOpts }) {\n    if (!chunk.buffer) {\n      throw new Error('expected chunk.buffer in htsget')\n    }\n    return { data: chunk.buffer, cpositions: [], dpositions: [], chunk }\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(\n        `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n      )\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n    const headerText = uncba.toString('utf8', 8, 8 + headLen)\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: { refName: string; length: number }[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter(l => l.tag === 'SQ')\n    for (const [refId, sqLine] of sqLines.entries()) {\n      let refName = ''\n      let length = 0\n      for (const item of sqLine.data) {\n        if (item.tag === 'SN') {\n          refName = item.value\n        } else if (item.tag === 'LN') {\n          length = +item.value\n        }\n      }\n      nameToId[refName] = refId\n      idToName[refId] = { refName, length }\n    }\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nconst AggregateAbortController_1 = __importDefault(require(\"./AggregateAbortController\"));\nconst AggregateStatusReporter_1 = __importDefault(require(\"./AggregateStatusReporter\"));\nclass AbortablePromiseCache {\n    constructor({ fill, cache, }) {\n        if (typeof fill !== 'function') {\n            throw new TypeError('must pass a fill function');\n        }\n        if (typeof cache !== 'object') {\n            throw new TypeError('must pass a cache object');\n        }\n        if (typeof cache.get !== 'function' ||\n            typeof cache.set !== 'function' ||\n            typeof cache.delete !== 'function') {\n            throw new TypeError('cache must implement get(key), set(key, val), and and delete(key)');\n        }\n        this.cache = cache;\n        this.fillCallback = fill;\n    }\n    static isAbortException(exception) {\n        return (\n        // DOMException\n        exception.name === 'AbortError' ||\n            // standard-ish non-DOM abort exception\n            //@ts-ignore\n            exception.code === 'ERR_ABORTED' ||\n            // stringified DOMException\n            exception.message === 'AbortError: aborted' ||\n            // stringified standard-ish exception\n            exception.message === 'Error: aborted');\n    }\n    evict(key, entry) {\n        if (this.cache.get(key) === entry) {\n            this.cache.delete(key);\n        }\n    }\n    fill(key, data, signal, statusCallback) {\n        const aborter = new AggregateAbortController_1.default();\n        const statusReporter = new AggregateStatusReporter_1.default();\n        statusReporter.addCallback(statusCallback);\n        const newEntry = {\n            aborter: aborter,\n            promise: this.fillCallback(data, aborter.signal, (message) => {\n                statusReporter.callback(message);\n            }),\n            settled: false,\n            statusReporter,\n            get aborted() {\n                return this.aborter.signal.aborted;\n            },\n        };\n        newEntry.aborter.addSignal(signal);\n        // remove the fill from the cache when its abortcontroller fires, if still in there\n        newEntry.aborter.signal.addEventListener('abort', () => {\n            if (!newEntry.settled) {\n                this.evict(key, newEntry);\n            }\n        });\n        // chain off the cached promise to record when it settles\n        newEntry.promise\n            .then(() => {\n            newEntry.settled = true;\n        }, () => {\n            newEntry.settled = true;\n            // if the fill throws an error (including abort) and is still in the cache, remove it\n            this.evict(key, newEntry);\n        })\n            .catch(e => {\n            // this will only be reached if there is some kind of\n            // bad bug in this library\n            console.error(e);\n            throw e;\n        });\n        this.cache.set(key, newEntry);\n    }\n    static checkSinglePromise(promise, signal) {\n        // check just this signal for having been aborted, and abort the\n        // promise if it was, regardless of what happened with the cached\n        // response\n        function checkForSingleAbort() {\n            if (signal && signal.aborted) {\n                throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' });\n            }\n        }\n        return promise.then(result => {\n            checkForSingleAbort();\n            return result;\n        }, error => {\n            checkForSingleAbort();\n            throw error;\n        });\n    }\n    has(key) {\n        return this.cache.has(key);\n    }\n    /**\n     * Callback for getting status of the pending async\n     *\n     * @callback statusCallback\n     * @param {any} status, current status string or message object\n     */\n    /**\n     * @param {any} key cache key to use for this request\n     * @param {any} data data passed as the first argument to the fill callback\n     * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n     * @param {statusCallback} a callback to get the current status of a pending async operation\n     */\n    get(key, data, signal, statusCallback) {\n        if (!signal && data instanceof abortcontroller_ponyfill_1.AbortSignal) {\n            throw new TypeError('second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?');\n        }\n        const cacheEntry = this.cache.get(key);\n        if (cacheEntry) {\n            if (cacheEntry.aborted && !cacheEntry.settled) {\n                // if it's aborted but has not realized it yet, evict it and redispatch\n                this.evict(key, cacheEntry);\n                return this.get(key, data, signal, statusCallback);\n            }\n            if (cacheEntry.settled) {\n                // too late to abort, just return it\n                return cacheEntry.promise;\n            }\n            // request is in-flight, add this signal to its list of signals,\n            // or if there is no signal, the aborter will become non-abortable\n            cacheEntry.aborter.addSignal(signal);\n            cacheEntry.statusReporter.addCallback(statusCallback);\n            return AbortablePromiseCache.checkSinglePromise(cacheEntry.promise, signal);\n        }\n        // if we got here, it is not in the cache. fill.\n        this.fill(key, data, signal, statusCallback);\n        return AbortablePromiseCache.checkSinglePromise(\n        //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n        //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        this.cache.get(key).promise, signal);\n    }\n    /**\n     * delete the given entry from the cache. if it exists and its fill request has\n     * not yet settled, the fill will be signaled to abort.\n     *\n     * @param {any} key\n     */\n    delete(key) {\n        const cachedEntry = this.cache.get(key);\n        if (cachedEntry) {\n            if (!cachedEntry.settled) {\n                cachedEntry.aborter.abort();\n            }\n            this.cache.delete(key);\n        }\n    }\n    /**\n     * Clear all requests from the cache. Aborts any that have not settled.\n     * @returns {number} count of entries deleted\n     */\n    clear() {\n        // iterate without needing regenerator-runtime\n        const keyIter = this.cache.keys();\n        let deleteCount = 0;\n        for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n            this.delete(result.value);\n            deleteCount += 1;\n        }\n        return deleteCount;\n    }\n}\nexports.default = AbortablePromiseCache;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst abortcontroller_ponyfill_1 = require(\"./abortcontroller-ponyfill\");\nclass NullSignal {\n}\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nclass AggregateAbortController {\n    constructor() {\n        this.signals = new Set();\n        this.abortController = new abortcontroller_ponyfill_1.AbortController();\n    }\n    /**\n     * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n     *  will be treated as a null-signal, and this abortcontroller will no\n     *  longer be abortable.\n     */\n    //@ts-ignore\n    addSignal(signal = new NullSignal()) {\n        if (this.signal.aborted) {\n            throw new Error('cannot add a signal, already aborted!');\n        }\n        // note that a NullSignal will never fire, so if we\n        // have one this thing will never actually abort\n        this.signals.add(signal);\n        if (signal.aborted) {\n            // handle the abort immediately if it is already aborted\n            // for some reason\n            this.handleAborted(signal);\n        }\n        else if (typeof signal.addEventListener === 'function') {\n            signal.addEventListener('abort', () => {\n                this.handleAborted(signal);\n            });\n        }\n    }\n    handleAborted(signal) {\n        this.signals.delete(signal);\n        if (this.signals.size === 0) {\n            this.abortController.abort();\n        }\n    }\n    get signal() {\n        return this.abortController.signal;\n    }\n    abort() {\n        this.abortController.abort();\n    }\n}\nexports.default = AggregateAbortController;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nclass AggregateStatusReporter {\n    constructor() {\n        this.callbacks = new Set();\n    }\n    addCallback(callback = () => { }) {\n        this.callbacks.add(callback);\n        callback(this.currentMessage);\n    }\n    callback(message) {\n        this.currentMessage = message;\n        this.callbacks.forEach(elt => {\n            elt(message);\n        });\n    }\n}\nexports.default = AggregateStatusReporter;\n","\"use strict\";\n/* eslint-disable */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AbortSignal = exports.AbortController = void 0;\nconst cjs_ponyfill_1 = require(\"abortcontroller-polyfill/dist/cjs-ponyfill\");\nvar getGlobal = function () {\n    // the only reliable means to get the global object is\n    // `Function('return this')()`\n    // However, this causes CSP violations in Chrome apps.\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    if (typeof global !== 'undefined') {\n        return global;\n    }\n    throw new Error('unable to locate global object');\n};\n//@ts-ignore\nlet AbortController = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortController : getGlobal().AbortController;\nexports.AbortController = AbortController;\n//@ts-ignore\nlet AbortSignal = typeof getGlobal().AbortController === 'undefined' ? cjs_ponyfill_1.AbortSignal : getGlobal().AbortSignal;\nexports.AbortSignal = AbortSignal;\n","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst AbortablePromiseCache_1 = __importDefault(require(\"./AbortablePromiseCache\"));\nexports.default = AbortablePromiseCache_1.default;\n","export default function _OverloadYield(value, kind) {\n  this.v = value, this.k = kind;\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function _asyncGeneratorDelegate(inner) {\n  var iter = {},\n    waiting = !1;\n  function pump(key, value) {\n    return waiting = !0, value = new Promise(function (resolve) {\n      resolve(inner[key](value));\n    }), {\n      done: !1,\n      value: new OverloadYield(value, 1)\n    };\n  }\n  return iter[\"undefined\" != typeof Symbol && Symbol.iterator || \"@@iterator\"] = function () {\n    return this;\n  }, iter.next = function (value) {\n    return waiting ? (waiting = !1, value) : pump(\"next\", value);\n  }, \"function\" == typeof inner[\"throw\"] && (iter[\"throw\"] = function (value) {\n    if (waiting) throw waiting = !1, value;\n    return pump(\"throw\", value);\n  }), \"function\" == typeof inner[\"return\"] && (iter[\"return\"] = function (value) {\n    return waiting ? (waiting = !1, value) : pump(\"return\", value);\n  }), iter;\n}","export default function _asyncIterator(iterable) {\n  var method,\n    async,\n    sync,\n    retry = 2;\n  for (\"undefined\" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;) {\n    if (async && null != (method = iterable[async])) return method.call(iterable);\n    if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));\n    async = \"@@asyncIterator\", sync = \"@@iterator\";\n  }\n  throw new TypeError(\"Object is not async iterable\");\n}\nfunction AsyncFromSyncIterator(s) {\n  function AsyncFromSyncIteratorContinuation(r) {\n    if (Object(r) !== r) return Promise.reject(new TypeError(r + \" is not an object.\"));\n    var done = r.done;\n    return Promise.resolve(r.value).then(function (value) {\n      return {\n        value: value,\n        done: done\n      };\n    });\n  }\n  return AsyncFromSyncIterator = function AsyncFromSyncIterator(s) {\n    this.s = s, this.n = s.next;\n  }, AsyncFromSyncIterator.prototype = {\n    s: null,\n    n: null,\n    next: function next() {\n      return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));\n    },\n    \"return\": function _return(value) {\n      var ret = this.s[\"return\"];\n      return void 0 === ret ? Promise.resolve({\n        value: value,\n        done: !0\n      }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));\n    },\n    \"throw\": function _throw(value) {\n      var thr = this.s[\"return\"];\n      return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));\n    }\n  }, new AsyncFromSyncIterator(s);\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function _awaitAsyncGenerator(value) {\n  return new OverloadYield(value, 0);\n}","import OverloadYield from \"./OverloadYield.js\";\nexport default function AsyncGenerator(gen) {\n  var front, back;\n  function resume(key, arg) {\n    try {\n      var result = gen[key](arg),\n        value = result.value,\n        overloaded = value instanceof OverloadYield;\n      Promise.resolve(overloaded ? value.v : value).then(function (arg) {\n        if (overloaded) {\n          var nextKey = \"return\" === key ? \"return\" : \"next\";\n          if (!value.k || arg.done) return resume(nextKey, arg);\n          arg = gen[nextKey](arg).value;\n        }\n        settle(result.done ? \"return\" : \"normal\", arg);\n      }, function (err) {\n        resume(\"throw\", err);\n      });\n    } catch (err) {\n      settle(\"throw\", err);\n    }\n  }\n  function settle(type, value) {\n    switch (type) {\n      case \"return\":\n        front.resolve({\n          value: value,\n          done: !0\n        });\n        break;\n      case \"throw\":\n        front.reject(value);\n        break;\n      default:\n        front.resolve({\n          value: value,\n          done: !1\n        });\n    }\n    (front = front.next) ? resume(front.key, front.arg) : back = null;\n  }\n  this._invoke = function (key, arg) {\n    return new Promise(function (resolve, reject) {\n      var request = {\n        key: key,\n        arg: arg,\n        resolve: resolve,\n        reject: reject,\n        next: null\n      };\n      back ? back = back.next = request : (front = back = request, resume(key, arg));\n    });\n  }, \"function\" != typeof gen[\"return\"] && (this[\"return\"] = void 0);\n}\nAsyncGenerator.prototype[\"function\" == typeof Symbol && Symbol.asyncIterator || \"@@asyncIterator\"] = function () {\n  return this;\n}, AsyncGenerator.prototype.next = function (arg) {\n  return this._invoke(\"next\", arg);\n}, AsyncGenerator.prototype[\"throw\"] = function (arg) {\n  return this._invoke(\"throw\", arg);\n}, AsyncGenerator.prototype[\"return\"] = function (arg) {\n  return this._invoke(\"return\", arg);\n};","import AsyncGenerator from \"./AsyncGenerator.js\";\nexport default function _wrapAsyncGenerator(fn) {\n  return function () {\n    return new AsyncGenerator(fn.apply(this, arguments));\n  };\n}"],"names":["VirtualOffset","blockPosition","dataPosition","_classCallCheck","this","_createClass","key","value","concat","b","min","i","_len","arguments","length","args","Array","_key","compareTo","fromBytes","bytes","offset","undefined","Error","Chunk","minv","maxv","bin","_fetchedSize","fetchedSize","toUniqueString","timeout","ms","Promise","resolve","setTimeout","checkAbortSignal","signal","aborted","DOMException","e","code","makeOpts","obj","optimizeChunks","chunks","lowest","lastChunk","mergedChunks","sort","c0","c1","dif","_step","chunk1","chunk2","_iterator","_createForOfIteratorHelper","s","n","done","chunk","push","err","f","parsePseudoBin","lineCount","long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","longToNumber","Long","prototype","slice","call","findFirstData","firstDataLine","virtualOffset","IndexFile","_ref","filehandle","_ref$renameRefSeq","renameRefSeq","roundDown","multiple","reg2bins","beg","end","BAI","_IndexFile","_inherits","_super","_createSuper","apply","_lineCount","_asyncToGenerator","_regeneratorRuntime","mark","_callee","refId","opts","_a","_b","indexData","wrap","_context","prev","next","parse","sent","abrupt","indices","stats","stop","_x","_x2","_parse2","_callee2","refCount","binLimit","curr","binCount","binIndex","j","chunkCount","k","u","v","linearCount","linearIndex","_j","_context2","readFile","readUInt32LE","readInt32LE","bai","maxBlockSize","_x3","_indexCov","_callee3","seqId","start","range","seqIdx","_seqIdx$linearIndex","depths","totalSize","currentPos","_args3","_context3","score","map","d","_objectSpread","_x4","_x5","_x6","_blocksForRange","_callee4","max","ba","overlappingBins","_step$value","binChunks","_iterator2","_step2","binChunk","nintv","minLin","maxLin","vp","_args4","_context4","_slicedToArray","Math","_x7","_x8","_x9","_parse3","_callee5","_this","_args5","_context5","setupP","_parse","catch","_hasRefSeq","_callee6","header","_args6","_context6","_x10","rshift","num","bits","floor","pow","CSI","maxBinNumber","depth","minShift","formatFlags","coordinateType","format","columnNumbers","ref","metaValue","metaChar","String","fromCharCode","skipLines","nameSectionLength","namesBytes","currRefId","currNameStart","refIdToName","refNameToId","refName","toString","parseNameBytes","subarray","buffer","csiVersion","auxLength","aux","unzip","parseAuxData","csi","c","l","t","bins","_this2","SEQRET_DECODER","split","CIGAR_DECODER","BamRecord","data","_tagList","_allTagsParsed","fileOffset","byteArray","_id","_refID","flags","field","_get","toLowerCase","get","_parseTag","_parseAllTags","tags","isSegmentUnmapped","isPaired","_i","_Object$keys","Object","keys","seen","filter","lt","mq","qualRaw","join","_this$bytes","p","lseq","isReverseComplemented","isMateUnmapped","isMateReverseComplemented","nl","_this$bytes2","tagName","lcTag","_this$bytes3","_tagOffset","blockEnd","tag","type","readInt8","readUInt8","readInt16LE","readUInt16LE","readFloatLE","cc","Btype","limit","cigop","console","warn","cigar","match","op","toUpperCase","parseInt","Constants","_this$bytes4","numCigarOps","seqLen","lref","lop","length_on_ref","seq","_this$bytes5","seqBytes","len","buf","sb","_next_refid","s1","s2","o1","o2","isRead1","isRead2","tmp","template_length","_i2","_Object$keys2","charAt","parseHeaderText","text","lines","_line$split","_line$split2","_toArray","fields","_f$split","_f$split2","BAM_MAGIC","gen2array","_gen2array","_callee17","gen","out","_iteratorAbruptCompletion","_didIteratorError","_iteratorError","x","_context17","_asyncIterator","t0","return","finish","NullFilehandle","BamFile","_this3","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","htsget","_ref$yieldThreadTime","yieldThreadTime","_ref$renameRefSeqs","renameRefSeqs","featureCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","_fill","_yield$_this3$_readCh","cpositions","dpositions","_readChunk","readBamFeatures","bam","LocalFile","RemoteFile","index","_getHeaderPre","origOpts","ret","res","uncba","headLen","_yield$this$_readRefS","chrToIndex","indexToChr","read","Buffer","alloc","bytesRead","_readRefSeqs","_this4","headerP","getHeaderPre","_getHeaderText","getHeader","_readRefSeqs2","refSeqBytes","size","_yield$this$bam$read","nRef","lName","lRef","_getRecordsForRange","chr","streamRecordsForRange","_x11","_wrapAsyncGenerator","chrId","_awaitAsyncGenerator","blocksForRange","delegateYield","_asyncGeneratorDelegate","_fetchChunkFeatures","_callee7","viewAsPairs","feats","records","recs","_iterator3","_step3","feature","_context7","seq_id","t1","fetchPairs","_fetchPairs","_callee9","pairAcrossChr","_opts$maxInsertSize","maxInsertSize","unmatedPairs","readIds","matePromises","_iterator6","_step6","m","mateFeatPromises","_this5","_context9","_step4","readNames","_iterator4","element","name","id","_Object$entries","entries","_Object$entries$_i","_step5","_iterator5","pnext","_next_pos","rnext","abs","Map","all","flat","has","set","_toConsumableArray","values","_ref2","_callee8","_yield$_this5$_readCh","mateRecs","_iterator7","_step7","_context8","_x15","_x12","_x13","_x14","_readRegion2","_callee10","position","_yield$this$bam$read2","_args10","_context10","_x16","_x17","_readChunk2","_callee11","_ref3","_yield$unzipChunkSlic","_context11","_readRegion","unzipChunkSlice","_x18","_readBamFeatures","_callee12","blockStart","sink","pos","last","blockSize","_context12","Date","now","BAMFeature","crc32","_x19","_x20","_x21","_x22","_callee13","seqName","_context13","hasRefSeq","_x23","_callee14","_context14","_x24","_callee15","_context15","indexCov","_x25","_x26","_x27","_callee16","_context16","_x28","_x29","_x30","_x31","_concat","arr","url","headers","rest","_res","startsWith","from","referer","_objectWithoutProperties","_excluded","fetch","ok","status","t2","t3","t4","arrayBuffer","t5","elt","HtsgetFile","_BamFile","baseUrl","trackId","base","result","json","urls","_getHeader","headerText","samHeader","idToName","nameToId","sqLines","sqLine","item","require","__importDefault","mod","__esModule","defineProperty","exports","abortcontroller_ponyfill_1","AggregateAbortController_1","AggregateStatusReporter_1","TypeError","delete","fillCallback","entry","statusCallback","aborter","default","statusReporter","addCallback","newEntry","promise","message","callback","settled","addSignal","addEventListener","evict","then","error","AbortSignal","cacheEntry","checkSinglePromise","cachedEntry","abort","keyIter","deleteCount","exception","checkForSingleAbort","assign","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","add","handleAborted","AggregateStatusReporter","callbacks","currentMessage","forEach","cjs_ponyfill_1","getGlobal","self","window","global","AbortablePromiseCache_1","_OverloadYield","kind","inner","iter","waiting","pump","Symbol","iterator","iterable","method","async","sync","retry","asyncIterator","AsyncFromSyncIterator","AsyncFromSyncIteratorContinuation","r","reject","thr","AsyncGenerator","front","back","resume","arg","overloaded","OverloadYield","nextKey","settle","_invoke","request","fn"],"sourceRoot":""}