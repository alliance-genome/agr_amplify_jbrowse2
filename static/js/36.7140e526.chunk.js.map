{"version":3,"sources":["../../../plugins/alignments/src/HtsgetBamAdapter/HtsgetBamAdapter.ts","../../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","../../../plugins/alignments/src/BamAdapter/BamAdapter.ts"],"names":["HtsgetBamAdapter","this","configured","htsgetBase","readConfObject","config","htsgetTrackId","bam","HtsgetFile","baseUrl","trackId","adapterConfig","getSubAdapter","then","dataAdapter","sequenceAdapter","Promise","resolve","BamAdapter","BamSlightlyLazyFeature","record","adapter","ref","get","flags","isReverseComplemented","isPaired","getPairOrientation","undefined","_next_refid","_refID","refIdToName","_next_pos","getReadBases","md","seq","generateMD","qualRaw","properties","Object","getOwnPropertyNames","prototype","Set","filter","prop","startsWith","map","methodName","replace","concat","_tags","id","field","seq_id","fromEntries","tags","t","elt","uniqueId","opts","cigarAttributeName","mismatches","cigarOps","cigarString","parseCigar","cigarToMismatches","mdAttributeName","qual","mdString","mdToMismatches","seen","m","key","type","start","length","s","cigar","match","samHeader","setupP","bamLocation","location","indexType","chunkSizeLimit","BamFile","bamFilehandle","openLocation","pluginManager","csiFilehandle","baiFilehandle","fetchSizeLimit","a","configure","getHeaderText","statusCallback","updateStatus","getHeader","idToName","nameToId","l","tag","forEach","sqLine","refId","data","item","refName","value","setupPre","catch","e","setup","end","refSeqStore","features","getFeatures","assemblyName","pipe","toArray","toPromise","seqChunks","trimmed","sort","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","chunkSeq","push","substr","sequence","join","Error","toLocaleString","region","originalRefName","signal","ObservableCreate","observer","getRecordsForRange","records","checkAbortSignal","seqFetch","next","complete","regions","index","filehandle","bytesForRegions","bytes","BaseFeatureDataAdapter"],"mappings":"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","file":"static/js/36.7140e526.chunk.js","sourcesContent":["import { BamFile, HtsgetFile } from '@gmod/bam'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport BamAdapter from '../BamAdapter/BamAdapter'\n\nexport default class HtsgetBamAdapter extends BamAdapter {\n  protected async configure() {\n    if (!this.configured) {\n      const htsgetBase = readConfObject(this.config, 'htsgetBase')\n      const htsgetTrackId = readConfObject(this.config, 'htsgetTrackId')\n      const bam = new HtsgetFile({\n        baseUrl: htsgetBase,\n        trackId: htsgetTrackId,\n      }) as unknown as BamFile\n\n      const adapterConfig = readConfObject(this.config, 'sequenceAdapter')\n      if (adapterConfig && this.getSubAdapter) {\n        this.configured = this.getSubAdapter(adapterConfig).then(\n          ({ dataAdapter }) => {\n            return {\n              bam,\n              sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n            }\n          },\n        )\n      }\n      this.configured = Promise.resolve({ bam })\n    }\n    return this.configured\n  }\n}\n","/* eslint-disable no-underscore-dangle */\nimport {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\nimport { BamRecord } from '@gmod/bam'\nimport {\n  parseCigar,\n  generateMD,\n  cigarToMismatches,\n  mdToMismatches,\n  Mismatch,\n} from './MismatchParser'\n\nimport BamAdapter from './BamAdapter'\n\nexport default class BamSlightlyLazyFeature implements Feature {\n  constructor(\n    private record: BamRecord,\n    private adapter: BamAdapter,\n    private ref?: string,\n  ) {}\n\n  _get_name() {\n    return this.record.get('name')\n  }\n\n  _get_type(): string {\n    return 'match'\n  }\n\n  _get_score(): number {\n    return this.record.get('mq')\n  }\n\n  _get_flags(): string {\n    return this.record.flags\n  }\n\n  _get_strand(): number {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  _get_pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  _get_next_seq_id() {\n    return this.record._next_refid()\n  }\n\n  _get_seq_id() {\n    // @ts-ignore\n    return this.record._refID\n  }\n\n  _get_next_refName() {\n    return this.adapter.refIdToName(this.record._next_refid())\n  }\n\n  _get_next_segment_position() {\n    const { record, adapter } = this\n    return record.isPaired()\n      ? `${adapter.refIdToName(record._next_refid())}:${record._next_pos() + 1}`\n      : undefined\n  }\n\n  _get_seq() {\n    return this.record.getReadBases()\n  }\n\n  _get_MD() {\n    const md = this.record.get('MD') as string | undefined\n    const seq = this.get('seq') as string\n    if (!md && seq && this.ref) {\n      return generateMD(this.ref, this.record.getReadBases(), this.get('CIGAR'))\n    }\n    return md\n  }\n\n  qualRaw() {\n    return this.record.qualRaw()\n  }\n\n  set() {}\n\n  tags() {\n    const properties = Object.getOwnPropertyNames(\n      BamSlightlyLazyFeature.prototype,\n    )\n\n    return [\n      ...new Set(\n        properties\n          .filter(\n            prop =>\n              prop.startsWith('_get_') &&\n              prop !== '_get_mismatches' &&\n              prop !== '_get_skips_and_dels' &&\n              prop !== '_get_cram_read_features' &&\n              prop !== '_get_tags' &&\n              prop !== '_get_next_seq_id' &&\n              prop !== '_get_seq_id',\n          )\n          .map(methodName => methodName.replace('_get_', ''))\n          .concat(this.record._tags()),\n      ),\n    ]\n  }\n\n  id() {\n    return `${this.adapter.id}-${this.record.id()}`\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  get(field: string): any {\n    const methodName = `_get_${field}`\n    // @ts-ignore\n    if (this[methodName]) {\n      // @ts-ignore\n      return this[methodName]()\n    }\n    return this.record.get(field)\n  }\n\n  _get_refName() {\n    return this.adapter.refIdToName(this.record.seq_id())\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  pairedFeature() {\n    return false\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...Object.fromEntries(\n        this.tags()\n          .map(t => [t, this.get(t)])\n          .filter(elt => elt[1] !== undefined),\n      ),\n      uniqueId: this.id(),\n    }\n  }\n\n  _get_skips_and_dels(\n    opts: {\n      cigarAttributeName: string\n    } = {\n      cigarAttributeName: 'CIGAR',\n    },\n  ) {\n    const { cigarAttributeName } = opts\n    let mismatches: Mismatch[] = []\n    let cigarOps: string[] = []\n\n    // parse the CIGAR tag if it has one\n    const cigarString = this.get(cigarAttributeName)\n    if (cigarString) {\n      cigarOps = parseCigar(cigarString)\n      mismatches = mismatches.concat(\n        cigarToMismatches(cigarOps, this.get('seq'), this.qualRaw()),\n      )\n    }\n    return mismatches\n  }\n\n  _get_mismatches({\n    cigarAttributeName = 'CIGAR',\n    mdAttributeName = 'MD',\n  }: {\n    cigarAttributeName?: string\n    mdAttributeName?: string\n  } = {}) {\n    let mismatches: Mismatch[] = []\n    let cigarOps: string[] = []\n\n    // parse the CIGAR tag if it has one\n    const cigarString = this.get(cigarAttributeName)\n    const seq = this.get('seq')\n    const qual = this.qualRaw()\n    if (cigarString) {\n      cigarOps = parseCigar(cigarString)\n      mismatches = mismatches.concat(cigarToMismatches(cigarOps, seq, qual))\n    }\n\n    // now let's look for CRAM or MD mismatches\n    const mdString = this.get(mdAttributeName)\n    if (mdString) {\n      mismatches = mismatches.concat(\n        mdToMismatches(mdString, cigarOps, mismatches, seq, qual),\n      )\n    }\n\n    // uniqify the mismatches\n    const seen: { [index: string]: boolean } = {}\n    return mismatches.filter(m => {\n      const key = `${m.type},${m.start},${m.length}`\n      const s = seen[key]\n      seen[key] = true\n      return !s\n    })\n  }\n\n  _get_clipPos() {\n    const cigar = this.get('CIGAR') || ''\n    return this.get('strand') === -1\n      ? +(cigar.match(/(\\d+)[SH]$/) || [])[1] || 0\n      : +(cigar.match(/^(\\d+)([SH])/) || [])[1] || 0\n  }\n}\n","import { BamFile } from '@gmod/bam'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport {\n  checkAbortSignal,\n  bytesForRegions,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { toArray } from 'rxjs/operators'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature'\n\ninterface Header {\n  idToName: string[]\n  nameToId: Record<string, number>\n}\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  private samHeader?: Header\n\n  private setupP?: Promise<Header>\n\n  protected configured?: Promise<{\n    bam: BamFile\n    sequenceAdapter?: BaseFeatureDataAdapter\n  }>\n\n  // derived classes may not use the same configuration so a custom\n  // configure method allows derived classes to override this behavior\n  protected async configure() {\n    if (!this.configured) {\n      const bamLocation = readConfObject(this.config, 'bamLocation')\n      const location = readConfObject(this.config, ['index', 'location'])\n      const indexType = readConfObject(this.config, ['index', 'indexType'])\n      const chunkSizeLimit = readConfObject(this.config, 'chunkSizeLimit')\n      const bam = new BamFile({\n        bamFilehandle: openLocation(bamLocation, this.pluginManager),\n        csiFilehandle:\n          indexType === 'CSI'\n            ? openLocation(location, this.pluginManager)\n            : undefined,\n        baiFilehandle:\n          indexType !== 'CSI'\n            ? openLocation(location, this.pluginManager)\n            : undefined,\n        chunkSizeLimit,\n        fetchSizeLimit: 100_000_000,\n      })\n\n      const adapterConfig = readConfObject(this.config, 'sequenceAdapter')\n      if (adapterConfig && this.getSubAdapter) {\n        this.configured = this.getSubAdapter(adapterConfig).then(\n          ({ dataAdapter }) => ({\n            bam,\n            sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n          }),\n        )\n      } else {\n        this.configured = Promise.resolve({ bam })\n      }\n    }\n    return this.configured\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    return bam.getHeaderText(opts)\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const { bam } = await this.configure()\n    this.samHeader = await updateStatus(\n      'Downloading index',\n      statusCallback,\n      async () => {\n        const samHeader = await bam.getHeader(opts)\n\n        // use the @SQ lines in the header to figure out the\n        // mapping between ref ref ID numbers and names\n        const idToName: string[] = []\n        const nameToId: Record<string, number> = {}\n        samHeader\n          .filter(l => l.tag === 'SQ')\n          .forEach((sqLine, refId) => {\n            sqLine.data.forEach(item => {\n              if (item.tag === 'SN') {\n                // this is the ref name\n                const refName = item.value\n                nameToId[refName] = refId\n                idToName[refId] = refName\n              }\n            })\n          })\n\n        return { idToName, nameToId }\n      },\n    )\n    return this.samHeader\n  }\n\n  private async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch(e => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  private async seqFetch(refName: string, start: number, end: number) {\n    const { sequenceAdapter } = await this.configure()\n    const refSeqStore = sequenceAdapter\n    if (!refSeqStore) {\n      return undefined\n    }\n    if (!refName) {\n      return undefined\n    }\n\n    const features = refSeqStore.getFeatures({\n      refName,\n      start,\n      end,\n      assemblyName: '',\n    })\n\n    const seqChunks = await features.pipe(toArray()).toPromise()\n\n    const trimmed: string[] = []\n    seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .forEach(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        trimmed.push(chunkSeq.substr(trimStart, trimLength))\n      })\n\n    const sequence = trimmed.join('')\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions,\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { signal, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = await this.configure()\n      await this.setup(opts)\n      statusCallback('Downloading alignments')\n      const records = await bam.getRecordsForRange(refName, start, end, opts)\n\n      checkAbortSignal(signal)\n\n      for (const record of records) {\n        let ref: string | undefined\n        if (!record.get('md')) {\n          ref = await this.seqFetch(\n            originalRefName || refName,\n            record.get('start'),\n            record.get('end'),\n          )\n        }\n        observer.next(new BamSlightlyLazyFeature(record, this, ref))\n      }\n      statusCallback('')\n      observer.complete()\n    }, signal)\n  }\n\n  async estimateRegionsStats(regions: Region[], opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    // this is a method to avoid calling on htsget adapters\n    // @ts-ignore\n    if (bam.index.filehandle !== '?') {\n      const bytes = await bytesForRegions(regions, bam)\n      const fetchSizeLimit = readConfObject(this.config, 'fetchSizeLimit')\n      return { bytes, fetchSizeLimit }\n    } else {\n      return super.estimateRegionsStats(regions, opts)\n    }\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // depends on setup being called before the BAM constructor\n  refIdToName(refId: number): string | undefined {\n    return this.samHeader?.idToName[refId]\n  }\n}\n"],"sourceRoot":""}