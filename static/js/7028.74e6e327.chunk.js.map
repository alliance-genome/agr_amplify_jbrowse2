{"version":3,"file":"static/js/7028.74e6e327.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/twobit/src/twoBitFile.ts","../../../plugins/sequence/src/TwoBitAdapter/TwoBitAdapter.ts"],"sourcesContent":["import Long from 'long'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\nimport { Parser } from '@gmod/binary-parser'\n\nconst TWOBIT_MAGIC = 0x1a412743\n\nfunction tinyMemoize(_class: any, methodName: string) {\n  const method = _class.prototype[methodName]\n  const memoAttrName = `_memo_${methodName}`\n  _class.prototype[methodName] = function _tinyMemoized() {\n    if (!(memoAttrName in this)) {\n      this[memoAttrName] = method.call(this)\n    }\n    return this[memoAttrName]\n  }\n}\n\nconst twoBit = ['T', 'C', 'A', 'G']\n// byteTo4Bases is an array of byteValue -> 'ACTG'\n// the weird `...keys()` incantation generates an array of numbers 0 to 255\nconst byteTo4Bases = [] as string[]\nfor (let i = 0; i < 256; i++) {\n  byteTo4Bases.push(\n    twoBit[(i >> 6) & 3] +\n      twoBit[(i >> 4) & 3] +\n      twoBit[(i >> 2) & 3] +\n      twoBit[i & 3],\n  )\n}\n\ntype ParserName = 'header' | 'index' | 'record1' | 'record2' | 'record3'\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase())\n\nexport default class TwoBitFile {\n  private filehandle: GenericFilehandle\n  private isBigEndian?: boolean\n  private version?: number\n\n  /**\n   * @param {object} args\n   * @param {string} [args.path] filesystem path for the .2bit file to open\n   * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n   *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n   */\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new Error('must supply path or filehandle')\n    }\n    this.isBigEndian = undefined\n  }\n\n  async _getParser(name: ParserName) {\n    const parser = (await this._getParsers())[name]\n    if (!parser) {\n      throw new Error(`parser ${name} not found`)\n    }\n    return parser\n  }\n\n  async _detectEndianness() {\n    const ret = await this.filehandle.read(Buffer.allocUnsafe(8), 0, 8, 0)\n    const { buffer } = ret\n    if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {\n      this.isBigEndian = false\n      this.version = buffer.readInt32LE(4)\n    } else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {\n      this.isBigEndian = true\n      this.version = buffer.readInt32BE(4)\n    } else {\n      throw new Error('not a 2bit file')\n    }\n  }\n\n  // memoize\n  /**\n   * @private\n   * detects the file's endianness and instantiates our binary parsers accordingly\n   */\n  async _getParsers() {\n    await this._detectEndianness()\n\n    const endianess = this.isBigEndian ? 'big' : 'little'\n    const lebe = this.isBigEndian ? 'be' : 'le'\n\n    let indexEntryParser = new Parser()\n      .endianess(endianess)\n      .uint8('nameLength')\n      .string('name', { length: 'nameLength' })\n    if (this.version === 1) {\n      indexEntryParser = indexEntryParser.buffer('offsetBytes', {\n        length: 8,\n      })\n    } else {\n      indexEntryParser = indexEntryParser.uint32('offset')\n    }\n    /* istanbul ignore next */\n    const header = new Parser()\n      .endianess(endianess)\n      .int32('magic', {\n        assert: (m: number) => m === 0x1a412743,\n      })\n      .int32('version', {\n        /* istanbul ignore next */\n        assert: (v: number) => v === 0 || v === 1,\n      })\n      .uint32('sequenceCount', {\n        /* istanbul ignore next */\n        assert: (v: number) => v >= 0,\n      })\n      .uint32('reserved')\n\n    return {\n      header,\n      index: new Parser()\n        .endianess(endianess)\n        .uint32('sequenceCount')\n        .uint32('reserved')\n        .array('index', {\n          length: 'sequenceCount',\n          type: indexEntryParser,\n        }),\n      record1: new Parser()\n        .endianess(endianess)\n        .uint32('dnaSize')\n        .uint32('nBlockCount'),\n      record2: new Parser()\n        .endianess(endianess)\n        .uint32('nBlockCount')\n        .array('nBlockStarts', {\n          length: 'nBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .array('nBlockSizes', {\n          length: 'nBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .uint32('maskBlockCount'),\n      record3: new Parser()\n        .endianess(endianess)\n        .uint32('maskBlockCount')\n        .array('maskBlockStarts', {\n          length: 'maskBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .array('maskBlockSizes', {\n          length: 'maskBlockCount',\n          type: `uint32${lebe}`,\n        })\n        .int32('reserved'),\n      // .buffer('packedDna', { length: 'dnaSize' }),\n    }\n  }\n\n  // memoize\n  /**\n   * @returns {Promise} for object with the file's header information, like\n   *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`\n   */\n  async getHeader() {\n    await this._detectEndianness()\n\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(16),\n      0,\n      16,\n      0,\n    )\n    const headerParser = await this._getParser('header')\n    return headerParser.parse(buffer).result\n  }\n\n  // memoize\n  /**\n   * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`\n   */\n  async getIndex() {\n    const header = await this.getHeader()\n    const maxIndexLength =\n      8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4))\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(maxIndexLength),\n      0,\n      maxIndexLength,\n      8,\n    )\n    const indexParser = await this._getParser('index')\n    const indexData = indexParser.parse(buffer).result.index\n    const index = {} as { [key: string]: number }\n    if (this.version === 1) {\n      indexData.forEach(\n        ({ name, offsetBytes }: { name: string; offsetBytes: number }) => {\n          const long = Long.fromBytes(offsetBytes, true, !this.isBigEndian)\n          if (long.greaterThan(Number.MAX_SAFE_INTEGER)) {\n            throw new Error(\n              'integer overflow. File offset greater than 2^53-1 encountered. This library can only handle offsets up to 2^53-1.',\n            )\n          }\n          index[name] = long.toNumber()\n        },\n      )\n    } else {\n      indexData.forEach(\n        ({ name, offset }: { name: string; offset: number }) => {\n          index[name] = offset\n        },\n      )\n    }\n    return index\n  }\n\n  /**\n   * @returns {Promise} for an array of string sequence names that are found in the file\n   */\n  async getSequenceNames() {\n    const index = await this.getIndex()\n    return Object.keys(index)\n  }\n\n  /**\n   * @returns {Promise} for an object listing the lengths of all sequences like `{seqName: length, ...}`\n   */\n  async getSequenceSizes() {\n    const index = await this.getIndex()\n    const seqNames = Object.keys(index)\n    const sizePromises = Object.values(index).map(offset =>\n      this._getSequenceSize(offset as number),\n    )\n    const sizes = await Promise.all(sizePromises)\n    const returnObject = {} as { [key: string]: number }\n    for (let i = 0; i < seqNames.length; i += 1) {\n      returnObject[seqNames[i]] = sizes[i]\n    }\n    return returnObject\n  }\n\n  /**\n   * @param {string} seqName name of the sequence\n   * @returns {Promise} for the sequence's length, or undefined if it is not in the file\n   */\n  async getSequenceSize(seqName: string) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    return this._getSequenceSize(offset)\n  }\n\n  async _getSequenceSize(offset: number) {\n    // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads\n    if (offset === undefined || offset < 0) {\n      throw new Error('invalid offset')\n    }\n    const rec1 = await this._parseItem(offset, 8, 'record1')\n    return rec1.dnaSize\n  }\n\n  async _getSequenceRecord(offset: number) {\n    // we have to parse the sequence record in 3 parts, because we have to buffer 3 fixed-length file reads\n    if (offset === undefined || offset < 0) {\n      throw new Error('invalid offset')\n    }\n    const rec1 = await this._parseItem(offset, 8, 'record1')\n    const rec2DataLength = rec1.nBlockCount * 8 + 8\n    const rec2 = await this._parseItem(offset + 4, rec2DataLength, 'record2')\n    const rec3DataLength = rec2.maskBlockCount * 8 + 8\n    const rec3 = await this._parseItem(\n      offset + 4 + rec2DataLength - 4,\n      rec3DataLength,\n      'record3',\n    )\n\n    const rec = {\n      dnaSize: rec1.dnaSize,\n      nBlocks: { starts: rec2.nBlockStarts, sizes: rec2.nBlockSizes },\n      maskBlocks: { starts: rec3.maskBlockStarts, sizes: rec3.maskBlockSizes },\n      dnaPosition: offset + 4 + rec2DataLength - 4 + rec3DataLength,\n    }\n    return rec\n  }\n\n  async _parseItem(offset: number, length: number, parserName: ParserName) {\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(length),\n      0,\n      length,\n      offset,\n    )\n    const parser = await this._getParser(parserName)\n    return parser.parse(buffer).result\n  }\n\n  /**\n   * @param {string} seqName name of the sequence you want\n   * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.\n   * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence\n   * @returns {Promise} for a string of sequence bases\n   */\n  async getSequence(seqName: string, regionStart = 0, regionEnd: number) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    // fetch the record for the seq\n    const record = await this._getSequenceRecord(offset)\n\n    if (regionStart < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    // end defaults to the end of the sequence\n    if (regionEnd === undefined || regionEnd > record.dnaSize) {\n      regionEnd = record.dnaSize\n    }\n\n    const nBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.nBlocks.starts,\n      record.nBlocks.sizes,\n    )\n    const maskBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.maskBlocks.starts,\n      record.maskBlocks.sizes,\n    )\n\n    const baseBytes = Buffer.allocUnsafe(\n      Math.ceil((regionEnd - regionStart) / 4) + 1,\n    )\n    const baseBytesOffset = Math.floor(regionStart / 4)\n    const { buffer } = await this.filehandle.read(\n      baseBytes,\n      0,\n      baseBytes.length,\n      record.dnaPosition + baseBytesOffset,\n    )\n\n    let sequenceBases = ''\n    for (\n      let genomicPosition = regionStart;\n      genomicPosition < regionEnd;\n      genomicPosition += 1\n    ) {\n      // check whether we are currently masked\n      while (maskBlocks.length && maskBlocks[0].end <= genomicPosition) {\n        maskBlocks.shift()\n      }\n      const baseIsMasked =\n        maskBlocks[0] &&\n        maskBlocks[0].start <= genomicPosition &&\n        maskBlocks[0].end > genomicPosition\n\n      // process the N block if we have one\n      if (\n        nBlocks[0] &&\n        genomicPosition >= nBlocks[0].start &&\n        genomicPosition < nBlocks[0].end\n      ) {\n        const currentNBlock = nBlocks.shift()\n        for (\n          ;\n          genomicPosition < currentNBlock.end && genomicPosition < regionEnd;\n          genomicPosition += 1\n        ) {\n          sequenceBases += baseIsMasked ? 'n' : 'N'\n        }\n        genomicPosition -= 1\n      } else {\n        const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset\n        const subPosition = genomicPosition % 4\n        const byte = buffer[bytePosition]\n        sequenceBases += baseIsMasked\n          ? maskedByteTo4Bases[byte][subPosition]\n          : byteTo4Bases[byte][subPosition]\n      }\n    }\n\n    return sequenceBases\n  }\n\n  _getOverlappingBlocks(\n    regionStart: number,\n    regionEnd: number,\n    blockStarts: number[],\n    blockSizes: number[],\n  ) {\n    // find the start and end indexes of the blocks that match\n    let startIndex\n    let endIndex\n    for (let i = 0; i < blockStarts.length; i += 1) {\n      const blockStart = blockStarts[i]\n      const blockSize = blockSizes[i]\n      if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n        // block does not overlap the region\n        if (startIndex !== undefined) {\n          endIndex = i\n          break\n        }\n      } else if (startIndex === undefined) {\n        startIndex = i\n      } // block does overlap the region, record this if it is the first\n    }\n\n    if (startIndex === undefined) {\n      return []\n    }\n\n    // now format some block objects to return\n    if (endIndex === undefined) {\n      endIndex = blockStarts.length\n    }\n\n    const blocks = new Array(endIndex - startIndex)\n    for (let blockNum = startIndex; blockNum < endIndex; blockNum += 1) {\n      blocks[blockNum - startIndex] = {\n        start: blockStarts[blockNum],\n        end: blockStarts[blockNum] + blockSizes[blockNum],\n        size: blockSizes[blockNum],\n      }\n    }\n    return blocks\n  }\n}\n\ntinyMemoize(TwoBitFile, '_getParsers')\ntinyMemoize(TwoBitFile, 'getIndex')\ntinyMemoize(TwoBitFile, 'getHeader')\n","import { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TwoBitFile } from '@gmod/twobit'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration/configurationSchema'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n  private twobit: TwoBitFile\n\n  // the chromSizesData can be used to speed up loading since TwoBit has to do\n  // many range requests at startup to perform the getRegions request\n  protected chromSizesData: Promise<Record<string, number> | undefined>\n\n  private async initChromSizes() {\n    const conf = readConfObject(this.config, 'chromSizesLocation')\n    // check against default and empty in case someone makes the field blank in\n    // config editor, may want better way to check \"optional config slots\" in\n    // future\n    if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n      const file = openLocation(conf, this.pluginManager)\n      const data = await file.readFile('utf8')\n      return Object.fromEntries(\n        data\n          ?.split('\\n')\n          .filter(line => !!line.trim())\n          .map(line => {\n            const [name, length] = line.split('\\t')\n            return [name, +length]\n          }),\n      )\n    }\n    return undefined\n  }\n\n  constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    this.chromSizesData = this.initChromSizes()\n    this.twobit = new TwoBitFile({\n      filehandle: openLocation(\n        readConfObject(config, 'twoBitLocation'),\n        this.pluginManager,\n      ),\n    })\n  }\n\n  public async getRefNames() {\n    const chromSizesData = await this.chromSizesData\n    if (chromSizesData) {\n      return Object.keys(chromSizesData)\n    }\n    return this.twobit.getSequenceNames()\n  }\n\n  public async getRegions(): Promise<NoAssemblyRegion[]> {\n    const chromSizesData = await this.chromSizesData\n    if (chromSizesData) {\n      return Object.keys(chromSizesData).map(refName => ({\n        refName,\n        start: 0,\n        end: chromSizesData[refName],\n      }))\n    }\n    const refSizes = await this.twobit.getSequenceSizes()\n    return Object.keys(refSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: refSizes[refName],\n    }))\n  }\n\n  /**\n   * Fetch features for a certain region\n   * @param param -\n   * @returns Observable of Feature objects in the region\n   */\n  public getFeatures({ refName, start, end }: NoAssemblyRegion) {\n    return ObservableCreate<Feature>(async observer => {\n      const size = await this.twobit.getSequenceSize(refName)\n      const regionEnd = size !== undefined ? Math.min(size, end) : end\n      const seq = await this.twobit.getSequence(refName, start, regionEnd)\n      if (seq) {\n        observer.next(\n          new SimpleFeature({\n            id: `${refName} ${start}-${regionEnd}`,\n            data: { refName, start, end: regionEnd, seq },\n          }),\n        )\n      }\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the forseeable future and can be purged\n   * from caches, etc\n   */\n  public freeResources(/* { region } */): void {}\n}\n"],"names":["TWOBIT_MAGIC","tinyMemoize","_class","methodName","method","prototype","memoAttrName","this","call","twoBit","byteTo4Bases","i","push","maskedByteTo4Bases","map","bases","toLowerCase","TwoBitFile","filehandle","path","Error","LocalFile","isBigEndian","undefined","name","_getParsers","parser","read","Buffer","allocUnsafe","ret","buffer","readInt32LE","version","readInt32BE","_detectEndianness","endianess","lebe","indexEntryParser","Parser","uint8","string","length","uint32","header","int32","assert","m","v","index","array","type","record1","record2","record3","_getParser","headerParser","parse","result","getHeader","maxIndexLength","sequenceCount","indexParser","indexData","forEach","offsetBytes","long","Long","greaterThan","Number","MAX_SAFE_INTEGER","toNumber","offset","getIndex","Object","keys","seqNames","sizePromises","values","_getSequenceSize","Promise","all","sizes","returnObject","seqName","_parseItem","rec1","dnaSize","rec2DataLength","nBlockCount","rec2","rec3DataLength","maskBlockCount","rec3","rec","nBlocks","starts","nBlockStarts","nBlockSizes","maskBlocks","maskBlockStarts","maskBlockSizes","dnaPosition","parserName","regionStart","regionEnd","_getSequenceRecord","record","TypeError","_getOverlappingBlocks","baseBytes","Math","ceil","baseBytesOffset","floor","sequenceBases","genomicPosition","end","shift","baseIsMasked","start","currentNBlock","bytePosition","subPosition","byte","blockStarts","blockSizes","startIndex","endIndex","blockStart","blocks","Array","blockNum","size","TwoBitAdapter","config","getSubAdapter","pluginManager","twobit","chromSizesData","initChromSizes","openLocation","readConfObject","conf","uri","file","readFile","data","fromEntries","split","filter","line","trim","getSequenceNames","refName","getSequenceSizes","refSizes","ObservableCreate","observer","getSequenceSize","min","getSequence","seq","next","SimpleFeature","id","complete","BaseSequenceAdapter"],"sourceRoot":""}