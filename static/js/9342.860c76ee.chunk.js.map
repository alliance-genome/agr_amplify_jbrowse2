{"version":3,"file":"static/js/9342.860c76ee.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nimport gff, { GFF3FeatureLineWithRefs } from '@gmod/gff'\n\nfunction isGzip(buf: Buffer) {\n  return buf[0] === 31 && buf[1] === 139 && buf[2] === 8\n}\n\nexport default class extends BaseFeatureDataAdapter {\n  protected gffFeatures?: Promise<{\n    header: string\n    intervalTree: Record<string, IntervalTree>\n  }>\n\n  private async loadDataP() {\n    const buffer = await openLocation(\n      readConfObject(this.config, 'gffLocation'),\n      this.pluginManager,\n    ).readFile()\n    const buf = isGzip(buffer) ? await unzip(buffer) : buffer\n    // 512MB  max chrome string length is 512MB\n    if (buf.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buf)\n    const lines = data.split('\\n')\n    const headerLines = []\n    for (let i = 0; i < lines.length && lines[i].startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n\n    const feats = gff.parseStringSync(data, {\n      parseFeatures: true,\n      parseComments: false,\n      parseDirectives: false,\n      parseSequences: false,\n    })\n\n    const intervalTree = feats\n      .flat()\n      .map(\n        (f, i) =>\n          new SimpleFeature({\n            data: this.featureData(f),\n            id: `${this.id}-offset-${i}`,\n          }),\n      )\n      .reduce((acc, obj) => {\n        const key = obj.get('refName')\n        if (!acc[key]) {\n          acc[key] = new IntervalTree()\n        }\n        acc[key].insert([obj.get('start'), obj.get('end')], obj)\n        return acc\n      }, {} as Record<string, IntervalTree>)\n\n    return { header, intervalTree }\n  }\n\n  private async loadData() {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP().catch(e => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTree } = await this.loadData()\n    return Object.keys(intervalTree)\n  }\n\n  public async getHeader() {\n    const { header } = await this.loadData()\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTree } = await this.loadData()\n        intervalTree[refName]\n          ?.search([start, end])\n          .forEach(f => observer.next(f))\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  private featureData(data: GFF3FeatureLineWithRefs) {\n    const f: Record<string, unknown> = { ...data }\n    ;(f.start as number) -= 1 // convert to interbase\n    if (data.strand === '+') {\n      f.strand = 1\n    } else if (data.strand === '-') {\n      f.strand = -1\n    } else if (data.strand === '.') {\n      f.strand = 0\n    } else {\n      f.strand = undefined\n    }\n    f.phase = Number(data.phase)\n    f.refName = data.seq_id\n    if (data.score === null) {\n      delete f.score\n    }\n    if (data.phase === null) {\n      delete f.score\n    }\n    const defaultFields = [\n      'start',\n      'end',\n      'seq_id',\n      'score',\n      'type',\n      'source',\n      'phase',\n      'strand',\n    ]\n    const dataAttributes = data.attributes || {}\n    Object.keys(dataAttributes).forEach(a => {\n      let b = a.toLowerCase()\n      if (defaultFields.includes(b)) {\n        // add \"suffix\" to tag name if it already exists\n        // reproduces behavior of NCList\n        b += '2'\n      }\n      if (dataAttributes[a] !== null) {\n        let attr: string | string[] | undefined = dataAttributes[a]\n        if (Array.isArray(attr) && attr.length === 1) {\n          ;[attr] = attr\n        }\n        f[b] = attr\n      }\n    })\n    f.refName = f.seq_id\n\n    // the SimpleFeature constructor takes care of recursively inflating subfeatures\n    if (data.child_features && data.child_features.length) {\n      f.subfeatures = data.child_features\n        .map(childLocs => childLocs.map(childLoc => this.featureData(childLoc)))\n        .flat()\n    }\n\n    delete f.child_features\n    delete f.data\n    delete f.derived_features\n    delete f.attributes\n    delete f.seq_id\n    return f\n  }\n\n  public freeResources(/* { region } */) {}\n}\n"],"names":["isGzip","buf","gffFeatures","openLocation","readConfObject","this","config","pluginManager","readFile","buffer","unzip","length","Error","data","TextDecoder","fatal","decode","lines","split","headerLines","i","startsWith","push","header","join","feats","gff","parseFeatures","parseComments","parseDirectives","parseSequences","intervalTree","flat","map","f","SimpleFeature","featureData","id","reduce","acc","obj","key","get","IntervalTree","insert","loadDataP","catch","e","undefined","loadData","Object","keys","query","opts","ObservableCreate","observer","start","end","refName","search","forEach","next","complete","error","signal","strand","phase","Number","seq_id","score","defaultFields","dataAttributes","attributes","a","b","toLowerCase","includes","attr","Array","isArray","child_features","subfeatures","childLocs","childLoc","derived_features","BaseFeatureDataAdapter"],"sourceRoot":""}