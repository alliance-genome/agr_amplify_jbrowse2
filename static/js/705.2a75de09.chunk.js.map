{"version":3,"file":"static/js/705.2a75de09.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/ucsc-hub/src/raStanza.ts","../../../node_modules/@gmod/ucsc-hub/src/raFile.ts","../../../node_modules/@gmod/ucsc-hub/src/trackDbFile.ts","../../../node_modules/@gmod/ucsc-hub/src/hubFile.ts","../../../node_modules/@gmod/ucsc-hub/src/genomesFile.ts"],"sourcesContent":["/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza. An additional method `add()` is available to take a raw line of text\n * and break it up into a key and value and add them to the class. This should\n * be favored over `set()` when possible, as it performs more validity checks\n * than using `set()`.\n *\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of the\n * stanza (`undefined` if the stanza has no lines yet).\n *\n * @property {undefined|string} name - The value of the first line of the\n * stanza, by which it is identified in an ra file  (`undefined` if the stanza\n * has no lines yet).\n *\n * @property {undefined|string} indent - The leading indent of the stanza,\n * which is the same for every line (`undefined` if the stanza has no lines\n * yet, `''` if there is no indent).\n *\n * @throws {Error} Throws if the stanza has blank lines, if the first line\n * doesn't have both a key and a value, if a key in the stanza is\n * duplicated, or if lines in the stanza have inconsistent indentation.\n * @param {(string|string[])} [stanza=[]] - An ra file stanza, either as a\n * string or a array of strings with one line per entry. Supports both LF and\n * CRLF line terminators.\n *\n * @param {object} options\n *\n * @param {boolean} options.checkIndent [true] - Check if a stanza is indented\n * consistently and keep track of the indentation\n */\nexport default class RaStanza extends Map<string, string> {\n  _checkIndent: boolean\n\n  _keyAndCommentOrder: string[]\n\n  _continuedLine?: string\n\n  indent?: string\n\n  name?: string\n\n  nameKey?: string\n\n  constructor(stanza: string | string[], options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzaLines: string[]\n    if (typeof stanza === 'string') {\n      stanzaLines = stanza.trimEnd().split(/\\r?\\n/)\n    } else if (!stanza) {\n      stanzaLines = []\n    } else {\n      stanzaLines = stanza\n    }\n    this._keyAndCommentOrder = []\n    stanzaLines.forEach(line => {\n      this.add(line)\n    })\n  }\n\n  /**\n   * Add a single line to the stanza. If the exact line already exists, does\n   * nothing.\n   * @param {string} line A stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  add(line: string) {\n    if (line === '') {\n      throw new Error('Invalid stanza, contained blank lines')\n    }\n    if (line.trim().startsWith('#')) {\n      this._keyAndCommentOrder.push(line.trim())\n      return this\n    }\n    if (line.trimEnd().endsWith('\\\\')) {\n      const trimmedLine = line.trimEnd().slice(0, -1)\n      if (this._continuedLine) {\n        this._continuedLine += trimmedLine.trimStart()\n      } else {\n        this._continuedLine = trimmedLine\n      }\n      return this\n    }\n    let combinedLine = line\n    if (this._continuedLine) {\n      combinedLine = this._continuedLine + combinedLine.trimStart()\n      this._continuedLine = undefined\n    }\n    if (this.indent || this._checkIndent) {\n      const indent = combinedLine.match(/^([ \\t]+)/)\n      if (this.indent === undefined) {\n        if (indent) {\n          ;[, this.indent] = indent\n        } else {\n          this.indent = ''\n        }\n      } else if (\n        (this.indent === '' && indent !== null) ||\n        (this.indent && indent && this.indent !== indent[1])\n      ) {\n        throw new Error('Inconsistent indentation of stanza')\n      }\n    } else {\n      this.indent = ''\n    }\n    const trimmedLine = combinedLine.trim()\n    const sep = trimmedLine.indexOf(' ')\n    if (sep === -1) {\n      if (!this.nameKey) {\n        throw new Error(\n          'First line in a stanza must have both a key and a value',\n        )\n      }\n      // Adding a key that already exists and has no value is a no-op\n      if (this.has(trimmedLine)) {\n        return this\n      }\n      this._keyAndCommentOrder.push(trimmedLine)\n      return super.set(trimmedLine, '')\n    }\n    const key = trimmedLine.slice(0, sep)\n    const value = trimmedLine.slice(sep + 1)\n    if (this.has(key) && value !== this.get(key)) {\n      throw new Error(\n        'Got duplicate key with a different value in stanza: ' +\n          `\"${key}\" key has both ${this.get(key)} and ${value}`,\n      )\n    }\n    this._keyAndCommentOrder.push(key)\n    if (!this.nameKey) {\n      this.nameKey = key\n      this.name = trimmedLine.slice(sep + 1)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, indentation, duplicate keys, etc.\n   * @param {string} key The key of the stanza line\n   * @param {string} value The value of the stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  set(key: string, value: string) {\n    if (!(typeof value === 'string')) {\n      throw new Error(`Value of ${key} must be a string, got ${typeof value}`)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Delete a line\n   * @param {string} key The key of the line to delete\n   * @returns {boolean} true if the deleted line existed, false if it did not\n   */\n  delete(key: string) {\n    if (key === this.nameKey) {\n      throw new Error(\n        'Cannot delete the first line in a stanza (you can still overwrite it with set()).',\n      )\n    }\n    if (this._keyAndCommentOrder.includes(key)) {\n      this._keyAndCommentOrder = this._keyAndCommentOrder.filter(\n        value => value !== key,\n      )\n    }\n    return super.delete(key)\n  }\n\n  /**\n   * Clear all lines and comments\n   */\n  clear() {\n    this._keyAndCommentOrder.length = 0\n    this._continuedLine = undefined\n    this.indent = undefined\n    this.name = undefined\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   * as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const lines = [] as string[]\n    this._keyAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        lines.push(`${this.indent}${entry}`)\n      } else {\n        lines.push(`${this.indent}${entry} ${this.get(entry)}`.trimEnd())\n      }\n    })\n    return `${lines.join('\\n')}\\n`\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile extends Map<string, RaStanza> {\n  _checkIndent: boolean\n\n  _stanzaAndCommentOrder: string[]\n\n  nameKey?: string\n\n  constructor(raFile: string, options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzas: string[]\n    if (typeof raFile === 'string') {\n      stanzas = raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n    } else if (!raFile) {\n      stanzas = []\n    } else {\n      stanzas = raFile\n    }\n    this._stanzaAndCommentOrder = []\n    stanzas.forEach(stanza => {\n      this.add(stanza)\n    })\n  }\n\n  /**\n   * Add a single stanza to the file\n   * @param {string} stanza A single stanza\n   * @returns {RaFile} The RaFile object\n   */\n  add(stanza: string) {\n    if (stanza === '') {\n      throw new Error('Invalid stanza, was empty')\n    }\n    if (stanza.trim().startsWith('#')) {\n      const stanzaLines = stanza\n        .trimEnd()\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n      if (stanzaLines.every(line => line.startsWith('#'))) {\n        this._stanzaAndCommentOrder.push(stanzaLines.join('\\n'))\n        return this\n      }\n    }\n    const raStanza = new RaStanza(stanza, { checkIndent: this._checkIndent })\n    if (!this.nameKey) {\n      this.nameKey = raStanza.nameKey\n    } else if (raStanza.nameKey !== this.nameKey) {\n      throw new Error(\n        'The first line in each stanza must have the same key. ' +\n          `Saw both ${this.nameKey} and ${raStanza.nameKey}`,\n      )\n    }\n    if (!raStanza.name) {\n      throw new Error(`No stanza name: ${raStanza.name}`)\n    }\n    if (this.has(raStanza.name)) {\n      throw new Error(`Got duplicate stanza name: ${raStanza.name}`)\n    }\n\n    this._stanzaAndCommentOrder.push(raStanza.name)\n    return super.set(raStanza.name, raStanza)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, empty stanzas, duplicate keys, etc.\n   * @param {string} key The key of the RaFile stanza\n   * @param {RaStanza} value The RaFile stanza used to replace the prior one\n   */\n  update(key: string, value: RaStanza) {\n    if (!(value instanceof RaStanza)) {\n      throw new Error(`Value of ${key} is not an RaStanza`)\n    }\n    super.set(key, value)\n  }\n\n  /**\n   * Delete a stanza\n   * @param {string} stanza The name of the stanza to delete (the value in its\n   * first key-value pair)\n   * @returns {boolean} true if the deleted stanza existed, false if it did not\n   */\n  delete(stanza: string) {\n    if (this._stanzaAndCommentOrder.includes(stanza)) {\n      this._stanzaAndCommentOrder = this._stanzaAndCommentOrder.filter(\n        value => value !== stanza,\n      )\n    }\n    return super.delete(stanza)\n  }\n\n  /**\n   * Clear all stanzas and comments\n   */\n  clear() {\n    this._stanzaAndCommentOrder.length = 0\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   *  as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const stanzas = [] as string[]\n    this._stanzaAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        stanzas.push(`${entry}\\n`)\n      } else {\n        const e = this.get(entry)\n        if (e) {\n          stanzas.push(e.toString())\n        }\n      }\n    })\n    return stanzas.join('\\n')\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n  constructor(trackDbFile: string) {\n    super(trackDbFile, { checkIndent: false })\n    if (this.nameKey !== 'track') {\n      throw new Error(\n        `trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`,\n      )\n    }\n    this.forEach((track, trackName) => {\n      const trackKeys = Array.from(track.keys())\n      const missingKeys = [] as string[]\n      const requiredKeys = ['track', 'shortLabel']\n      requiredKeys.forEach(key => {\n        if (!trackKeys.includes(key)) {\n          missingKeys.push(key)\n        }\n      })\n      if (missingKeys.length > 0) {\n        throw new Error(\n          `Track ${trackName} is missing required key(s): ${missingKeys.join(\n            ', ',\n          )}`,\n        )\n      }\n      const parentTrackKeys = [\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n      ]\n      if (!trackKeys.some(key => parentTrackKeys.includes(key))) {\n        if (!trackKeys.includes('bigDataUrl')) {\n          throw new Error(\n            `Track ${trackName} is missing required key \"bigDataUrl\"`,\n          )\n        }\n        if (!trackKeys.includes('type')) {\n          const settings = this.settings(trackName)\n          const settingsKeys = Array.from(settings.keys())\n          if (!settingsKeys.includes('type')) {\n            throw new Error(\n              `Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`,\n            )\n          }\n        }\n      }\n      let indent = ''\n      let currentTrackName: string | undefined = trackName\n      do {\n        currentTrackName = this.get(currentTrackName)?.get('parent')\n        if (currentTrackName) {\n          ;[currentTrackName] = currentTrackName.split(' ')\n          indent += '    '\n        }\n      } while (currentTrackName)\n      const currentTrack = this.get(trackName)\n      if (currentTrack) {\n        currentTrack.indent = indent\n        this.set(trackName, currentTrack)\n      }\n    })\n  }\n\n  /**\n   * Gets all track entries including those of parent tracks, with closer\n   * entries overriding more distant ones\n   * @param {string} trackName The name of a track\n   * @throws {Error} Throws if track name does not exist in the trackDb\n   */\n  settings(trackName: string) {\n    if (!this.has(trackName)) {\n      throw new Error(`Track ${trackName} does not exist`)\n    }\n    const parentTracks = [trackName]\n    let currentTrackName: string | undefined = trackName\n    do {\n      currentTrackName = this.get(currentTrackName)?.get('parent')\n      if (currentTrackName) {\n        parentTracks.push(currentTrackName)\n      }\n    } while (currentTrackName)\n    const settings = new Map()\n    parentTracks.reverse()\n    parentTracks.forEach(parentTrack => {\n      this.get(parentTrack)?.forEach((value, key) => {\n        settings.set(key, value)\n      })\n    })\n    return settings\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n  constructor(hubFile: string) {\n    super(hubFile)\n    if (this.nameKey !== 'hub') {\n      throw new Error('Hub file must begin with a line like \"hub <hub_name>\"')\n    }\n    const hubTxtFields = [\n      'hub',\n      'shortLabel',\n      'longLabel',\n      'genomesFile',\n      'email',\n      'descriptionUrl',\n    ]\n    const extraFields = [] as string[]\n    this.forEach((_value, key) => {\n      if (!hubTxtFields.includes(key)) {\n        extraFields.push(key)\n      }\n    })\n    if (extraFields.length > 0) {\n      throw new Error(\n        `Hub file has invalid entr${\n          extraFields.length === 1 ? 'y' : 'ies'\n        }: ${extraFields.join(', ')}`,\n      )\n    }\n    const missingFields = [] as string[]\n    hubTxtFields.forEach(field => {\n      if (field !== 'descriptionUrl' && !this.get(field)) {\n        missingFields.push(field)\n      }\n    })\n    if (missingFields.length > 0) {\n      throw new Error(\n        `Hub file is missing required entr${\n          missingFields.length === 1 ? 'y' : 'ies'\n        }: ${missingFields.join(', ')}`,\n      )\n    }\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n  constructor(genomesFile: string) {\n    super(genomesFile)\n    if (this.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n\n    // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n    const requiredFields = [\n      'genome',\n      'trackDb',\n      // 'twoBitPath',\n      // 'groups',\n    ]\n    this.forEach((genome, genomeName) => {\n      const missingFields = [] as string[]\n      requiredFields.forEach(field => {\n        if (!genome.get(field)) {\n          missingFields.push(field)\n        }\n      })\n      if (missingFields.length > 0) {\n        throw new Error(\n          `Genomes file entry ${genomeName} is missing required entr${\n            missingFields.length === 1 ? 'y' : 'ies'\n          }: ${missingFields.join(', ')}`,\n        )\n      }\n    })\n  }\n}\n"],"names":["RaStanza","stanza","options","checkIndent","stanzaLines","_checkIndent","trimEnd","split","_keyAndCommentOrder","forEach","line","add","Error","trim","startsWith","this","push","endsWith","trimmedLine","slice","_continuedLine","trimStart","combinedLine","undefined","indent","match","sep","indexOf","nameKey","has","key","value","get","name","includes","filter","length","size","lines","entry","join","Map","RaFile","raFile","stanzas","_stanzaAndCommentOrder","map","every","raStanza","e","toString","TrackDbFile","trackDbFile","track","trackName","trackKeys","Array","from","keys","missingKeys","parentTrackKeys","some","settings","currentTrackName","currentTrack","set","parentTracks","reverse","parentTrack","HubFile","hubFile","hubTxtFields","extraFields","_value","missingFields","field","GenomesFile","genomesFile","requiredFields","genome","genomeName"],"sourceRoot":""}