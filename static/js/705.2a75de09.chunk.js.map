{"version":3,"file":"static/js/705.2a75de09.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/ucsc-hub/src/raStanza.ts","../../../node_modules/@gmod/ucsc-hub/src/raFile.ts","../../../node_modules/@gmod/ucsc-hub/src/trackDbFile.ts","../../../node_modules/@gmod/ucsc-hub/src/hubFile.ts","../../../node_modules/@gmod/ucsc-hub/src/genomesFile.ts"],"sourcesContent":["/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza. An additional method `add()` is available to take a raw line of text\n * and break it up into a key and value and add them to the class. This should\n * be favored over `set()` when possible, as it performs more validity checks\n * than using `set()`.\n *\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of the\n * stanza (`undefined` if the stanza has no lines yet).\n *\n * @property {undefined|string} name - The value of the first line of the\n * stanza, by which it is identified in an ra file  (`undefined` if the stanza\n * has no lines yet).\n *\n * @property {undefined|string} indent - The leading indent of the stanza,\n * which is the same for every line (`undefined` if the stanza has no lines\n * yet, `''` if there is no indent).\n *\n * @throws {Error} Throws if the stanza has blank lines, if the first line\n * doesn't have both a key and a value, if a key in the stanza is\n * duplicated, or if lines in the stanza have inconsistent indentation.\n * @param {(string|string[])} [stanza=[]] - An ra file stanza, either as a\n * string or a array of strings with one line per entry. Supports both LF and\n * CRLF line terminators.\n *\n * @param {object} options\n *\n * @param {boolean} options.checkIndent [true] - Check if a stanza is indented\n * consistently and keep track of the indentation\n */\nexport default class RaStanza extends Map<string, string> {\n  _checkIndent: boolean\n\n  _keyAndCommentOrder: string[]\n\n  _continuedLine?: string\n\n  indent?: string\n\n  name?: string\n\n  nameKey?: string\n\n  constructor(stanza: string | string[], options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzaLines: string[]\n    if (typeof stanza === 'string') {\n      stanzaLines = stanza.trimEnd().split(/\\r?\\n/)\n    } else if (!stanza) {\n      stanzaLines = []\n    } else {\n      stanzaLines = stanza\n    }\n    this._keyAndCommentOrder = []\n    stanzaLines.forEach(line => {\n      this.add(line)\n    })\n  }\n\n  /**\n   * Add a single line to the stanza. If the exact line already exists, does\n   * nothing.\n   * @param {string} line A stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  add(line: string) {\n    if (line === '') {\n      throw new Error('Invalid stanza, contained blank lines')\n    }\n    if (line.trim().startsWith('#')) {\n      this._keyAndCommentOrder.push(line.trim())\n      return this\n    }\n    if (line.trimEnd().endsWith('\\\\')) {\n      const trimmedLine = line.trimEnd().slice(0, -1)\n      if (this._continuedLine) {\n        this._continuedLine += trimmedLine.trimStart()\n      } else {\n        this._continuedLine = trimmedLine\n      }\n      return this\n    }\n    let combinedLine = line\n    if (this._continuedLine) {\n      combinedLine = this._continuedLine + combinedLine.trimStart()\n      this._continuedLine = undefined\n    }\n    if (this.indent || this._checkIndent) {\n      const indent = combinedLine.match(/^([ \\t]+)/)\n      if (this.indent === undefined) {\n        if (indent) {\n          ;[, this.indent] = indent\n        } else {\n          this.indent = ''\n        }\n      } else if (\n        (this.indent === '' && indent !== null) ||\n        (this.indent && indent && this.indent !== indent[1])\n      ) {\n        throw new Error('Inconsistent indentation of stanza')\n      }\n    } else {\n      this.indent = ''\n    }\n    const trimmedLine = combinedLine.trim()\n    const sep = trimmedLine.indexOf(' ')\n    if (sep === -1) {\n      if (!this.nameKey) {\n        throw new Error(\n          'First line in a stanza must have both a key and a value',\n        )\n      }\n      // Adding a key that already exists and has no value is a no-op\n      if (this.has(trimmedLine)) {\n        return this\n      }\n      this._keyAndCommentOrder.push(trimmedLine)\n      return super.set(trimmedLine, '')\n    }\n    const key = trimmedLine.slice(0, sep)\n    const value = trimmedLine.slice(sep + 1)\n    if (this.has(key) && value !== this.get(key)) {\n      throw new Error(\n        'Got duplicate key with a different value in stanza: ' +\n          `\"${key}\" key has both ${this.get(key)} and ${value}`,\n      )\n    }\n    this._keyAndCommentOrder.push(key)\n    if (!this.nameKey) {\n      this.nameKey = key\n      this.name = trimmedLine.slice(sep + 1)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, indentation, duplicate keys, etc.\n   * @param {string} key The key of the stanza line\n   * @param {string} value The value of the stanza line\n   * @returns {RaStanza} The RaStanza object\n   */\n  set(key: string, value: string) {\n    if (!(typeof value === 'string')) {\n      throw new Error(`Value of ${key} must be a string, got ${typeof value}`)\n    }\n    return super.set(key, value)\n  }\n\n  /**\n   * Delete a line\n   * @param {string} key The key of the line to delete\n   * @returns {boolean} true if the deleted line existed, false if it did not\n   */\n  delete(key: string) {\n    if (key === this.nameKey) {\n      throw new Error(\n        'Cannot delete the first line in a stanza (you can still overwrite it with set()).',\n      )\n    }\n    if (this._keyAndCommentOrder.includes(key)) {\n      this._keyAndCommentOrder = this._keyAndCommentOrder.filter(\n        value => value !== key,\n      )\n    }\n    return super.delete(key)\n  }\n\n  /**\n   * Clear all lines and comments\n   */\n  clear() {\n    this._keyAndCommentOrder.length = 0\n    this._continuedLine = undefined\n    this.indent = undefined\n    this.name = undefined\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   * as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const lines = [] as string[]\n    this._keyAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        lines.push(`${this.indent}${entry}`)\n      } else {\n        lines.push(`${this.indent}${entry} ${this.get(entry)}`.trimEnd())\n      }\n    })\n    return `${lines.join('\\n')}\\n`\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @extends Map\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile extends Map<string, RaStanza> {\n  _checkIndent: boolean\n\n  _stanzaAndCommentOrder: string[]\n\n  nameKey?: string\n\n  constructor(raFile: string, options = { checkIndent: true }) {\n    super()\n    const { checkIndent } = options\n    this._checkIndent = checkIndent\n    let stanzas: string[]\n    if (typeof raFile === 'string') {\n      stanzas = raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n    } else if (!raFile) {\n      stanzas = []\n    } else {\n      stanzas = raFile\n    }\n    this._stanzaAndCommentOrder = []\n    stanzas.forEach(stanza => {\n      this.add(stanza)\n    })\n  }\n\n  /**\n   * Add a single stanza to the file\n   * @param {string} stanza A single stanza\n   * @returns {RaFile} The RaFile object\n   */\n  add(stanza: string) {\n    if (stanza === '') {\n      throw new Error('Invalid stanza, was empty')\n    }\n    if (stanza.trim().startsWith('#')) {\n      const stanzaLines = stanza\n        .trimEnd()\n        .split(/\\r?\\n/)\n        .map(line => line.trim())\n      if (stanzaLines.every(line => line.startsWith('#'))) {\n        this._stanzaAndCommentOrder.push(stanzaLines.join('\\n'))\n        return this\n      }\n    }\n    const raStanza = new RaStanza(stanza, { checkIndent: this._checkIndent })\n    if (!this.nameKey) {\n      this.nameKey = raStanza.nameKey\n    } else if (raStanza.nameKey !== this.nameKey) {\n      throw new Error(\n        'The first line in each stanza must have the same key. ' +\n          `Saw both ${this.nameKey} and ${raStanza.nameKey}`,\n      )\n    }\n    if (!raStanza.name) {\n      throw new Error(`No stanza name: ${raStanza.name}`)\n    }\n    if (this.has(raStanza.name)) {\n      throw new Error(`Got duplicate stanza name: ${raStanza.name}`)\n    }\n\n    this._stanzaAndCommentOrder.push(raStanza.name)\n    return super.set(raStanza.name, raStanza)\n  }\n\n  /**\n   * Use `add()` if possible instead of this method. If using this, be aware\n   * that no checks are made for comments, empty stanzas, duplicate keys, etc.\n   * @param {string} key The key of the RaFile stanza\n   * @param {RaStanza} value The RaFile stanza used to replace the prior one\n   */\n  update(key: string, value: RaStanza) {\n    if (!(value instanceof RaStanza)) {\n      throw new Error(`Value of ${key} is not an RaStanza`)\n    }\n    super.set(key, value)\n  }\n\n  /**\n   * Delete a stanza\n   * @param {string} stanza The name of the stanza to delete (the value in its\n   * first key-value pair)\n   * @returns {boolean} true if the deleted stanza existed, false if it did not\n   */\n  delete(stanza: string) {\n    if (this._stanzaAndCommentOrder.includes(stanza)) {\n      this._stanzaAndCommentOrder = this._stanzaAndCommentOrder.filter(\n        value => value !== stanza,\n      )\n    }\n    return super.delete(stanza)\n  }\n\n  /**\n   * Clear all stanzas and comments\n   */\n  clear() {\n    this._stanzaAndCommentOrder.length = 0\n    this.nameKey = undefined\n    super.clear()\n  }\n\n  /**\n   * @returns {string} Returns the stanza as a string fit for writing to a ra\n   * file. Original leading indent is preserved. It may not be the same as the\n   * input stanza as lines that were joined with `\\` in the input will be output\n   *  as a single line and all comments will have the same indentations as the\n   * rest of the stanza. Comments between joined lines will move before that\n   * line.\n   */\n  toString() {\n    if (this.size === 0) {\n      return ''\n    }\n    const stanzas = [] as string[]\n    this._stanzaAndCommentOrder.forEach(entry => {\n      if (entry.startsWith('#')) {\n        stanzas.push(`${entry}\\n`)\n      } else {\n        const e = this.get(entry)\n        if (e) {\n          stanzas.push(e.toString())\n        }\n      }\n    })\n    return stanzas.join('\\n')\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n  constructor(trackDbFile: string) {\n    super(trackDbFile, { checkIndent: false })\n    if (this.nameKey !== 'track') {\n      throw new Error(\n        `trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`,\n      )\n    }\n    this.forEach((track, trackName) => {\n      const trackKeys = Array.from(track.keys())\n      const missingKeys = [] as string[]\n      const requiredKeys = ['track', 'shortLabel']\n      requiredKeys.forEach(key => {\n        if (!trackKeys.includes(key)) {\n          missingKeys.push(key)\n        }\n      })\n      if (missingKeys.length > 0) {\n        throw new Error(\n          `Track ${trackName} is missing required key(s): ${missingKeys.join(\n            ', ',\n          )}`,\n        )\n      }\n      const parentTrackKeys = [\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n      ]\n      if (!trackKeys.some(key => parentTrackKeys.includes(key))) {\n        if (!trackKeys.includes('bigDataUrl')) {\n          throw new Error(\n            `Track ${trackName} is missing required key \"bigDataUrl\"`,\n          )\n        }\n        if (!trackKeys.includes('type')) {\n          const settings = this.settings(trackName)\n          const settingsKeys = Array.from(settings.keys())\n          if (!settingsKeys.includes('type')) {\n            throw new Error(\n              `Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`,\n            )\n          }\n        }\n      }\n      let indent = ''\n      let currentTrackName: string | undefined = trackName\n      do {\n        currentTrackName = this.get(currentTrackName)?.get('parent')\n        if (currentTrackName) {\n          ;[currentTrackName] = currentTrackName.split(' ')\n          indent += '    '\n        }\n      } while (currentTrackName)\n      const currentTrack = this.get(trackName)\n      if (currentTrack) {\n        currentTrack.indent = indent\n        this.set(trackName, currentTrack)\n      }\n    })\n  }\n\n  /**\n   * Gets all track entries including those of parent tracks, with closer\n   * entries overriding more distant ones\n   * @param {string} trackName The name of a track\n   * @throws {Error} Throws if track name does not exist in the trackDb\n   */\n  settings(trackName: string) {\n    if (!this.has(trackName)) {\n      throw new Error(`Track ${trackName} does not exist`)\n    }\n    const parentTracks = [trackName]\n    let currentTrackName: string | undefined = trackName\n    do {\n      currentTrackName = this.get(currentTrackName)?.get('parent')\n      if (currentTrackName) {\n        parentTracks.push(currentTrackName)\n      }\n    } while (currentTrackName)\n    const settings = new Map()\n    parentTracks.reverse()\n    parentTracks.forEach(parentTrack => {\n      this.get(parentTrack)?.forEach((value, key) => {\n        settings.set(key, value)\n      })\n    })\n    return settings\n  }\n}\n","import RaStanza from './raStanza'\n\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n  constructor(hubFile: string) {\n    super(hubFile)\n    if (this.nameKey !== 'hub') {\n      throw new Error('Hub file must begin with a line like \"hub <hub_name>\"')\n    }\n    const hubTxtFields = [\n      'hub',\n      'shortLabel',\n      'longLabel',\n      'genomesFile',\n      'email',\n      'descriptionUrl',\n    ]\n    const extraFields = [] as string[]\n    this.forEach((_value, key) => {\n      if (!hubTxtFields.includes(key)) {\n        extraFields.push(key)\n      }\n    })\n    if (extraFields.length > 0) {\n      throw new Error(\n        `Hub file has invalid entr${\n          extraFields.length === 1 ? 'y' : 'ies'\n        }: ${extraFields.join(', ')}`,\n      )\n    }\n    const missingFields = [] as string[]\n    hubTxtFields.forEach(field => {\n      if (field !== 'descriptionUrl' && !this.get(field)) {\n        missingFields.push(field)\n      }\n    })\n    if (missingFields.length > 0) {\n      throw new Error(\n        `Hub file is missing required entr${\n          missingFields.length === 1 ? 'y' : 'ies'\n        }: ${missingFields.join(', ')}`,\n      )\n    }\n  }\n}\n","import RaFile from './raFile'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n  constructor(genomesFile: string) {\n    super(genomesFile)\n    if (this.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n\n    // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n    const requiredFields = [\n      'genome',\n      'trackDb',\n      // 'twoBitPath',\n      // 'groups',\n    ]\n    this.forEach((genome, genomeName) => {\n      const missingFields = [] as string[]\n      requiredFields.forEach(field => {\n        if (!genome.get(field)) {\n          missingFields.push(field)\n        }\n      })\n      if (missingFields.length > 0) {\n        throw new Error(\n          `Genomes file entry ${genomeName} is missing required entr${\n            missingFields.length === 1 ? 'y' : 'ies'\n          }: ${missingFields.join(', ')}`,\n        )\n      }\n    })\n  }\n}\n"],"names":["RaStanza","_Map","_inherits","_super","_createSuper","stanza","_this","options","arguments","length","undefined","checkIndent","_classCallCheck","call","stanzaLines","_checkIndent","trimEnd","split","_keyAndCommentOrder","forEach","line","add","_createClass","key","value","Error","trim","startsWith","this","push","endsWith","trimmedLine","slice","_continuedLine","trimStart","combinedLine","indent","match","_indent","_slicedToArray","sep","indexOf","nameKey","has","_get","_getPrototypeOf","prototype","get","concat","name","includes","filter","_this2","size","lines","entry","join","_wrapNativeSuper","Map","RaFile","raFile","stanzas","_stanzaAndCommentOrder","map","every","raStanza","e","toString","TrackDbFile","_RaFile","trackDbFile","track","trackName","trackKeys","Array","from","keys","missingKeys","parentTrackKeys","some","settings","currentTrackName","_a","_currentTrackName$spl","currentTrack","set","parentTracks","reverse","parentTrack","HubFile","_RaStanza","hubFile","hubTxtFields","extraFields","_value","missingFields","field","GenomesFile","genomesFile","requiredFields","genome","genomeName"],"sourceRoot":""}